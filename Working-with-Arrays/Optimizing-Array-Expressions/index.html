<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Optimizing Array Expressions</title><link rel="stylesheet" href="../../book.css">
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <script src="../../static/katex/katex.min.js"></script>
    <script src="../../static/math.js"></script>
    <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="../../-verso-js/popper.js"></script>
    <script src="../../-verso-js/tippy.js"></script>
    <link rel="stylesheet" href="../../static/theme.css">
    <link rel="stylesheet" href="../../static/inter/inter.css">
    <link rel="stylesheet" href="../../static/firacode/fira_code.css">
    <link rel="stylesheet" href="../../static/katex/katex.min.css">
    <link rel="stylesheet" href="../../-verso-css/tippy-border.css">
    <style>
div.collapsible-hint {
  margin: 5px 0;
}

div.collapsible-hint-header {
  padding: 2px;
  font-size: medium;
  cursor: pointer;
  position: relative;
}

div.collapsible-hint-header::after {
  content: "⊢";
  position: absolute;
  left: 50px;
  transition: transform 0.3s ease;
}

div.collapsible-hint-content {
  border: 1px solid white;
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease;
}

div.collapsible-hint.expanded .collapsible-hint-content {
  max-height: 500px; /* Adjust this value depending on the content's height */
  border: 1px solid lightgrey;
}

div.collapsible-hint.expanded .collapsible-hint-header::after {
  transform: rotate(90deg); /* Rotate to show ">" when expanded */
}
</style><style>

.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
}

.hl.lean .keyword {
  font-weight : bold;
}

.hl.lean .var {
  font-style: italic;
  position: relative;
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5em;
  z-index: 300;
  font-size: inherit;
}

.hl.lean .hover-info.messages {
  max-height: 10em;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5em 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5em;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1em;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0em;
}

/*
@media (hover: hover) {
  .hl.lean .has-info:hover > .hover-container > .hover-info:not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .has-info:hover > .hover-container > .hover-info,
  .hl.lean .token:hover > .hover-container > .hover-info:not(.has-info *):not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .token:hover > .hover-container > .hover-info:not(.has-info *) {
    display: inline-block;
    position: absolute;
    top: 1em;
    font-weight: normal;
    font-style: normal;
    width: min-content;
  }
}
*/

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: 0.1rem;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5em;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error {
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2em solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error pre {
    color: red;
}

.hl.lean .has-info.warning {
  text-decoration-color: #efd871;
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color: #efd871;
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: #efd871;
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2em solid #efd871;
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.info {
  text-decoration-color: blue;
}

@media (hover: hover) {
  .hl.lean .has-info.info:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.info {
  background-color: #e5e5e5;
  border-left: 0.2em solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.info {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: sans-serif;
  white-space: normal;
  max-width: 40em;
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1em;
  margin-right: 1em;
  margin-top: 0.5em;
  margin-bottom: 0.5em;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: monospace;
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  left: 2em;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1em;
  padding: 0.5em;
  font-family: sans-serif;
  background-color: #ffffff;
  z-index: 200;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5em;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: block;
}

/*
@media (hover: hover) {
  .hl.lean .tactic:hover > .tactic-toggle:not(:checked) ~ .tactic-state {
    display: block;
    position: absolute;
    left: 0;
    transform: translate(0.25rem, 0);
    z-index: 250;
  }
}
*/

.hl.lean .tactic > label {
  position: relative;
  transition: all 0.5s;
}

@media (hover: hover) {
  .hl.lean .tactic > label:hover {
    border-bottom: 1px dotted #bbbbbb;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  border-radius: 1em;
  height: 0.25em;
  vertical-align: middle;
  width: 0.6em;
  margin-left: 0.1em;
  margin-right: 0.1em;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5em;
}

.hl.lean .tactic-state summary {
  margin-left: -0.5em;
}

.hl.lean .tactic-state details {
  padding-left: 0.5em;
}

.hl.lean .tactic-state .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .tactic-state .goal-name {
  font-style: italic;
  font-family: monospace;
}

.hl.lean .tactic-state .hypotheses td.colon {
  text-align: center;
  min-width: 1em;
}

.hl.lean .tactic-state .hypotheses td.name {
  text-align: right;
}

.hl.lean .tactic-state .hypotheses td.name,
.hl.lean .tactic-state .hypotheses td.type,
.hl.lean .tactic-state .conclusion .type {
  font-family: monospace;
}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #efd871;
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}



.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}

</style><style>
div.TODO {
  border: 5px solid red;
  position: relative;
}
div.TODO::before {
  content: "TODO";
  position: absolute;
  top: 0;
  right: 0;
  color: red;
  font-size: large;
  font-weight: bold;
  transform: rotate(-90deg) translate(-2em);
}
</style><style>
div.collapsible {
  margin: 5px 0;
}

div.collapsible-header {
  padding: 2px;
  font-size: medium;
  cursor: pointer;
  position: relative;
}

div.collapsible-header::after {
  content: "⊢";
  position: absolute;
  left: 60px;
  transition: transform 0.3s ease;
}

div.collapsible-content {
  border: 1px solid white;
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease;
}

div.collapsible.expanded .collapsible-content {
  max-height: 500px; /* Adjust this value depending on the content's height */
  border: 1px solid lightgrey;
}

div.collapsible.expanded .collapsible-header::after {
  transform: rotate(90deg); /* Rotate to show ">" when expanded */
}
</style><script>
      
window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    fetch("/-verso-docs.json").then((resp) => resp.json()).then((versoDocData) => {

      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        theme: "lean",
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        ignoreAttributes: true,
        onShow(inst) {
          if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          content.className = "hl lean";
          content.style.display = "block";
          content.style.maxHeight = "300px";
          content.style.overflowY = "auto";
          content.style.overflowX = "hidden";
          const hoverId = tgt.dataset.versoHover;
          const hoverInfo = tgt.querySelector(".hover-info");
          if (hoverId) { // Docstrings from the table
            // TODO stop doing an implicit conversion from string to number here
            let data = versoDocData[hoverId];
            if (data) {
              const info = document.createElement("span");
              info.className = "hover-info";
              info.style.display = "block";
              info.innerHTML = data;
              content.appendChild(info);
              /* Render docstrings - TODO server-side */
              if ('undefined' !== typeof marked) {
                  for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                      const str = d.innerText;
                      const html = marked.parse(str);
                      const rendered = document.createElement("div");
                      rendered.classList.add("docstring");
                      rendered.innerHTML = html;
                      d.parentNode.replaceChild(rendered, d);
                  }
              }
            } else {
              content.innerHTML = "Failed to load doc ID: " + hoverId;
            }
          } else if (hoverInfo) { // The inline info, still used for compiler messages
            content.appendChild(hoverInfo.cloneNode(true));
          }
          return content;
        }
      };

      const addTippy = (selector, props) => {
        tippy(selector, Object.assign({}, defaultTippyProps, props));
      };
      addTippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token', {theme: 'lean'});
      addTippy('.hl.lean .has-info.warning', {theme: 'warning message'});
      addTippy('.hl.lean .has-info.info', {theme: 'info message'});
      addTippy('.hl.lean .has-info.error', {theme: 'error message'});

      tippy('.hl.lean .tactic', {
        allowHtml: true,
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        maxWidth: "none",
        onShow(inst) {
          const toggle = inst.reference.querySelector("input.tactic-toggle");
          if (toggle && toggle.checked) {
            return false;
          }
          if (blockedByTippy(inst.reference)) { return false; }
        },
        theme: "tactic",
        placement: 'bottom-start',
        content (tgt) {
          const content = document.createElement("span");
          const state = tgt.querySelector(".tactic-state").cloneNode(true);
          state.style.display = "block";
          content.appendChild(state);
          content.style.display = "block";
          content.className = "hl lean popup";
          return content;
        }
      });
  });
}
</script>
    </head>
  <body>
    <div class="with-toc">
      <header>
        <h1>
          <a href="../../">Scientific Computing in Lean</a></h1>
        <div id="controls">
          <label for="toggle-toc" id="toggle-toc-click">📖</label></div>
        <div id="print">
          <span>🖨</span></div>
        </header>
      <nav id="toc">
        <input type="checkbox" id="toggle-toc" checked="checked"><ol>
          <li>
            <a href="../../Introduction#Scientific-Computing-in-Lean--Introduction">Introduction</a><ol>
              <li>
                <a href="../../Introduction/About#Scientific-Computing-in-Lean--Introduction--About">About</a></li>
              <li>
                <a href="../../Introduction/Introduction#Scientific-Computing-in-Lean--Introduction--Introduction">Introduction</a><ol>
                  <li>
                    <a href="../../Introduction/Introduction#Scientific-Computing-in-Lean--Introduction--Introduction--Why-Lean-for-Scientific-Computing">Why Lean for Scientific Computing?</a></li>
                  </ol>
                </li>
              </ol>
            </li>
          <li>
            <a href="../../Working-with-Arrays#Scientific-Computing-in-Lean--Working-with-Arrays">Working with Arrays</a><ol>
              <li>
                <a href="../../Working-with-Arrays/Basic-Operations#Scientific-Computing-in-Lean--Working-with-Arrays--Basic-Operations">Basic Operations</a><ol>
                  <li>
                    <a href="../../Working-with-Arrays/Basic-Operations#Scientific-Computing-in-Lean--Working-with-Arrays--Basic-Operations--Reshaping-Arrays">Reshaping Arrays</a></li>
                  <li>
                    <a href="../../Working-with-Arrays/Basic-Operations#Scientific-Computing-in-Lean--Working-with-Arrays--Basic-Operations--Exercises">Exercises</a></li>
                  </ol>
                </li>
              <li>
                <a href="../../Working-with-Arrays/Tensor-Operations#Scientific-Computing-in-Lean--Working-with-Arrays--Tensor-Operations">Tensor Operations</a><ol>
                  <li>
                    <a href="../../Working-with-Arrays/Tensor-Operations#Scientific-Computing-in-Lean--Working-with-Arrays--Tensor-Operations--Transformations-and-Reductions">Transformations and Reductions</a></li>
                  <li>
                    <a href="../../Working-with-Arrays/Tensor-Operations#Scientific-Computing-in-Lean--Working-with-Arrays--Tensor-Operations--Convolution-and-Operations-on-Indices">Convolution and Operations on Indices</a></li>
                  <li>
                    <a href="../../Working-with-Arrays/Tensor-Operations#Scientific-Computing-in-Lean--Working-with-Arrays--Tensor-Operations--Pooling-and-Difficulties-with-Dependent-Types">Pooling and Difficulties with Dependent Types</a></li>
                  <li>
                    <a href="../../Working-with-Arrays/Tensor-Operations#Scientific-Computing-in-Lean--Working-with-Arrays--Tensor-Operations--Simple-Neural-Network">Simple Neural Network</a></li>
                  </ol>
                </li>
              <li>
                <a href="../../Working-with-Arrays/Optimizing-Array-Expressions#Scientific-Computing-in-Lean--Working-with-Arrays--Optimizing-Array-Expressions">Optimizing Array Expressions</a><ol>
                  <li>
                    <a href="../../Working-with-Arrays/Optimizing-Array-Expressions#Scientific-Computing-in-Lean--Working-with-Arrays--Optimizing-Array-Expressions--Loop-Fusion">Loop Fusion</a></li>
                  <li>
                    <a href="../../Working-with-Arrays/Optimizing-Array-Expressions#Scientific-Computing-in-Lean--Working-with-Arrays--Optimizing-Array-Expressions--Optimizing-Array-Indexing">Optimizing Array Indexing</a></li>
                  </ol>
                </li>
              </ol>
            </li>
          <li>
            <a href="../../Differentiation#Scientific-Computing-in-Lean--Differentiation">Differentiation</a><ol>
              <li>
                <a href="../../Differentiation/Symbolic-Differentiation#Scientific-Computing-in-Lean--Differentiation--Symbolic-Differentiation">Symbolic Differentiation</a><ol>
                  <li>
                    <a href="../../Differentiation/Symbolic-Differentiation#Scientific-Computing-in-Lean--Differentiation--Symbolic-Differentiation--Notation">Notation</a></li>
                  <li>
                    <a href="../../Differentiation/Symbolic-Differentiation#Scientific-Computing-in-Lean--Differentiation--Symbolic-Differentiation--Examples">Examples</a></li>
                  <li>
                    <a href="../../Differentiation/Symbolic-Differentiation#Scientific-Computing-in-Lean--Differentiation--Symbolic-Differentiation--Gradient">Gradient</a></li>
                  <li>
                    <a href="../../Differentiation/Symbolic-Differentiation#Scientific-Computing-in-Lean--Differentiation--Symbolic-Differentiation--Derivative-Rules">Derivative Rules</a></li>
                  <li>
                    <a href="../../Differentiation/Symbolic-Differentiation#Scientific-Computing-in-Lean--Differentiation--Symbolic-Differentiation--Differentiating-Division-Log-Sqrt-">Differentiating Division, Log, Sqrt, ...</a></li>
                  <li>
                    <a href="../../Differentiation/Symbolic-Differentiation#Scientific-Computing-in-Lean--Differentiation--Symbolic-Differentiation--Abstract-Vector-Spaces">Abstract Vector Spaces</a></li>
                  </ol>
                </li>
              <li>
                <a href="../../Differentiation/Automatic-Differentiation#Scientific-Computing-in-Lean--Differentiation--Automatic-Differentiation">Automatic Differentiation</a><ol>
                  <li>
                    <a href="../../Differentiation/Automatic-Differentiation#Scientific-Computing-in-Lean--Differentiation--Automatic-Differentiation--Forward-Mode">Forward Mode</a></li>
                  <li>
                    <a href="../../Differentiation/Automatic-Differentiation#Scientific-Computing-in-Lean--Differentiation--Automatic-Differentiation--Reverse-Mode">Reverse Mode</a></li>
                  <li>
                    <a href="../../Differentiation/Automatic-Differentiation#Scientific-Computing-in-Lean--Differentiation--Automatic-Differentiation--Derivatives-of-Neural-Network-Layers">Derivatives of Neural Network Layers</a></li>
                  </ol>
                </li>
              <li>
                <a href="../../Differentiation/Function-Transformation#Scientific-Computing-in-Lean--Differentiation--Function-Transformation">Function Transformation</a><ol>
                  <li>
                    <a href="../../Differentiation/Function-Transformation#Scientific-Computing-in-Lean--Differentiation--Function-Transformation--User-Defined-Function-Transformation">User Defined Function Transformation</a></li>
                  <li>
                    <a href="../../Differentiation/Function-Transformation#Scientific-Computing-in-Lean--Differentiation--Function-Transformation--Lambda-Theorems">Lambda Theorems</a></li>
                  <li>
                    <a href="../../Differentiation/Function-Transformation#Scientific-Computing-in-Lean--Differentiation--Function-Transformation--Function-Theorems">Function Theorems</a></li>
                  <li>
                    <a href="../../Differentiation/Function-Transformation#Scientific-Computing-in-Lean--Differentiation--Function-Transformation--Free-Variable-Theorems">Free Variable Theorems</a></li>
                  <li>
                    <a href="../../Differentiation/Function-Transformation#Scientific-Computing-in-Lean--Differentiation--Function-Transformation--Morphism-Theorems">Morphism Theorems</a></li>
                  <li>
                    <a href="../../Differentiation/Function-Transformation#Scientific-Computing-in-Lean--Differentiation--Function-Transformation--Advanced-Function-Theorems">Advanced Function Theorems</a></li>
                  </ol>
                </li>
              </ol>
            </li>
          <li>
            <a href="../../Examples#Scientific-Computing-in-Lean--Examples">Examples</a><ol>
              <li>
                <a href="../../Examples/Harmonic-Oscillator#Scientific-Computing-in-Lean--Examples--Harmonic-Oscillator">Harmonic Oscillator</a></li>
              </ol>
            </li>
          </ol>
        </nav>
      <main><section>
          <h1>
            Optimizing Array Expressions</h1>
          <p>
            Lean is an interactive theorem prover. In this chapter, we will demonstrate how to use Lean as an interactive compiler or computer algebra system. We will focus on a common compiler optimization with arrays: loop fusion, which involves merging two loops into one. We will show how to craft such optimizations, explore them interactively, and discuss how to automate them.</p>
          <p>
            Program optimization can be seen as rewriting a program into another program that is equivalent. By "equivalent," we mean that for the same input, these programs produce the same output. There is a close parallel to theorem proving. Often, to prove equality <code>x = y</code>, we simplify <code>x</code> to <code>x'</code> and <code>y</code> to <code>y'</code>. If <code>x'</code> is identical to <code>y'</code>, we have proven that <code>x = y</code>. Lean provides a general-purpose expression simplifier called <code>simp</code>, which has a database of rewrite rules and tries to apply them to subexpressions.</p>
          <p>
            For example, in Lean, there is a theorem stating that adding zero does not change the value:</p>
          <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-1509" data-verso-hover="34">namespace</span> <span class="unknown token" data-binding="">OptimizingArrays</span>
<span class="unknown token" data-binding="">@[</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.simp-1538" data-verso-hover="189">simp</span><span class="unknown token" data-binding="">]</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-1544">theorem</span> <span class="const token" data-binding="const-OptimizingArrays.Nat.add_zero" data-verso-hover="190">Nat.add_zero</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">n</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">n</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">0</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">n</span> <span class="unknown token" data-binding="">:=</span> <span class="const token" data-binding="const-rfl" data-verso-hover="191">rfl</span>
<span class="unknown token" data-binding=""></span></code><p>
            Adding the attribute <code>@[simp]</code> adds this theorem to the <code>simp</code> database of theorems it tries to apply.</p>
          <p>
            We can simplify any expression <code>e</code> by using <code>e rewrite_by simp</code>:</p>
          <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">5 : ℕ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-1796">#check</span></span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">0</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">5</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">0</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-SciLean.term_Rewrite_byAssuming__-1803">rewrite_by</span> <span class="tactic"><label for="tactic-state-11662964618036929249-1826-1830"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.Conv.simp-1826" data-verso-hover="192">simp</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11662964618036929249-1826-1830"><div class="tactic-state"><div class="goal"><span class="conclusion"><span class="prefix">| </span><span class="type">5</span></span></div></div></span>
<span class="unknown token" data-binding=""></span></code><div class="information">
            <pre>5 : ℕ
</pre></div>
          <p>
            This returns <code>5 : ℕ</code>, showing that all the zero additions have been eliminated. We can inspect what the simplifier did by turning on some options:</p>
          <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-2052" data-verso-hover="193">set_option</span> <span class="option token" data-binding="option-Lean.initFn._@.Lean.Meta.Tactic.Simp._hyg.123" data-verso-hover="194">trace.Meta.Tactic.simp.rewrite</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-2052" data-verso-hover="193">true</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.in-2052">in</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">5 : ℕ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-2102">#check</span></span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">0</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">5</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">0</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-SciLean.term_Rewrite_byAssuming__-2109">rewrite_by</span> <span class="tactic"><label for="tactic-state-11662964618036929249-2132-2136"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.Conv.simp-2132" data-verso-hover="192">simp</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11662964618036929249-2132-2136"><div class="tactic-state"><div class="goal"><span class="conclusion"><span class="prefix">| </span><span class="type">5</span></span></div></div></span>
<span class="unknown token" data-binding=""></span></code><pre>[Meta.Tactic.simp.rewrite] zero_add:1000, 0 + 5 ==&gt; 5
[Meta.Tactic.simp.rewrite] add_zero:1000, 5 + 0 ==&gt; 5
</pre><p>
            We can see that the simplifier first simplifies the subexpression <code>0 + 5</code> to <code>5</code> and then <code>5 + 0</code> to <code>5</code>.</p>
          <p>
            The simplifier has many options and configurations. By default, <code>simp</code> uses all the theorems marked with <code>simp</code>. However, it is often useful to narrow it down to a specific set of theorems. You can do this by using <code>simp only</code>, which does not use any theorems at all, performing only basic lambda calculus reductions, like beta reduction, which turns <code>(fun x =&gt; f x) y</code> into <code>f y</code>. To explicitly specify a set of theorems to use, use square brackets:</p>
          <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">0 + 5 : ℕ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-2844">#check</span></span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">0</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">5</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">0</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-SciLean.term_Rewrite_byAssuming__-2851">rewrite_by</span> <span class="tactic"><label for="tactic-state-15648039267169773155-2874-2894"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.Conv.simp-2874" data-verso-hover="192">simp</span> <span class="keyword token" data-binding="kw-occ-null-2879">only</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-add_zero" data-verso-hover="195">add_zero</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-15648039267169773155-2874-2894"><div class="tactic-state"><div class="goal"><span class="conclusion"><span class="prefix">| </span><span class="type">0<span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="156"> + </span>5</span></span></div></div></span>
<span class="unknown token" data-binding=""></span></code><div class="information">
            <pre>0 + 5 : ℕ
</pre></div>
          <p>
            This produces <code>0 + 5</code>, as only the rewrite rule <code>add_zero</code> is allowed.</p>
          <section>
            <h2 id="Scientific-Computing-in-Lean--Working-with-Arrays--Optimizing-Array-Expressions--Loop-Fusion">
              Loop Fusion</h2>
            <p>
              This theorem illustrates the concept of loop fusion, which is relevant to program optimization. Consider the theorem:</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-3157" data-verso-hover="13">open</span> <span class="unknown token" data-binding="">SciLean</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-3170">theorem</span> <span class="const token" data-binding="const-mapMono_mapMono" data-verso-hover="196">mapMono_mapMono</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="39">I</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="">Type</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-SciLean.IndexType" data-verso-hover="41">IndexType</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="39">I</span><span class="unknown token" data-binding="">]</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="86">x</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span><span class="unknown token" data-binding="">^[</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="39">I</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="93">f</span> <span class="var token" data-binding="var-_uniq.21" data-verso-hover="93">g</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="86">x</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-SciLean.DataArrayN.mapMono" data-verso-hover="94">mapMono</span> <span class="var token" data-binding="var-_uniq.17" data-verso-hover="93">f</span> <span class="unknown token" data-binding="">|&gt;.</span><span class="const token" data-binding="const-SciLean.DataArrayN.mapMono" data-verso-hover="94">mapMono</span> <span class="var token" data-binding="var-_uniq.21" data-verso-hover="93">g</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.13" data-verso-hover="86">x</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-SciLean.DataArrayN.mapMono" data-verso-hover="94">mapMono</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-3308">fun</span> <span class="var token" data-binding="var-_uniq.67" data-verso-hover="81">x</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.21" data-verso-hover="93">g</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="93">f</span> <span class="var token" data-binding="var-_uniq.67" data-verso-hover="81">x</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-10341989209332850279-3328-3330"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-3328" data-verso-hover="69">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-10341989209332850279-3328-3330"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="39">I</span></td><td class="colon">:</td><td class="type"><span class="sort token" data-binding="">Type</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.73" data-verso-hover="197">inst✝</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-SciLean.IndexType" data-verso-hover="41">IndexType</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="39">I</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.13" data-verso-hover="86">x</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>^[<span class="var token" data-binding="var-_uniq.2" data-verso-hover="39">I</span>]</td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.17" data-verso-hover="93">f</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span> → <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.21" data-verso-hover="93">g</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span> → <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type">(<span class="var token" data-binding="var-_uniq.13" data-verso-hover="86">x</span>.mapMono <span class="var token" data-binding="var-_uniq.17" data-verso-hover="93">f</span>).mapMono <span class="var token" data-binding="var-_uniq.21" data-verso-hover="93">g</span><span class="const token" data-binding="const-Eq" data-verso-hover="72"> = </span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="86">x</span>.mapMono <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.317" data-verso-hover="81">x</span> =&gt; <span class="var token" data-binding="var-_uniq.21" data-verso-hover="93">g</span> (<span class="var token" data-binding="var-_uniq.17" data-verso-hover="93">f</span> <span class="var token" data-binding="var-_uniq.317" data-verso-hover="81">x</span>)</span></span></div></div></span> <span class="tactic"><label for="tactic-state-17073833640819878306-3331-3334"><span class="keyword token" data-binding="kw-occ-Lean.Elab.Tactic.Ext.ext-3331" data-verso-hover="198">ext</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-17073833640819878306-3331-3334"><div class="tactic-state"><div class="goal"><details open="open"><summary><span class="goal-name">a._@.SciLean.Data.ArrayType.Basic._hyg.281</span></summary><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="39">I</span></td><td class="colon">:</td><td class="type"><span class="sort token" data-binding="">Type</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.73" data-verso-hover="197">inst✝</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-SciLean.IndexType" data-verso-hover="41">IndexType</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="39">I</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.13" data-verso-hover="86">x</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>^[<span class="var token" data-binding="var-_uniq.2" data-verso-hover="39">I</span>]</td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.17" data-verso-hover="93">f</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span> → <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.21" data-verso-hover="93">g</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span> → <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.131" data-verso-hover="88">i✝</span></td><td class="colon">:</td><td class="type"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="39">I</span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type">((<span class="var token" data-binding="var-_uniq.13" data-verso-hover="86">x</span>.mapMono <span class="var token" data-binding="var-_uniq.17" data-verso-hover="93">f</span>).mapMono <span class="var token" data-binding="var-_uniq.21" data-verso-hover="93">g</span>)[<span class="var token" data-binding="var-_uniq.131" data-verso-hover="88">i✝</span>]<span class="const token" data-binding="const-Eq" data-verso-hover="72"> = </span>(<span class="var token" data-binding="var-_uniq.13" data-verso-hover="86">x</span>.mapMono <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.335" data-verso-hover="81">x</span> =&gt; <span class="var token" data-binding="var-_uniq.21" data-verso-hover="93">g</span> (<span class="var token" data-binding="var-_uniq.17" data-verso-hover="93">f</span> <span class="var token" data-binding="var-_uniq.335" data-verso-hover="81">x</span>))[<span class="var token" data-binding="var-_uniq.131" data-verso-hover="88">i✝</span>]</span></span></details></div></div></span><span class="unknown token" data-binding="">;</span> <span class="tactic"><label for="tactic-state-7-3336-3340"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-3336" data-verso-hover="199">simp</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-3336-3340"><div class="tactic-state">All goals completed! 🐙</div></span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-3342">theorem</span> <span class="const token" data-binding="const-mapMono_mapIdxMono" data-verso-hover="200">mapMono_mapIdxMono</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.300" data-verso-hover="39">I</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="">Type</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-SciLean.IndexType" data-verso-hover="41">IndexType</span> <span class="var token" data-binding="var-_uniq.300" data-verso-hover="39">I</span><span class="unknown token" data-binding="">]</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.311" data-verso-hover="86">x</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span><span class="unknown token" data-binding="">^[</span><span class="var token" data-binding="var-_uniq.300" data-verso-hover="39">I</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.315" data-verso-hover="93">f</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.321" data-verso-hover="201">g</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.300" data-verso-hover="39">I</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.311" data-verso-hover="86">x</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-SciLean.DataArrayN.mapMono" data-verso-hover="94">mapMono</span> <span class="var token" data-binding="var-_uniq.315" data-verso-hover="93">f</span> <span class="unknown token" data-binding="">|&gt;.</span><span class="const token" data-binding="const-SciLean.DataArrayN.mapIdxMono" data-verso-hover="97">mapIdxMono</span> <span class="var token" data-binding="var-_uniq.321" data-verso-hover="201">g</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.311" data-verso-hover="86">x</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-SciLean.DataArrayN.mapIdxMono" data-verso-hover="97">mapIdxMono</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-3515">fun</span> <span class="var token" data-binding="var-_uniq.370" data-verso-hover="88">i</span> <span class="var token" data-binding="var-_uniq.373" data-verso-hover="81">x</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.321" data-verso-hover="201">g</span> <span class="var token" data-binding="var-_uniq.370" data-verso-hover="88">i</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.315" data-verso-hover="93">f</span> <span class="var token" data-binding="var-_uniq.373" data-verso-hover="81">x</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-14501588084819918398-3539-3541"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-3539" data-verso-hover="69">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14501588084819918398-3539-3541"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.300" data-verso-hover="39">I</span></td><td class="colon">:</td><td class="type"><span class="sort token" data-binding="">Type</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.381" data-verso-hover="197">inst✝</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-SciLean.IndexType" data-verso-hover="41">IndexType</span> <span class="var token" data-binding="var-_uniq.300" data-verso-hover="39">I</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.311" data-verso-hover="86">x</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>^[<span class="var token" data-binding="var-_uniq.300" data-verso-hover="39">I</span>]</td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.315" data-verso-hover="93">f</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span> → <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.321" data-verso-hover="201">g</span></td><td class="colon">:</td><td class="type"><span class="var token" data-binding="var-_uniq.300" data-verso-hover="39">I</span> → <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span> → <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type">(<span class="var token" data-binding="var-_uniq.311" data-verso-hover="86">x</span>.mapMono <span class="var token" data-binding="var-_uniq.315" data-verso-hover="93">f</span>).mapIdxMono <span class="var token" data-binding="var-_uniq.321" data-verso-hover="201">g</span><span class="const token" data-binding="const-Eq" data-verso-hover="72"> = </span><span class="var token" data-binding="var-_uniq.311" data-verso-hover="86">x</span>.mapIdxMono <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.659" data-verso-hover="88">i</span> <span class="var token" data-binding="var-_uniq.660" data-verso-hover="81">x</span> =&gt; <span class="var token" data-binding="var-_uniq.321" data-verso-hover="201">g</span> <span class="var token" data-binding="var-_uniq.659" data-verso-hover="88">i</span> (<span class="var token" data-binding="var-_uniq.315" data-verso-hover="93">f</span> <span class="var token" data-binding="var-_uniq.660" data-verso-hover="81">x</span>)</span></span></div></div></span>
  <span class="tactic"><label for="tactic-state-1504771911375331970-3544-3547"><span class="keyword token" data-binding="kw-occ-Lean.Elab.Tactic.Ext.ext-3544" data-verso-hover="198">ext</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-1504771911375331970-3544-3547"><div class="tactic-state"><div class="goal"><details open="open"><summary><span class="goal-name">a._@.SciLean.Data.ArrayType.Basic._hyg.281</span></summary><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.300" data-verso-hover="39">I</span></td><td class="colon">:</td><td class="type"><span class="sort token" data-binding="">Type</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.381" data-verso-hover="197">inst✝</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-SciLean.IndexType" data-verso-hover="41">IndexType</span> <span class="var token" data-binding="var-_uniq.300" data-verso-hover="39">I</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.311" data-verso-hover="86">x</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>^[<span class="var token" data-binding="var-_uniq.300" data-verso-hover="39">I</span>]</td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.315" data-verso-hover="93">f</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span> → <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.321" data-verso-hover="201">g</span></td><td class="colon">:</td><td class="type"><span class="var token" data-binding="var-_uniq.300" data-verso-hover="39">I</span> → <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span> → <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.439" data-verso-hover="88">i✝</span></td><td class="colon">:</td><td class="type"><span class="var token" data-binding="var-_uniq.300" data-verso-hover="39">I</span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type">((<span class="var token" data-binding="var-_uniq.311" data-verso-hover="86">x</span>.mapMono <span class="var token" data-binding="var-_uniq.315" data-verso-hover="93">f</span>).mapIdxMono <span class="var token" data-binding="var-_uniq.321" data-verso-hover="201">g</span>)[<span class="var token" data-binding="var-_uniq.439" data-verso-hover="88">i✝</span>]<span class="const token" data-binding="const-Eq" data-verso-hover="72"> = </span>(<span class="var token" data-binding="var-_uniq.311" data-verso-hover="86">x</span>.mapIdxMono <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.677" data-verso-hover="88">i</span> <span class="var token" data-binding="var-_uniq.678" data-verso-hover="81">x</span> =&gt; <span class="var token" data-binding="var-_uniq.321" data-verso-hover="201">g</span> <span class="var token" data-binding="var-_uniq.677" data-verso-hover="88">i</span> (<span class="var token" data-binding="var-_uniq.315" data-verso-hover="93">f</span> <span class="var token" data-binding="var-_uniq.678" data-verso-hover="81">x</span>))[<span class="var token" data-binding="var-_uniq.439" data-verso-hover="88">i✝</span>]</span></span></details></div></div></span><span class="unknown token" data-binding="">;</span> <span class="tactic"><label for="tactic-state-7-3549-3553"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-3549" data-verso-hover="199">simp</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-3549-3553"><div class="tactic-state">All goals completed! 🐙</div></span>
<span class="unknown token" data-binding=""></span></code><p>
              This theorem shows that two <code>mapMono</code> operations can be fused into one. The function <code>mapMono</code> can be implemented with a for loop, so this theorem states that two for loops can be merged into one.</p>
            <p>
              In numerical linear algebra, a common operation is computing <code>a•x+y</code> for <code>a : Float</code>, <code>x</code> and <code>y</code> of type <code>Float^[n]</code>. Scalar multiplication and addition on <code>Float^[n]</code> can be implemented using <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-SciLean.ArrayType.mapMono" data-verso-hover="202">ArrayType.mapMono</span></code>, which means that <code>a•x+y</code> contains two loops that can be fused together using the above theorem.</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-4087" data-verso-hover="13">open</span> <span class="unknown token" data-binding="">SciLean</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-4100">def</span> <span class="const token" data-binding="const-saxpy" data-verso-hover="203">saxpy</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="4">n</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="81">a</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="31">x</span> <span class="var token" data-binding="var-_uniq.18" data-verso-hover="31">y</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span><span class="unknown token" data-binding="">^[</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="4">n</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="81">a</span><span class="unknown token" data-binding="">•</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="31">x</span><span class="unknown token" data-binding="">+</span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="31">y</span><span class="unknown token" data-binding="">)</span>
  <span class="keyword token" data-binding="kw-occ-SciLean.term_Rewrite_byAssuming__-4147">rewrite_by</span>
    <span class="tactic"><label for="tactic-state-13092749991160677766-4174-4228"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.Conv.simp-4174" data-verso-hover="192">simp</span> <span class="keyword token" data-binding="kw-occ-null-4179">only</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="156">HAdd.hAdd</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-Add.add" data-verso-hover="204">Add.add</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-HSMul.hSMul" data-verso-hover="205">HSMul.hSMul</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-SMul.smul" data-verso-hover="206">SMul.smul</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-13092749991160677766-4174-4228"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="4">n</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.5" data-verso-hover="81">a</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.14" data-verso-hover="31">x</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>^[<span class="var token" data-binding="var-_uniq.3" data-verso-hover="4">n</span>]</td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.18" data-verso-hover="31">y</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>^[<span class="var token" data-binding="var-_uniq.3" data-verso-hover="4">n</span>]</td></tr></table><span class="conclusion"><span class="prefix">| </span><span class="type"><span class="const token" data-binding="const-SciLean.ArrayType.mapIdxMono" data-verso-hover="207">ArrayType.mapIdxMono</span> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.4961" data-verso-hover="32">x</span> <span class="var token" data-binding="var-_uniq.4962" data-verso-hover="81">fx</span> =&gt; <span class="var token" data-binding="var-_uniq.4962" data-verso-hover="81">fx</span>.add <span class="var token" data-binding="var-_uniq.18" data-verso-hover="31">y</span>[<span class="var token" data-binding="var-_uniq.4961" data-verso-hover="32">x</span>]) (<span class="const token" data-binding="const-SciLean.ArrayType.mapMono" data-verso-hover="202">ArrayType.mapMono</span> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.4993" data-verso-hover="81">fx</span> =&gt; <span class="var token" data-binding="var-_uniq.5" data-verso-hover="81">a</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="153"> * </span><span class="var token" data-binding="var-_uniq.4993" data-verso-hover="81">fx</span>) <span class="var token" data-binding="var-_uniq.14" data-verso-hover="31">x</span>)</span></span></div></div></span>
    <span class="tactic"><label for="tactic-state-6197341805818162218-4233-4263"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.Conv.simp-4233" data-verso-hover="192">simp</span> <span class="keyword token" data-binding="kw-occ-null-4238">only</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-mapMono_mapIdxMono" data-verso-hover="208">mapMono_mapIdxMono</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-6197341805818162218-4233-4263"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="4">n</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.5" data-verso-hover="81">a</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.14" data-verso-hover="31">x</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>^[<span class="var token" data-binding="var-_uniq.3" data-verso-hover="4">n</span>]</td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.18" data-verso-hover="31">y</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>^[<span class="var token" data-binding="var-_uniq.3" data-verso-hover="4">n</span>]</td></tr></table><span class="conclusion"><span class="prefix">| </span><span class="type"><span class="var token" data-binding="var-_uniq.14" data-verso-hover="31">x</span>.mapIdxMono <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.4951" data-verso-hover="32">i</span> <span class="var token" data-binding="var-_uniq.4952" data-verso-hover="81">x</span> =&gt; (<span class="var token" data-binding="var-_uniq.5" data-verso-hover="81">a</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="153"> * </span><span class="var token" data-binding="var-_uniq.4952" data-verso-hover="81">x</span>).add <span class="var token" data-binding="var-_uniq.18" data-verso-hover="31">y</span>[<span class="var token" data-binding="var-_uniq.4951" data-verso-hover="32">i</span>]</span></span></div></div></span>
<span class="unknown token" data-binding=""></span></code><p>
              The <code>saxpy</code> function computes <code>a•x+y</code>, and by adding <code>rewrite_by ...</code>, we rewrite <code>a•x+y</code> to:</p>
            <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">def saxpy : {n : ℕ} → Float → Float^[n] → Float^[n] → Float^[n] :=
fun {n} a x y =&gt; x.mapIdxMono fun i x =&gt; (a * x).add y[i]</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.print-4393">#print</span></span> <span class="const token" data-binding="const-saxpy" data-verso-hover="209">saxpy</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
              <pre>def saxpy : {n : ℕ} → Float → Float^[n] → Float^[n] → Float^[n] :=
fun {n} a x y =&gt; x.mapIdxMono fun i x =&gt; (a * x).add y[i]
</pre></div>
            <p>
              The first <code>simp only</code> command unfolds the definitions of all the arithmetic operations, revealing the use of <code>mapMono</code> and <code>mapIdxMono</code> used to implement arithmetic operations on arrays. The syntax <code>x + y</code> is just a syntactic sugar for <code>HAdd.hAdd x y</code>. If you want to see the actual definitions, you can add <code>set_option pp.notation false</code> somewhere in your file.</p>
            <p>
              Sometimes, it's useful to keep the default or naive implementation of a function intact and only instruct the compiler to use the optimized version when compiling the code. This can be achieved using the <code>def_optimize</code> command.</p>
            <p>
              For example, let's define a naive version of <code>saxpy</code>:</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-5229">def</span> <span class="const token" data-binding="const-saxpy_naive" data-verso-hover="210">saxpy_naive</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="4">n</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="81">a</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="31">x</span> <span class="var token" data-binding="var-_uniq.18" data-verso-hover="31">y</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span><span class="unknown token" data-binding="">^[</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="4">n</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="81">a</span><span class="unknown token" data-binding="">•</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="31">x</span><span class="unknown token" data-binding="">+</span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="31">y</span>
<span class="unknown token" data-binding=""></span></code><p>
              To instruct the compiler to replace <code>saxpy_naive</code> with the optimized version, we use the <code>def_optimize</code> command:</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-SciLean.commandDef_optimize_By_-5417">def_optimize</span> <span class="unknown token" data-binding="">saxpy_naive</span> <span class="keyword token" data-binding="kw-occ-SciLean.commandDef_optimize_By_-5417">by</span>
  <span class="tactic"><label for="tactic-state-7143219656727981662-5447-5501"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.Conv.simp-5447" data-verso-hover="192">simp</span> <span class="keyword token" data-binding="kw-occ-null-5452">only</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="156">HAdd.hAdd</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-Add.add" data-verso-hover="204">Add.add</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-HSMul.hSMul" data-verso-hover="205">HSMul.hSMul</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-SMul.smul" data-verso-hover="206">SMul.smul</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7143219656727981662-5447-5501"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.1" data-verso-hover="4">n</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="81">a</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="31">x</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>^[<span class="var token" data-binding="var-_uniq.1" data-verso-hover="4">n</span>]</td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="31">y</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>^[<span class="var token" data-binding="var-_uniq.1" data-verso-hover="4">n</span>]</td></tr></table><span class="conclusion"><span class="prefix">| </span><span class="type"><span class="const token" data-binding="const-SciLean.ArrayType.mapIdxMono" data-verso-hover="211">SciLean.ArrayType.mapIdxMono</span> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.299" data-verso-hover="32">x</span> <span class="var token" data-binding="var-_uniq.300" data-verso-hover="81">fx</span> =&gt; <span class="var token" data-binding="var-_uniq.300" data-verso-hover="81">fx</span>.add <span class="var token" data-binding="var-_uniq.4" data-verso-hover="31">y</span>[<span class="var token" data-binding="var-_uniq.299" data-verso-hover="32">x</span>]) (<span class="const token" data-binding="const-SciLean.ArrayType.mapMono" data-verso-hover="212">SciLean.ArrayType.mapMono</span> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.331" data-verso-hover="81">fx</span> =&gt; <span class="var token" data-binding="var-_uniq.2" data-verso-hover="81">a</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="153"> * </span><span class="var token" data-binding="var-_uniq.331" data-verso-hover="81">fx</span>) <span class="var token" data-binding="var-_uniq.3" data-verso-hover="31">x</span>)</span></span></div></div></span>
  <span class="tactic"><label for="tactic-state-6998434745796562833-5504-5534"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.Conv.simp-5504" data-verso-hover="192">simp</span> <span class="keyword token" data-binding="kw-occ-null-5509">only</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-mapMono_mapIdxMono" data-verso-hover="213">mapMono_mapIdxMono</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-6998434745796562833-5504-5534"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.1" data-verso-hover="4">n</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="81">a</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="31">x</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>^[<span class="var token" data-binding="var-_uniq.1" data-verso-hover="4">n</span>]</td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="31">y</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>^[<span class="var token" data-binding="var-_uniq.1" data-verso-hover="4">n</span>]</td></tr></table><span class="conclusion"><span class="prefix">| </span><span class="type"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="31">x</span>.mapIdxMono <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.289" data-verso-hover="32">i</span> <span class="var token" data-binding="var-_uniq.290" data-verso-hover="81">x</span> =&gt; (<span class="var token" data-binding="var-_uniq.2" data-verso-hover="81">a</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="153"> * </span><span class="var token" data-binding="var-_uniq.290" data-verso-hover="81">x</span>).add <span class="var token" data-binding="var-_uniq.4" data-verso-hover="31">y</span>[<span class="var token" data-binding="var-_uniq.289" data-verso-hover="32">i</span>]</span></span></div></div></span>
<span class="unknown token" data-binding=""></span></code><p>
              This command creates a new definition <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-saxpy_naive.optimized" data-verso-hover="214">saxpy_naive.optimized</span></code>, which is an optimized version of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-saxpy_naive" data-verso-hover="215">saxpy_naive</span></code>. It also creates a new theorem called <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-saxpy_naive.optimize_rule" data-verso-hover="216">saxpy_naive.optimize_rule</span></code>, which states that <code>saxpy_naive = saxpy_naive.optimized</code> and marks it with the <code>@[csimp]</code> attribute. The <code>csimp</code> attribute is similar to <code>simp</code>, but it stands for "compiler simp," and the corresponding theorems are only applied during compilation.</p>
            </section>
          <section>
            <h2 id="Scientific-Computing-in-Lean--Working-with-Arrays--Optimizing-Array-Expressions--Optimizing-Array-Indexing">
              Optimizing Array Indexing</h2>
            <p>
              Our approach to arrays, allowing indexing with an arbitrary type <code>I</code>, incurs a performance cost as the current Lean compiler can't optimize all layers of abstraction away. However, the flexibility of Lean enables us to engineer such optimizations ourselves without needing to modify the compiler.</p>
            <p>
              Consider matrix-vector multiplication:</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-6360">def</span> <span class="const token" data-binding="const-matVecMul" data-verso-hover="217">matVecMul</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="4">n</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="4">m</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.27" data-verso-hover="59">A</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span><span class="unknown token" data-binding="">^[</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="4">n</span><span class="unknown token" data-binding="">,</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="4">m</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.33" data-verso-hover="57">x</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span><span class="unknown token" data-binding="">^[</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="4">m</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span>
  <span class="unknown token" data-binding="">⊞</span> <span class="var token" data-binding="var-_uniq.44" data-verso-hover="32">i</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">∑</span> <span class="var token" data-binding="var-_uniq.54" data-verso-hover="58">j</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.27" data-verso-hover="59">A</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.44" data-verso-hover="32">i</span><span class="unknown token" data-binding="">,</span><span class="var token" data-binding="var-_uniq.54" data-verso-hover="58">j</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">*</span> <span class="var token" data-binding="var-_uniq.33" data-verso-hover="57">x</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.54" data-verso-hover="58">j</span><span class="unknown token" data-binding="">]</span>
<span class="unknown token" data-binding=""></span></code><p>
              Recall that <code>Float^[n,m]</code> stands for <code>DataArrayN Float (Fin n × Fin m)</code>, a data structure indexed by <code>Fin n × Fin m</code>. The generic type <code>A × B</code> presents an issue because currently, any product type is implemented as a pair of pointers. Therefore, the index access <code>A[i,j]</code> first constructs the index <code>(i,j)</code>, which is a pair of pointers to <code>i</code> and <code>j</code>, stored somewhere on the heap. This is highly inefficient. We want to rewrite <code>A[i,j]</code> to <code>A.data.get (i*m+j)</code>, computing the linear index <code>i*m+j</code> and avoiding the construction of the product <code>(i,j)</code>.</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-7018" data-verso-hover="13">open</span> <span class="unknown token" data-binding="">SciLean</span>
<span class="keyword token" data-binding="kw-occ-SciLean.commandDef_optimize_By_-7031">def_optimize</span> <span class="unknown token" data-binding="">matVecMul</span> <span class="keyword token" data-binding="kw-occ-SciLean.commandDef_optimize_By_-7031">by</span>
  <span class="tactic"><label for="tactic-state-11549540456140016339-7059-7165"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.Conv.simp-7059" data-verso-hover="192">simp</span> <span class="keyword token" data-binding="kw-occ-null-7064">only</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-GetElem.getElem" data-verso-hover="218">GetElem.getElem</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-SciLean.ArrayType.get" data-verso-hover="219">ArrayType.get</span><span class="unknown token" data-binding="">,</span>
             <span class="const token" data-binding="const-SciLean.DataArrayN.get" data-verso-hover="220">DataArrayN.get</span><span class="unknown token" data-binding="">,</span><span class="const token" data-binding="const-SciLean.IndexType.toFin" data-verso-hover="221">IndexType.toFin</span><span class="unknown token" data-binding="">,</span><span class="const token" data-binding="const-SciLean.Size.size" data-verso-hover="44">Size.size</span><span class="unknown token" data-binding="">,</span><span class="const token" data-binding="const-Fin.cast" data-verso-hover="222">Fin.cast</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11549540456140016339-7059-7165"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.1" data-verso-hover="4">n</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">m</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="59">A</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>^[<span class="var token" data-binding="var-_uniq.1" data-verso-hover="4">n</span>, <span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">m</span>]</td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="57">x</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>^[<span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">m</span>]</td></tr></table><span class="conclusion"><span class="prefix">| </span><span class="type">⊞ <span class="var token" data-binding="var-_uniq.253" data-verso-hover="32">i</span> =&gt; ∑ <span class="var token" data-binding="var-_uniq.268" data-verso-hover="58">j</span>, <span class="var token" data-binding="var-_uniq.3" data-verso-hover="59">A</span>.data.get ⟨↑<span class="var token" data-binding="var-_uniq.253" data-verso-hover="32">i</span><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="156"> + </span><span class="var token" data-binding="var-_uniq.1" data-verso-hover="4">n</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="153"> * </span>↑<span class="var token" data-binding="var-_uniq.268" data-verso-hover="58">j</span>, ⋯⟩<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="153"> * </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="57">x</span>.data.get ⟨↑<span class="var token" data-binding="var-_uniq.268" data-verso-hover="58">j</span>, ⋯⟩</span></span></div></div></span>
<span class="unknown token" data-binding=""></span></code><p>
              This optimization results in:</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-7231" data-verso-hover="193">set_option</span> <span class="option token" data-binding="option-Lean.pp.funBinderTypes" data-verso-hover="223">pp.funBinderTypes</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-7231" data-verso-hover="193">true</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">def matVecMul.optimized : {n m : ℕ} → Float^[n, m] → Float^[m] → Float^[n] :=
fun {n m : ℕ} (A : Float^[n, m]) (x : Float^[m]) =&gt;
  ⊞ (i : Fin n) =&gt; ∑ (j : Fin m), A.data.get ⟨↑i + n * ↑j, ⋯⟩ * x.data.get ⟨↑j, ⋯⟩</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.print-7265">#print</span></span> <span class="const token" data-binding="const-matVecMul.optimized" data-verso-hover="224">matVecMul.optimized</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
              <pre>def matVecMul.optimized : {n m : ℕ} → Float^[n, m] → Float^[m] → Float^[n] :=
fun {n m : ℕ} (A : Float^[n, m]) (x : Float^[m]) =&gt;
  ⊞ (i : Fin n) =&gt; ∑ (j : Fin m), A.data.get ⟨↑i + n * ↑j, ⋯⟩ * x.data.get ⟨↑j, ⋯⟩
</pre></div>
            <p>
              The above optimization simply forces the inlining of the mentioned functions. To simplify this process, there is a tactic <code>optimize_index_access</code> that calls <code>simp</code> with the appropriate settings and theorems.</p>
            <p>
              Next, let's consider the dot product of two matrices:</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-7869">def</span> <span class="const token" data-binding="const-matDot" data-verso-hover="225">matDot</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="4">n</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="4">m</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.27" data-verso-hover="59">A</span> <span class="var token" data-binding="var-_uniq.33" data-verso-hover="59">B</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span><span class="unknown token" data-binding="">^[</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="4">n</span><span class="unknown token" data-binding="">,</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="4">m</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">∑</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.390" data-verso-hover="226">ij</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Fin" data-verso-hover="54">Fin</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="4">n</span> <span class="unknown token" data-binding="">×</span> <span class="const token" data-binding="const-Fin" data-verso-hover="54">Fin</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="4">m</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.27" data-verso-hover="59">A</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.390" data-verso-hover="226">ij</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">*</span> <span class="var token" data-binding="var-_uniq.33" data-verso-hover="59">B</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.390" data-verso-hover="226">ij</span><span class="unknown token" data-binding="">]</span>
<span class="unknown token" data-binding=""></span></code><p>
              Explicitly mentioning the type of the index <code>ij : Fin n × Fin m</code> highlights that this function again creates the problematic product type. We want to iterate this sum over the range <code>0,...,n*m-1</code> and use this linear index to access the matrices.</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-8211" data-verso-hover="13">open</span> <span class="unknown token" data-binding="">SciLean</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-8224" data-verso-hover="193">set_option</span> <span class="option token" data-binding="option-Lean.pp.funBinderTypes" data-verso-hover="223">pp.funBinderTypes</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-8224" data-verso-hover="193">true</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.in-8224">in</span>
<span class="keyword token" data-binding="kw-occ-SciLean.commandDef_optimize_By_-8261">def_optimize</span> <span class="unknown token" data-binding="">matDot</span> <span class="keyword token" data-binding="kw-occ-SciLean.commandDef_optimize_By_-8261">by</span>

  -- rewrite `sum` over `Fin n × Fin m` to `fold` over `Fin (n*m)`
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.Conv.convRw__-8355" data-verso-hover="227">rw</span><span class="unknown token" data-binding="">[</span><span class="tactic"><label for="tactic-state-5184911503813432905-8358-8381"><span class="const token" data-binding="const-SciLean.IndexType.sum_linearize" data-verso-hover="228">IndexType.sum_linearize</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5184911503813432905-8358-8381"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.1" data-verso-hover="4">n</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">m</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="59">A</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>^[<span class="var token" data-binding="var-_uniq.1" data-verso-hover="4">n</span>, <span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">m</span>]</td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="59">B</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>^[<span class="var token" data-binding="var-_uniq.1" data-verso-hover="4">n</span>, <span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">m</span>]</td></tr></table><span class="conclusion"><span class="prefix">| </span><span class="type"> ∑ (<span class="var token" data-binding="var-_uniq.1087" data-verso-hover="229">i</span> : <span class="const token" data-binding="const-Fin" data-verso-hover="54">Fin</span> (<span class="const token" data-binding="const-SciLean.Size.size" data-verso-hover="44">size</span> (<span class="const token" data-binding="const-Fin" data-verso-hover="54">Fin</span> <span class="var token" data-binding="var-_uniq.1" data-verso-hover="4">n</span><span class="const token" data-binding="const-Prod" data-verso-hover="71"> × </span><span class="const token" data-binding="const-Fin" data-verso-hover="54">Fin</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">m</span>))), <span class="var token" data-binding="var-_uniq.3" data-verso-hover="59">A</span>[<span class="const token" data-binding="const-SciLean.IndexType.fromFin" data-verso-hover="230">IndexType.fromFin</span> <span class="var token" data-binding="var-_uniq.1087" data-verso-hover="229">i</span>]<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="153"> * </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="59">B</span>[<span class="const token" data-binding="const-SciLean.IndexType.fromFin" data-verso-hover="230">IndexType.fromFin</span> <span class="var token" data-binding="var-_uniq.1087" data-verso-hover="229">i</span>]</span></span></div></div></span><span class="unknown token" data-binding="">]</span>

  -- unfold several layers of abstraction for `get` function
  <span class="tactic"><label for="tactic-state-8935066470594743878-8447-8505"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.Conv.simp-8447" data-verso-hover="192">simp</span> <span class="keyword token" data-binding="kw-occ-null-8452">only</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-GetElem.getElem" data-verso-hover="218">GetElem.getElem</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-SciLean.ArrayType.get" data-verso-hover="219">ArrayType.get</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-SciLean.DataArrayN.get" data-verso-hover="220">DataArrayN.get</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-8935066470594743878-8447-8505"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.1" data-verso-hover="4">n</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">m</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="59">A</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>^[<span class="var token" data-binding="var-_uniq.1" data-verso-hover="4">n</span>, <span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">m</span>]</td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="59">B</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>^[<span class="var token" data-binding="var-_uniq.1" data-verso-hover="4">n</span>, <span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">m</span>]</td></tr></table><span class="conclusion"><span class="prefix">| </span><span class="type"> ∑ (<span class="var token" data-binding="var-_uniq.1087" data-verso-hover="229">i</span> : <span class="const token" data-binding="const-Fin" data-verso-hover="54">Fin</span> (<span class="const token" data-binding="const-SciLean.Size.size" data-verso-hover="44">size</span> (<span class="const token" data-binding="const-Fin" data-verso-hover="54">Fin</span> <span class="var token" data-binding="var-_uniq.1" data-verso-hover="4">n</span><span class="const token" data-binding="const-Prod" data-verso-hover="71"> × </span><span class="const token" data-binding="const-Fin" data-verso-hover="54">Fin</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">m</span>))),
  <span class="var token" data-binding="var-_uniq.3" data-verso-hover="59">A</span>.data.get (<span class="const token" data-binding="const-Fin.cast" data-verso-hover="222">Fin.cast</span> ⋯ (<span class="const token" data-binding="const-SciLean.IndexType.toFin" data-verso-hover="221">IndexType.toFin</span> (<span class="const token" data-binding="const-SciLean.IndexType.fromFin" data-verso-hover="230">IndexType.fromFin</span> <span class="var token" data-binding="var-_uniq.1087" data-verso-hover="229">i</span>)))<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="153"> *
    </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="59">B</span>.data.get (<span class="const token" data-binding="const-Fin.cast" data-verso-hover="222">Fin.cast</span> ⋯ (<span class="const token" data-binding="const-SciLean.IndexType.toFin" data-verso-hover="221">IndexType.toFin</span> (<span class="const token" data-binding="const-SciLean.IndexType.fromFin" data-verso-hover="230">IndexType.fromFin</span> <span class="var token" data-binding="var-_uniq.1087" data-verso-hover="229">i</span>)))</span></span></div></div></span>

  -- simplify `toFin (fromFin i)` to `i`
  <span class="tactic"><label for="tactic-state-411779708383703489-8550-8575"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.Conv.simp-8550" data-verso-hover="192">simp</span> <span class="keyword token" data-binding="kw-occ-null-8555">only</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-toFin_fromFin" data-verso-hover="231">toFin_fromFin</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-411779708383703489-8550-8575"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.1" data-verso-hover="4">n</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">m</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="59">A</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>^[<span class="var token" data-binding="var-_uniq.1" data-verso-hover="4">n</span>, <span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">m</span>]</td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="59">B</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>^[<span class="var token" data-binding="var-_uniq.1" data-verso-hover="4">n</span>, <span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">m</span>]</td></tr></table><span class="conclusion"><span class="prefix">| </span><span class="type"> ∑ (<span class="var token" data-binding="var-_uniq.1087" data-verso-hover="229">i</span> : <span class="const token" data-binding="const-Fin" data-verso-hover="54">Fin</span> (<span class="const token" data-binding="const-SciLean.Size.size" data-verso-hover="44">size</span> (<span class="const token" data-binding="const-Fin" data-verso-hover="54">Fin</span> <span class="var token" data-binding="var-_uniq.1" data-verso-hover="4">n</span><span class="const token" data-binding="const-Prod" data-verso-hover="71"> × </span><span class="const token" data-binding="const-Fin" data-verso-hover="54">Fin</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">m</span>))), <span class="var token" data-binding="var-_uniq.3" data-verso-hover="59">A</span>.data.get (<span class="const token" data-binding="const-Fin.cast" data-verso-hover="222">Fin.cast</span> ⋯ <span class="var token" data-binding="var-_uniq.1087" data-verso-hover="229">i</span>)<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="153"> * </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="59">B</span>.data.get (<span class="const token" data-binding="const-Fin.cast" data-verso-hover="222">Fin.cast</span> ⋯ <span class="var token" data-binding="var-_uniq.1087" data-verso-hover="229">i</span>)</span></span></div></div></span>

  -- clean up some expressions
  <span class="tactic"><label for="tactic-state-9014805277414954787-8610-8640"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.Conv.simp-8610" data-verso-hover="192">simp</span> <span class="keyword token" data-binding="kw-occ-null-8615">only</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-Fin.cast" data-verso-hover="222">Fin.cast</span><span class="unknown token" data-binding="">,</span><span class="const token" data-binding="const-SciLean.Size.size" data-verso-hover="44">Size.size</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-9014805277414954787-8610-8640"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.1" data-verso-hover="4">n</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">m</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.3" data-verso-hover="59">A</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>^[<span class="var token" data-binding="var-_uniq.1" data-verso-hover="4">n</span>, <span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">m</span>]</td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="59">B</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>^[<span class="var token" data-binding="var-_uniq.1" data-verso-hover="4">n</span>, <span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">m</span>]</td></tr></table><span class="conclusion"><span class="prefix">| </span><span class="type"> ∑ (<span class="var token" data-binding="var-_uniq.1087" data-verso-hover="232">i</span> : <span class="const token" data-binding="const-Fin" data-verso-hover="54">Fin</span> (<span class="var token" data-binding="var-_uniq.1" data-verso-hover="4">n</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="153"> * </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">m</span>)), <span class="var token" data-binding="var-_uniq.3" data-verso-hover="59">A</span>.data.get ⟨↑<span class="var token" data-binding="var-_uniq.1087" data-verso-hover="232">i</span>, ⋯⟩<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="153"> * </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="59">B</span>.data.get ⟨↑<span class="var token" data-binding="var-_uniq.1087" data-verso-hover="232">i</span>, ⋯⟩</span></span></div></div></span>
<span class="unknown token" data-binding=""></span></code><p>
              This optimization results in:</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-8702" data-verso-hover="193">set_option</span> <span class="option token" data-binding="option-Lean.pp.funBinderTypes" data-verso-hover="223">pp.funBinderTypes</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-8702" data-verso-hover="193">true</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">def matDot.optimized : {n m : ℕ} → Float^[n, m] → Float^[n, m] → Float :=
fun {n m : ℕ} (A B : Float^[n, m]) =&gt;  ∑ (i : Fin (n * m)), A.data.get ⟨↑i, ⋯⟩ * B.data.get ⟨↑i, ⋯⟩</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.print-8736">#print</span></span> <span class="const token" data-binding="const-matDot.optimized" data-verso-hover="233">matDot.optimized</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
              <pre>def matDot.optimized : {n m : ℕ} → Float^[n, m] → Float^[n, m] → Float :=
fun {n m : ℕ} (A B : Float^[n, m]) =&gt;  ∑ (i : Fin (n * m)), A.data.get ⟨↑i, ⋯⟩ * B.data.get ⟨↑i, ⋯⟩
</pre></div>
            <p>
              This can also be achieved by calling the <code>optimize_index_access</code> tactic in a single line.</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-9118" data-verso-hover="13">open</span> <span class="unknown token" data-binding="">SciLean</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-9131">def</span> <span class="const token" data-binding="const-matDot'" data-verso-hover="234">matDot'</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="4">n</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="4">m</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.27" data-verso-hover="59">A</span> <span class="var token" data-binding="var-_uniq.33" data-verso-hover="59">B</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span><span class="unknown token" data-binding="">^[</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="4">n</span><span class="unknown token" data-binding="">,</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="4">m</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">∑</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.390" data-verso-hover="226">ij</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Fin" data-verso-hover="54">Fin</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="4">n</span> <span class="unknown token" data-binding="">×</span> <span class="const token" data-binding="const-Fin" data-verso-hover="54">Fin</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="4">m</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.27" data-verso-hover="59">A</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.390" data-verso-hover="226">ij</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">*</span> <span class="var token" data-binding="var-_uniq.33" data-verso-hover="59">B</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.390" data-verso-hover="226">ij</span><span class="unknown token" data-binding="">]</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-9214" data-verso-hover="193">set_option</span> <span class="option token" data-binding="option-Lean.pp.funBinderTypes" data-verso-hover="223">pp.funBinderTypes</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-9214" data-verso-hover="193">true</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.in-9214">in</span>
<span class="keyword token" data-binding="kw-occ-SciLean.commandDef_optimize_By_-9251">def_optimize</span> <span class="unknown token" data-binding="">matDot'</span> <span class="keyword token" data-binding="kw-occ-SciLean.commandDef_optimize_By_-9251">by</span> <span class="tactic"><label for="tactic-state-16418927924715348989-9275-9296"><span class="keyword token" data-binding="kw-occ-SciLean.convOptimize_index_access-9275">optimize_index_access</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-16418927924715348989-9275-9296"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.608" data-verso-hover="4">n</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.609" data-verso-hover="4">m</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.610" data-verso-hover="59">A</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>^[<span class="var token" data-binding="var-_uniq.608" data-verso-hover="4">n</span>, <span class="var token" data-binding="var-_uniq.609" data-verso-hover="4">m</span>]</td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.611" data-verso-hover="59">B</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>^[<span class="var token" data-binding="var-_uniq.608" data-verso-hover="4">n</span>, <span class="var token" data-binding="var-_uniq.609" data-verso-hover="4">m</span>]</td></tr></table><span class="conclusion"><span class="prefix">| </span><span class="type"> ∑ (<span class="var token" data-binding="var-_uniq.1012" data-verso-hover="232">i</span> : <span class="const token" data-binding="const-Fin" data-verso-hover="54">Fin</span> (<span class="var token" data-binding="var-_uniq.608" data-verso-hover="4">n</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="153"> * </span><span class="var token" data-binding="var-_uniq.609" data-verso-hover="4">m</span>)), <span class="var token" data-binding="var-_uniq.610" data-verso-hover="59">A</span>.data.get ⟨↑<span class="var token" data-binding="var-_uniq.1012" data-verso-hover="232">i</span>, ⋯⟩<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="153"> * </span><span class="var token" data-binding="var-_uniq.611" data-verso-hover="59">B</span>.data.get ⟨↑<span class="var token" data-binding="var-_uniq.1012" data-verso-hover="232">i</span>, ⋯⟩</span></span></div></div></span>
<span class="unknown token" data-binding=""></span></code></section>
          </section>
        </main></div>
    </body>
  </html>

