<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Basic Operations</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../title.html">Scientific Computing in Lean</a></li><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../introduction/sorry-friendly-programming.html"><strong aria-hidden="true">1.1.</strong> Sorry Friendly Programming</a></li></ol></li><li class="chapter-item expanded "><a href="../working-with-arrays.html"><strong aria-hidden="true">2.</strong> Working with Arrays</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../working-with-arrays/basics.html" class="active"><strong aria-hidden="true">2.1.</strong> Basic Operations</a></li><li class="chapter-item expanded "><a href="../working-with-arrays/tensor-operations.html"><strong aria-hidden="true">2.2.</strong> Tensor Operations</a></li><li class="chapter-item expanded "><a href="../working-with-arrays/abstract-interface.html"><strong aria-hidden="true">2.3.</strong> Abstract Array Interface</a></li><li class="chapter-item expanded "><a href="../working-with-arrays/optimizing-arrays.html"><strong aria-hidden="true">2.4.</strong> Optimizing Array Expressions</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Differentiation</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.</strong> Zoo of Differentiation Operators</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.</strong> Defining New Functions</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.3.</strong> Theoretical Aspects*</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Function Transformations</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> Defining New Function Transformation</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> Function Transformation Algorithm*</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Problem Transformations</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Solve Function</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> Approximation</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Differential Equations</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Probabilistic Programming</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="basic-operations"><a class="header" href="#basic-operations">Basic Operations</a></h1>
<p>What distinguishes Lean from many other programming languages is that Lean is so called dependently typed programming language. This allows us to work with arrays that have their dimensions specified in their type. For example, vector dot product can be defined as</p>
<pre><code class="language-lean">def dot {n : Nat} (x y : Float^[n]) : Float := ∑ i, x[i] * y[i]
</code></pre>
<p>This function accepts the size of the array as an argument <code>n : Nat</code> and then two arrays of the same size <code>n</code>. The meaning of <em>dependently typed</em> is that the type of function argument can depend on the value of another argument. Here the type of <code>x</code> and <code>y</code> is <code>Float^[n]</code> which depends on the first argument <code>n</code>. This is really not possible in ordinary programming languages, some of them allow you to provide the dimension at compile time. In Lean this is not the case, the dimension <code>n</code> can be determined completly at runtime.</p>
<p>As you can see, one of the nice advantages is that we didn't have to specify the range over which we want to sum at it is automatically infered it should sum over the numbers <code>0..(n-1)</code>.</p>
<p>We can test the function with</p>
<pre><code class="language-lean">#eval dot ⊞[1.0,1.0] ⊞[1.0,1.0]
</code></pre>
<p>When calling a function, you have to provide only the arguments with normal braces, such as <code>(x y : Float^[n])</code>. Arguments with the curly braces <code>{n : Nat}</code> are implicit and will be infered automatically from the other arguments, from <code>x</code> and <code>y</code> in this case. Lean prevents us from providing arrays of different lenghts </p>
<pre><code class="language-lean">#eval dot ⊞[1.0,1.0] ⊞[1.0,1.0,1.0]
</code></pre>
<p>Let's back up and talk about the notation <code>Float^[n]</code> and how it connects to <code>DataArray X</code> we talked about previously. An array <code>x : Float^[n]</code> has length <code>n</code> and thus can be indexed with number <code>0..(n-1)</code>. The type expressing all natural numbers smaller then <code>n</code> is denoted with <code>Fin n</code>. It is defined as a structure:</p>
<pre><code class="language-lean">structure Fin (n : Nat) where
  val  : Nat
  isLt : val &lt; n
</code></pre>
<p>which holds the value <code>val</code> and a proof <code>isLt</code> that the value is infact smaller then <code>n</code>. </p>
<p><code>Float^[n]</code> is just a syntactic sugar for <code>DataArrayN Float (Fin n)</code> which is  <code>DataArray Float</code> together with a proof that the size of the array is <code>n</code>. In general, <code>Fin n</code> can be replaced with an arbitrary index type <code>I</code>. The definition of <code>DataArrayN</code> is:</p>
<pre><code class="language-lean">structure DataArrayN (X : Type) (I : Type) where
  data : DataArray X
  h_size : card I = data.size
</code></pre>
<p>which is an array <code>data</code> with a proof that the array size it equal to the cardinality of the index set <code>I</code>. In the case of <code>I = Fin n</code> we have <code>card (Fin n) = n.</code></p>
<p>Having the flexibility using an arbitrary type <code>I</code> as index is already sufficient to support arbitrary n-dimensional array. To get matrices we pick <code>I = Fin n × Fin m</code>. In other words matrix is just an array indexed by pair of indices <code>(i,j)</code> where <code>0≤i&lt;n</code> and <code>0≤j&lt;m</code>. Thus <code>DataArrayN Float (Fin n × Fin m)</code> is just a <code>n×m</code> matrix and the syntactic sugar for it is <code>Float^[n,m]</code>. We can generalize this and pick <code>I = Fin n₁ × ... × Fin nᵣ</code> which yields <code>r</code>-dimensional array with dimensions <code>n₁, ..., nᵣ</code>. The syntactic sugar for <code>DataArrayN Float (Fin n₁ × ... × Fin nᵣ)</code> is <code>Float^[n₁, ..., nᵣ]</code>.</p>
<p>Have a look at chapter 1.4. Structures in Functional Programming in LeanTo learn more about structures </p>
<p>Let's go over the basic operations on arrays in <em>SciLean</em>. As we mentioned previously you can create <code>List</code> with <code>[a,b,...]</code> or <code>Array</code> with <code>#[a,b,...]</code>. Here we will mainly focus on <code>DataArray</code> that uses <code>⊞[a,b,...]</code> so let's create one</p>
<pre><code class="language-lean">def u :=  ⊞[1.0, 2.0]
</code></pre>
<p>we can access its elements with bracket notation <code>u[i]</code></p>
<pre><code>#eval u[0]
#eval u[1]
</code></pre>
<p>Lean can leverage the index information in the type of <code>u</code> so when we write </p>
<pre><code>#eval ∑ i, u[i]
</code></pre>
<p>or </p>
<pre><code>#check fun i =&gt; u[i]
</code></pre>
<p>Lean automatically infers the type of <code>i</code></p>
<p>Similarly we can create a matrix</p>
<pre><code class="language-lean">def A := ⊞[1.0, 2.0; 3.0, 4.0]
</code></pre>
<p>and we can access its elements</p>
<pre><code class="language-lean">#eval A[0,1]
</code></pre>
<p>Because matrix <code>A</code> is just an array indexed by <code>Fin 2 × Fin 2</code> we can also write it as </p>
<pre><code class="language-lean">#check A[(0,1)]
</code></pre>
<p>which might look like an odd quirk of our definition of matrix but hopeful later on you will see that this generality allows us to work with indices that have a proper meaning rather being a meaningless number.</p>
<p>Popular method for creating arrays in Python is list comprehension. To some capacity this can be viewed as process turning a function, <code>f : Idx → Elem</code>, into an array <code>DataArraN Elem Idx</code>. The notation is very similar to lambda notation <code>fun x =&gt; f x</code></p>
<pre><code>#check ⊞ i =&gt; f i
</code></pre>
<p>Unlike lambda notation, array notation uncurries all of its arguments. This means that <code>⊞ i j =&gt; f i j</code> creates and matrix indexed by <code>(i,j)</code>. For example outer product of two arrays can be defines as</p>
<pre><code class="language-lean">def outerProduct {n m : Nat} (x : Float^[n]) (y : Float^[m]) : Float^[n,m] :=
  ⊞ i j =&gt; x[i]*y[j]
</code></pre>
<p>If you want an array of arrays instead of matrix you would write <code>⊞ i =&gt; (⊞ j =&gt; x[i]*y[j])</code> or <code>⊞ j =&gt; (⊞ i =&gt; x[i]*y[j])</code> depending whether you want the matrix stored as an array of rows or columns.</p>
<p>Currently this notation does not allow you to do any advanced features like filtering the elements based on some property. If you have a good idea how this should work please submit a proposal.</p>
<p>Another way to set up a matrix is to set its elements one by one</p>
<pre><code class="language-lean">def outerProduct {n m : Nat} (x : Float^[n]) (y : Float^[m]) := Id.run do
  let mut A : Float^[n,m] := 0
  for i in IndexType.univ Fin n do
    for j in IndexType.univ Fin m do
      A[i,j] := x[i]*y[j]
  return A
</code></pre>
<p>We first create mutable zero matrix and then set every. The function <code>IndexType.univ I</code> creates a range that runs over all the elements of <code>I</code>. When working with matrices, one has to be careful if they are in column major or row major ordering and accordingly iterate over <code>i</code> first and then over <code>j</code>. We will explain later how this is done in <em>SciLean</em> so for now it is safe to just iterate over both indices simultaneously and we get the optimal order</p>
<pre><code class="language-lean">def outerProduct {n m : Nat} (x : Float^[n]) (y : Float^[m]) := Id.run do
  let mut A : Float^[n,m] := 0
  for (i,j) in (IndexType.univ (Fin n × Fin m)) do
    A[i,j] := x[i]*y[j]
  return A
</code></pre>
<p>Of course the above implementation of has the drawback that it first initialized the whole matrix to zero and then go over the matrix again and set it up to the correct value. Sometimes it is much more natural to create the matrix element by element. We can create an array with dynamic size and push element one by one. Once we are done we can fix the dimensions of the matrix.</p>
<pre><code class="language-lean">def outerProduct {n m : Float} (x : Float^[n]) (y : Float^[m]) : Float^[n,m] := Id.run do
  let mut A : DataArray Float := ⊞[]
  A := reserve A (n*m)
  for (i,j) in (IndexType.univ (Fin n × Fin m)) do
    A := A.push (x[i]*y[j])
  return { data:= A, h_size:= sorry }
</code></pre>
<p>Recall that <code>Float^[n,m]</code> is just syntax for <code>DataArrayN Float (Fin n × Fin m)</code> and <code>DataArrayN X I</code> is just a structure holding <code>data : DataArray X</code> and a proof <code>h_size : data.size = card I</code>. In this case, we provide the matrix <code>A</code> and in the second element we should provide a proof that <code>A.size = card (Fin n × Fin m) = n*m</code>. Right now, we do not want to focus on proofs to we just omit it. Deciding when to provide proofs and when to omit them is a crucial skill when writing programs in Lean. Often it is very useful to just state what your program is supposed to do. It is a an amazing tool to clarify in your head what program are you actually writing. On the other hand, providing all the proofs can be really tedious and often a waste of time if you have to reorganize you program and all your proofs are suddently invalid.</p>
<h2 id="reshaping-arrays"><a class="header" href="#reshaping-arrays">Reshaping Arrays</a></h2>
<p>Reshaping arrays is a common operation, where you may need to transform an array of one shape into another while preserving its total size. <em>SciLean</em> provides several functions for reshaping arrays, allowing you to convert arrays of arbitrary shapes into vectors, matrices, or arrays of higher rank.</p>
<pre><code class="language-lean">def reshape1 (x : Float^[I]) (n : Nat)    (h : card I = n)     : Float^[n] := ...
def reshape2 (x : Float^[I]) (n m : Nat)  (h : card I = n*m)   : Float^[n,m] := ...
def reshape3 (x : Float^[I]) (n m k: Nat) (h : card I = n*m*k) : Float^[n,m,k] := ...
...
</code></pre>
<p>For example, to create a matrix, you can first create an array and then convert it to a matrix:</p>
<pre><code class="language-lean">#check ⊞[(1.0 : Float), 2.0, 3.0, 4.0].reshape2 2 2 (by decide)
</code></pre>
<p>Here, we also prove that reshaping an array of size four to a two-by-two matrix is valid by calling the tactic <code>decide</code>. This tactic works well with concrete numbers, when variables are involved, feel free to omit the proof with <code>sorry</code>.</p>
<p>These reshape functions are concrete instances of a general <code>reshape</code> function:</p>
<pre><code class="language-lean">def reshape (x : Float^[I]) (J : Type) [IndexType J] 
    (h := IndexType.card I = IndexType.card J) : Float^[J] := ...
</code></pre>
<p>which reshapes an array of shape <code>I</code> to an array of shape <code>J</code>. Using this function for vectors or matrices is cumbersome, as <code>x.reshape2 n m sorry</code> is just a shorthand for <code>x.reshape (Fin n × Fin m) sorry</code>.</p>
<p>The <code>reshape</code> function is also a concrete instance of the more general function <code>reshapeEquiv</code>, which reshapes an array of size <code>I</code> to an array of size <code>J</code> by an arbitrary equivalence <code>I ≃ J</code>:</p>
<pre><code class="language-lean">def reshapeEquiv (x : Float^[I]) (ι : I ≃ J) : Float^[J] := ...
</code></pre>
<p>This function allows you to reshape an array and perform various permutations of its data.</p>
<p>The <code>reshape</code> function is implemented with the <code>reshapeEquiv</code> function via the natural equivalence between two index types <code>I</code> and <code>J</code>, where you first convert <code>i : I</code> to a flat index <code>toFin i : Fin (card I)</code> and then convert it back to a structured index <code>J</code> by <code>fromFin (toFin i) : J</code>. For this operation to be valid, it is required that <code>card I = card J</code>. Here is the implementation of this natural equivalence:</p>
<pre><code class="language-lean">open IndexType in
def naturalEquiv (I J : Type) [IndexType I] [IndexType J] 
    (h : card I = card J) : I ≃ J := 
{
  toFun := fun i =&gt; fromFin (h ▸ toFin i),
  invFun := fun j =&gt; fromFin (h ▸ toFin j),
  left_inv := sorry,
  right_inv := sorry
}
</code></pre>
<p>To construct an equivalence <code>I ≃ J</code>, we need to provide <code>toFun : I → J</code>, its inverse <code>invFun : J → I</code>, and proofs that they are indeed inverses of each other, which we omit here.</p>
<p>Implementing this equivalence is a bit tricky because we cannot simply call <code>fromFin (toFin i)</code>. This is because <code>toFin i</code> produces <code>Fin (card I)</code>, but for <code>fromFin</code> to create an index of type <code>J</code>, it would expect <code>Fin (card J)</code>. Therefore, we need to convert the flat index <code>Fin (card I)</code> to the flat index <code>Fin (card J)</code>. In Lean, the notation <code>h ▸ x</code> allows you to cast <code>x : X</code> to a different type by using the fact <code>h</code>. In our particular case, <code>h ▸ toFin i</code> produces <code>Fin (card J)</code>, which can be passed on to <code>fromFin</code> to obtain <code>J</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../working-with-arrays.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../working-with-arrays/tensor-operations.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../working-with-arrays.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../working-with-arrays/tensor-operations.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
