<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Typeclasses as Interfaces and Function Overloading</title><link rel="stylesheet" href="../../book.css">
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <script src="../../static/katex/katex.min.js"></script>
    <script src="../../static/math.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../-verso-js/popper.js"></script>
    <script src="../../-verso-js/tippy.js"></script>
    <link rel="stylesheet" href="../../static/theme.css">
    <link rel="stylesheet" href="../../static/inter/inter.css">
    <link rel="stylesheet" href="../../static/firacode/fira_code.css">
    <link rel="stylesheet" href="../../static/katex/katex.min.css">
    <link rel="stylesheet" href="../../-verso-css/tippy-border.css">
    <style>
div.collapsible-hint {
  margin: 5px 0;
}

div.collapsible-hint-header {
  padding: 2px;
  font-size: medium;
  cursor: pointer;
  position: relative;
}

div.collapsible-hint-header::after {
  content: "⊢";
  position: absolute;
  left: 50px;
  transition: transform 0.3s ease;
}

div.collapsible-hint-content {
  border: 1px solid white;
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease;
}

div.collapsible-hint.expanded .collapsible-hint-content {
  max-height: 500px; /* Adjust this value depending on the content's height */
  border: 1px solid lightgrey;
}

div.collapsible-hint.expanded .collapsible-hint-header::after {
  transform: rotate(90deg); /* Rotate to show ">" when expanded */
}
</style><style>

.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
}

.hl.lean .keyword {
  font-weight : bold;
}

.hl.lean .var {
  font-style: italic;
  position: relative;
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5em;
  z-index: 300;
  font-size: inherit;
}

.hl.lean .hover-info.messages {
  max-height: 10em;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5em 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5em;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1em;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0em;
}

/*
@media (hover: hover) {
  .hl.lean .has-info:hover > .hover-container > .hover-info:not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .has-info:hover > .hover-container > .hover-info,
  .hl.lean .token:hover > .hover-container > .hover-info:not(.has-info *):not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .token:hover > .hover-container > .hover-info:not(.has-info *) {
    display: inline-block;
    position: absolute;
    top: 1em;
    font-weight: normal;
    font-style: normal;
    width: min-content;
  }
}
*/

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: 0.1rem;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5em;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error {
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2em solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error pre {
    color: red;
}

.hl.lean .has-info.warning {
  text-decoration-color: #efd871;
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color: #efd871;
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: #efd871;
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2em solid #efd871;
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.info {
  text-decoration-color: blue;
}

@media (hover: hover) {
  .hl.lean .has-info.info:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.info {
  background-color: #e5e5e5;
  border-left: 0.2em solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.info {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: sans-serif;
  white-space: normal;
  max-width: 40em;
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1em;
  margin-right: 1em;
  margin-top: 0.5em;
  margin-bottom: 0.5em;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: monospace;
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  left: 2em;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1em;
  padding: 0.5em;
  font-family: sans-serif;
  background-color: #ffffff;
  z-index: 200;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5em;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: block;
}

/*
@media (hover: hover) {
  .hl.lean .tactic:hover > .tactic-toggle:not(:checked) ~ .tactic-state {
    display: block;
    position: absolute;
    left: 0;
    transform: translate(0.25rem, 0);
    z-index: 250;
  }
}
*/

.hl.lean .tactic > label {
  position: relative;
  transition: all 0.5s;
}

@media (hover: hover) {
  .hl.lean .tactic > label:hover {
    border-bottom: 1px dotted #bbbbbb;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  border-radius: 1em;
  height: 0.25em;
  vertical-align: middle;
  width: 0.6em;
  margin-left: 0.1em;
  margin-right: 0.1em;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5em;
}

.hl.lean .tactic-state summary {
  margin-left: -0.5em;
}

.hl.lean .tactic-state details {
  padding-left: 0.5em;
}

.hl.lean .tactic-state .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .tactic-state .goal-name {
  font-style: italic;
  font-family: monospace;
}

.hl.lean .tactic-state .hypotheses td.colon {
  text-align: center;
  min-width: 1em;
}

.hl.lean .tactic-state .hypotheses td.name {
  text-align: right;
}

.hl.lean .tactic-state .hypotheses td.name,
.hl.lean .tactic-state .hypotheses td.type,
.hl.lean .tactic-state .conclusion .type {
  font-family: monospace;
}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #efd871;
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}



.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}

</style><style>
div.TODO {
  border: 5px solid red;
  position: relative;
}
div.TODO::before {
  content: "TODO";
  position: absolute;
  top: 0;
  right: 0;
  color: red;
  font-size: large;
  font-weight: bold;
  transform: rotate(-90deg) translate(-2em);
}
</style><style>
div.collapsible {
  margin: 5px 0;
}

div.collapsible-header {
  padding: 2px;
  font-size: medium;
  cursor: pointer;
  position: relative;
}

div.collapsible-header::after {
  content: "⊢";
  position: absolute;
  left: 60px;
  transition: transform 0.3s ease;
}

div.collapsible-content {
  border: 1px solid white;
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease;
}

div.collapsible.expanded .collapsible-content {
  max-height: 500px; /* Adjust this value depending on the content's height */
  border: 1px solid lightgrey;
}

div.collapsible.expanded .collapsible-header::after {
  transform: rotate(90deg); /* Rotate to show ">" when expanded */
}
</style><script>
      
window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    fetch("/-verso-docs.json").then((resp) => resp.json()).then((versoDocData) => {

      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        theme: "lean",
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        ignoreAttributes: true,
        onShow(inst) {
          if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          content.className = "hl lean";
          content.style.display = "block";
          content.style.maxHeight = "300px";
          content.style.overflowY = "auto";
          content.style.overflowX = "hidden";
          const hoverId = tgt.dataset.versoHover;
          const hoverInfo = tgt.querySelector(".hover-info");
          if (hoverId) { // Docstrings from the table
            // TODO stop doing an implicit conversion from string to number here
            let data = versoDocData[hoverId];
            if (data) {
              const info = document.createElement("span");
              info.className = "hover-info";
              info.style.display = "block";
              info.innerHTML = data;
              content.appendChild(info);
              /* Render docstrings - TODO server-side */
              if ('undefined' !== typeof marked) {
                  for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                      const str = d.innerText;
                      const html = marked.parse(str);
                      const rendered = document.createElement("div");
                      rendered.classList.add("docstring");
                      rendered.innerHTML = html;
                      d.parentNode.replaceChild(rendered, d);
                  }
              }
            } else {
              content.innerHTML = "Failed to load doc ID: " + hoverId;
            }
          } else if (hoverInfo) { // The inline info, still used for compiler messages
            content.appendChild(hoverInfo.cloneNode(true));
          }
          return content;
        }
      };

      const addTippy = (selector, props) => {
        tippy(selector, Object.assign({}, defaultTippyProps, props));
      };
      addTippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token', {theme: 'lean'});
      addTippy('.hl.lean .has-info.warning', {theme: 'warning message'});
      addTippy('.hl.lean .has-info.info', {theme: 'info message'});
      addTippy('.hl.lean .has-info.error', {theme: 'error message'});

      tippy('.hl.lean .tactic', {
        allowHtml: true,
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        maxWidth: "none",
        onShow(inst) {
          const toggle = inst.reference.querySelector("input.tactic-toggle");
          if (toggle && toggle.checked) {
            return false;
          }
          if (blockedByTippy(inst.reference)) { return false; }
        },
        theme: "tactic",
        placement: 'bottom-start',
        content (tgt) {
          const content = document.createElement("span");
          const state = tgt.querySelector(".tactic-state").cloneNode(true);
          state.style.display = "block";
          content.appendChild(state);
          content.style.display = "block";
          content.className = "hl lean popup";
          return content;
        }
      });
  });
}
</script>
    </head>
  <body>
    <div class="with-toc">
      <header>
        <h1>
          <a href="../../">Scientific Computing in Lean</a></h1>
        <div id="controls">
          <label for="toggle-toc" id="toggle-toc-click">📖</label></div>
        <div id="print">
          <span>🖨</span></div>
        </header>
      <nav id="toc">
        <input type="checkbox" id="toggle-toc" checked="checked"><ol>
          <li>
            <a href="../../Introduction#Scientific-Computing-in-Lean--Introduction">Introduction</a><ol>
              <li>
                <a href="../../Introduction/Introduction#Scientific-Computing-in-Lean--Introduction--Introduction">Introduction</a><ol>
                  <li>
                    <a href="../../Introduction/Introduction#Scientific-Computing-in-Lean--Introduction--Introduction--Why-Lean-for-Scientific-Computing">Why Lean for Scientific Computing?</a></li>
                  </ol>
                </li>
              </ol>
            </li>
          <li>
            <a href="../../Working-with-Arrays#Scientific-Computing-in-Lean--Working-with-Arrays">Working with Arrays</a><ol>
              <li>
                <a href="../../Working-with-Arrays/Basic-Operations#Scientific-Computing-in-Lean--Working-with-Arrays--Basic-Operations">Basic Operations</a><ol>
                  <li>
                    <a href="../../Working-with-Arrays/Basic-Operations#Scientific-Computing-in-Lean--Working-with-Arrays--Basic-Operations--Reshaping-Arrays">Reshaping Arrays</a></li>
                  <li>
                    <a href="../../Working-with-Arrays/Basic-Operations#Scientific-Computing-in-Lean--Working-with-Arrays--Basic-Operations--Exercises">Exercises</a></li>
                  </ol>
                </li>
              <li>
                <a href="../../Working-with-Arrays/Tensor-Operations#Scientific-Computing-in-Lean--Working-with-Arrays--Tensor-Operations">Tensor Operations</a><ol>
                  <li>
                    <a href="../../Working-with-Arrays/Tensor-Operations#Scientific-Computing-in-Lean--Working-with-Arrays--Tensor-Operations--Transformations-and-Reductions">Transformations and Reductions</a></li>
                  <li>
                    <a href="../../Working-with-Arrays/Tensor-Operations#Scientific-Computing-in-Lean--Working-with-Arrays--Tensor-Operations--Convolution-and-Operations-on-Indices">Convolution and Operations on Indices</a></li>
                  <li>
                    <a href="../../Working-with-Arrays/Tensor-Operations#Scientific-Computing-in-Lean--Working-with-Arrays--Tensor-Operations--Pooling-and-Difficulties-with-Dependent-Types">Pooling and Difficulties with Dependent Types</a></li>
                  <li>
                    <a href="../../Working-with-Arrays/Tensor-Operations#Scientific-Computing-in-Lean--Working-with-Arrays--Tensor-Operations--Simple-Neural-Network">Simple Neural Network</a></li>
                  </ol>
                </li>
              <li>
                <a href="../../Working-with-Arrays/Optimizing-Array-Expressions#Scientific-Computing-in-Lean--Working-with-Arrays--Optimizing-Array-Expressions">Optimizing Array Expressions</a><ol>
                  <li>
                    <a href="../../Working-with-Arrays/Optimizing-Array-Expressions#Scientific-Computing-in-Lean--Working-with-Arrays--Optimizing-Array-Expressions--Loop-Fusion">Loop Fusion</a></li>
                  <li>
                    <a href="../../Working-with-Arrays/Optimizing-Array-Expressions#Scientific-Computing-in-Lean--Working-with-Arrays--Optimizing-Array-Expressions--Optimizing-Array-Indexing">Optimizing Array Indexing</a></li>
                  </ol>
                </li>
              </ol>
            </li>
          <li>
            <a href="../../-Differentiation#Scientific-Computing-in-Lean---Differentiation">🚧 Differentiation</a><ol>
              <li>
                <a href="../../-Differentiation/Symbolic-Differentiation#Scientific-Computing-in-Lean---Differentiation--Symbolic-Differentiation">Symbolic Differentiation</a><ol>
                  <li>
                    <a href="../../-Differentiation/Symbolic-Differentiation#Scientific-Computing-in-Lean---Differentiation--Symbolic-Differentiation--Notation">Notation</a></li>
                  <li>
                    <a href="../../-Differentiation/Symbolic-Differentiation#Scientific-Computing-in-Lean---Differentiation--Symbolic-Differentiation--Examples">Examples</a></li>
                  <li>
                    <a href="../../-Differentiation/Symbolic-Differentiation#Scientific-Computing-in-Lean---Differentiation--Symbolic-Differentiation--Gradient">Gradient</a></li>
                  <li>
                    <a href="../../-Differentiation/Symbolic-Differentiation#Scientific-Computing-in-Lean---Differentiation--Symbolic-Differentiation--Derivative-Rules">Derivative Rules</a></li>
                  <li>
                    <a href="../../-Differentiation/Symbolic-Differentiation#Scientific-Computing-in-Lean---Differentiation--Symbolic-Differentiation--Differentiating-Division-Log-Sqrt-">Differentiating Division, Log, Sqrt, ...</a></li>
                  <li>
                    <a href="../../-Differentiation/Symbolic-Differentiation#Scientific-Computing-in-Lean---Differentiation--Symbolic-Differentiation--Abstract-Vector-Spaces">Abstract Vector Spaces</a></li>
                  </ol>
                </li>
              <li>
                <a href="../../-Differentiation/Automatic-Differentiation#Scientific-Computing-in-Lean---Differentiation--Automatic-Differentiation">Automatic Differentiation</a><ol>
                  <li>
                    <a href="../../-Differentiation/Automatic-Differentiation#Scientific-Computing-in-Lean---Differentiation--Automatic-Differentiation--Forward-Mode">Forward Mode</a></li>
                  <li>
                    <a href="../../-Differentiation/Automatic-Differentiation#Scientific-Computing-in-Lean---Differentiation--Automatic-Differentiation--Reverse-Mode">Reverse Mode</a></li>
                  <li>
                    <a href="../../-Differentiation/Automatic-Differentiation#Scientific-Computing-in-Lean---Differentiation--Automatic-Differentiation--Derivatives-of-Neural-Network-Layers">Derivatives of Neural Network Layers</a></li>
                  </ol>
                </li>
              <li>
                <a href="../../-Differentiation/Derivative-Rules#Scientific-Computing-in-Lean---Differentiation--Derivative-Rules">Derivative Rules</a><ol>
                  <li>
                    <a href="../../-Differentiation/Derivative-Rules#Scientific-Computing-in-Lean---Differentiation--Derivative-Rules--Basic-Rules">Basic Rules</a></li>
                  <li>
                    <a href="../../-Differentiation/Derivative-Rules#Scientific-Computing-in-Lean---Differentiation--Derivative-Rules--Rules-with-Conditions">Rules with Conditions</a></li>
                  <li>
                    <a href="../../-Differentiation/Derivative-Rules#Scientific-Computing-in-Lean---Differentiation--Derivative-Rules--Higher-Order-Functions">Higher Order Functions</a></li>
                  <li>
                    <a href="../../-Differentiation/Derivative-Rules#Scientific-Computing-in-Lean---Differentiation--Derivative-Rules--Recursive-Functions">Recursive Functions</a></li>
                  <li>
                    <a href="../../-Differentiation/Derivative-Rules#Scientific-Computing-in-Lean---Differentiation--Derivative-Rules--Custom-Structures">Custom Structures</a></li>
                  <li>
                    <a href="../../-Differentiation/Derivative-Rules#Scientific-Computing-in-Lean---Differentiation--Derivative-Rules--Polymorphics-Functions">Polymorphics Functions</a></li>
                  </ol>
                </li>
              <li>
                <a href="../../-Differentiation/Differentiating-Array-Expressions#Scientific-Computing-in-Lean---Differentiation--Differentiating-Array-Expressions">Differentiating Array Expressions</a></li>
              <li>
                <a href="../../-Differentiation/Imperative-and-Monadic-Code#Scientific-Computing-in-Lean---Differentiation--Imperative-and-Monadic-Code">Imperative and Monadic Code</a><ol>
                  <li>
                    <a href="../../-Differentiation/Imperative-and-Monadic-Code#Scientific-Computing-in-Lean---Differentiation--Imperative-and-Monadic-Code--Control-flow">Control flow</a></li>
                  <li>
                    <a href="../../-Differentiation/Imperative-and-Monadic-Code#Scientific-Computing-in-Lean---Differentiation--Imperative-and-Monadic-Code--Differentiable-Monad">Differentiable Monad</a></li>
                  <li>
                    <a href="../../-Differentiation/Imperative-and-Monadic-Code#Scientific-Computing-in-Lean---Differentiation--Imperative-and-Monadic-Code--Forward-Derivative-Monad">Forward Derivative Monad</a></li>
                  <li>
                    <a href="../../-Differentiation/Imperative-and-Monadic-Code#Scientific-Computing-in-Lean---Differentiation--Imperative-and-Monadic-Code--Reverse-Derivative-Monad">Reverse Derivative Monad</a></li>
                  </ol>
                </li>
              <li>
                <a href="../../-Differentiation/Variational-Calculus#Scientific-Computing-in-Lean---Differentiation--Variational-Calculus">Variational Calculus</a></li>
              </ol>
            </li>
          <li>
            <a href="../../-Function-Transformation#Scientific-Computing-in-Lean---Function-Transformation">🚧 Function Transformation</a><ol>
              <li>
                <a href="../../-Function-Transformation/User-Defined-Function-Transformation#Scientific-Computing-in-Lean---Function-Transformation--User-Defined-Function-Transformation">User Defined Function Transformation</a><ol>
                  <li>
                    <a href="../../-Function-Transformation/User-Defined-Function-Transformation#Scientific-Computing-in-Lean---Function-Transformation--User-Defined-Function-Transformation--Lambda-Theorems">Lambda Theorems</a></li>
                  <li>
                    <a href="../../-Function-Transformation/User-Defined-Function-Transformation#Scientific-Computing-in-Lean---Function-Transformation--User-Defined-Function-Transformation--Function-Theorems">Function Theorems</a></li>
                  <li>
                    <a href="../../-Function-Transformation/User-Defined-Function-Transformation#Scientific-Computing-in-Lean---Function-Transformation--User-Defined-Function-Transformation--Free-Variable-Theorems">Free Variable Theorems</a></li>
                  <li>
                    <a href="../../-Function-Transformation/User-Defined-Function-Transformation#Scientific-Computing-in-Lean---Function-Transformation--User-Defined-Function-Transformation--Morphism-Theorems">Morphism Theorems</a></li>
                  <li>
                    <a href="../../-Function-Transformation/User-Defined-Function-Transformation#Scientific-Computing-in-Lean---Function-Transformation--User-Defined-Function-Transformation--Advanced-Function-Theorems">Advanced Function Theorems</a></li>
                  </ol>
                </li>
              <li>
                <a href="../../-Function-Transformation/Expression-Compiler#Scientific-Computing-in-Lean---Function-Transformation--Expression-Compiler">Expression Compiler</a><ol>
                  <li>
                    <a href="../../-Function-Transformation/Expression-Compiler#Scientific-Computing-in-Lean---Function-Transformation--Expression-Compiler--Compiling-from-Lean-to-Expressions">Compiling from Lean to Expressions</a></li>
                  </ol>
                </li>
              </ol>
            </li>
          <li>
            <a href="../../Miscellaneous#Scientific-Computing-in-Lean--Miscellaneous">Miscellaneous</a><ol>
              <li>
                <a href="../../Miscellaneous/Typeclasses-as-Interfaces-and-Function-Overloading#Scientific-Computing-in-Lean--Miscellaneous--Typeclasses-as-Interfaces-and-Function-Overloading">Typeclasses as Interfaces and Function Overloading</a><ol>
                  <li>
                    <a href="../../Miscellaneous/Typeclasses-as-Interfaces-and-Function-Overloading#Scientific-Computing-in-Lean--Miscellaneous--Typeclasses-as-Interfaces-and-Function-Overloading--Function-overloading">Function overloading</a></li>
                  <li>
                    <a href="../../Miscellaneous/Typeclasses-as-Interfaces-and-Function-Overloading#Scientific-Computing-in-Lean--Miscellaneous--Typeclasses-as-Interfaces-and-Function-Overloading--Typeclasses-as-Interfaces">Typeclasses as Interfaces</a></li>
                  </ol>
                </li>
              <li>
                <a href="../../Miscellaneous/Working-with-Quotients#Scientific-Computing-in-Lean--Miscellaneous--Working-with-Quotients">Working with Quotients</a><ol>
                  <li>
                    <a href="../../Miscellaneous/Working-with-Quotients#Scientific-Computing-in-Lean--Miscellaneous--Working-with-Quotients--Unordered-Pair">Unordered Pair</a></li>
                  <li>
                    <a href="../../Miscellaneous/Working-with-Quotients#Scientific-Computing-in-Lean--Miscellaneous--Working-with-Quotients--Symbolic-Expressions">Symbolic Expressions</a></li>
                  </ol>
                </li>
              </ol>
            </li>
          <li>
            <a href="../../Examples#Scientific-Computing-in-Lean--Examples">Examples</a><ol>
              <li>
                <a href="../../Examples/Harmonic-Oscillator#Scientific-Computing-in-Lean--Examples--Harmonic-Oscillator">Harmonic Oscillator</a></li>
              </ol>
            </li>
          </ol>
        </nav>
      <main><section>
          <h1>
            Typeclasses as Interfaces and Function Overloading</h1>
          <p>
            Typeclasses in Lean bring together multiple concepts from other programming languages, notably function overloading and interfaces. In this section, we will focus on how to use typeclasses in Lean and how they relate to these familiar programming paradigms. For a deeper explanation of typeclasses we refer the reader to <a href="https://lean-lang.org/functional_programming_in_lean/type-classes.html">Overloading and Type Classes in FPiL</a></p>
          <section>
            <h2 id="Scientific-Computing-in-Lean--Miscellaneous--Typeclasses-as-Interfaces-and-Function-Overloading--Function-overloading">
              Function overloading</h2>
            <p>
              In many programming languages, function overloading allows the same function name to have different implementations depending on the types of its arguments. This is sometimes called <strong>ad-hoc polymorphism</strong>, where the behavior of a function adapts based on the types of its inputs.</p>
            <p>
              In Lean, function overloading is achieved through typeclasses. A simple example is defining a <code>size</code> function that works on different types:</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.classTk-1269">class</span> <span class="const token" data-binding="const-Overloading.Size" data-verso-hover="626">Size</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="39">A</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="">Type</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-null-1291">where</span>
  <span class="const token" data-binding="const-Overloading.Size.size" data-verso-hover="627">size</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="39">A</span> <span class="unknown token" data-binding="">-&gt;</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span>
<span class="unknown token" data-binding=""></span></code><p>
              This defines a function <code>size</code> for any type <code>A</code>, as long as there’s an instance of <code>Size</code> for that type. We can define an instance of <code>Size</code> for lists, where the size of a list corresponds to its length:</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-1535">instance</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="39">A</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="">Type</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Overloading.Size" data-verso-hover="626">Size</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-List" data-verso-hover="20">List</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="39">A</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-1571">where</span>
  <span class="const token" data-binding="const-Overloading.Size.size" data-verso-hover="628">size</span> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="629">l</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="629">l</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-List.length" data-verso-hover="550">length</span>
<span class="unknown token" data-binding=""></span></code><p>
              For strings, <code>size</code> can return the length of the string:</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-1669">instance</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Overloading.Size" data-verso-hover="626">Size</span> <span class="const token" data-binding="const-String" data-verso-hover="28">String</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-1692">where</span>
  <span class="const token" data-binding="const-Overloading.Size.size" data-verso-hover="630">size</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="488">s</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="488">s</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-String.length" data-verso-hover="631">length</span>
<span class="unknown token" data-binding=""></span></code><p>
              For the type <code>Unit</code> (which has only one value), the size can always return <code>0</code>:</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-1813">instance</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Overloading.Size" data-verso-hover="626">Size</span> <span class="const token" data-binding="const-Unit" data-verso-hover="632">Unit</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-1834">where</span>
  <span class="const token" data-binding="const-Overloading.Size.size" data-verso-hover="633">size</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">0</span>
<span class="unknown token" data-binding=""></span></code><p>
              With these instances, the <code>size</code> function is now overloaded and can be used with different types:</p>
            <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">3
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-1966">#eval</span></span> <span class="const token" data-binding="const-Overloading.Size.size" data-verso-hover="627">Size.size</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">3</span><span class="unknown token" data-binding="">]</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">5
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-1992">#eval</span></span> <span class="const token" data-binding="const-Overloading.Size.size" data-verso-hover="627">Size.size</span> <span class="literal string token" data-binding="" data-verso-hover="29">"hello"</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">0
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-2016">#eval</span></span> <span class="const token" data-binding="const-Overloading.Size.size" data-verso-hover="627">Size.size</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
              A more complex example of function overloading is scalar multiplication, where we want to multiply elements of a type <code>X</code> by a scalar of type <code>R</code>:</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.classTk-2196">class</span> <span class="const token" data-binding="const-Overloading.SMul" data-verso-hover="634">SMul</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="39">R</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="39">X</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="">Type</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-null-2220">where</span>
  <span class="const token" data-binding="const-Overloading.SMul.smul" data-verso-hover="635">smul</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="39">R</span> <span class="unknown token" data-binding="">-&gt;</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="39">X</span> <span class="unknown token" data-binding="">-&gt;</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="39">X</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.export-2248" data-verso-hover="636">export</span> <span class="unknown token" data-binding="">SMul</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Overloading.SMul.smul" data-verso-hover="635">smul</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
              The <code>smul</code> function allows us to define scalar multiplication for any pair of types <code>R</code> and <code>X</code>. The command <code>export SMul (smul)</code> exports <code>smul</code> from <code>SMul</code> namespace so we can write just <code>smul</code> instead of <code>SMul.smul</code>. Here’s how we might multiply a list of natural numbers by a scalar:</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-2570">def</span> <span class="const token" data-binding="const-Overloading.natListSMul" data-verso-hover="637">natListSMul</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">n</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="24">l</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-List" data-verso-hover="20">List</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-List" data-verso-hover="20">List</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span> <span class="unknown token" data-binding="">:=</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-2627" data-verso-hover="25">match</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="24">l</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-2627" data-verso-hover="25">with</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.41" data-verso-hover="4">x</span> <span class="unknown token" data-binding="">::</span> <span class="var token" data-binding="var-_uniq.42" data-verso-hover="24">xs</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">n</span> <span class="unknown token" data-binding="">*</span> <span class="var token" data-binding="var-_uniq.41" data-verso-hover="4">x</span> <span class="unknown token" data-binding="">::</span> <span class="const token" data-binding="const-Overloading.natListSMul" data-verso-hover="637">natListSMul</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">n</span> <span class="var token" data-binding="var-_uniq.42" data-verso-hover="24">xs</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-2695">instance</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Overloading.SMul" data-verso-hover="634">SMul</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-List" data-verso-hover="20">List</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">⟨</span><span class="const token" data-binding="const-Overloading.natListSMul" data-verso-hover="637">natListSMul</span><span class="unknown token" data-binding="">⟩</span>
<span class="unknown token" data-binding=""></span></code><p>
              This instance allows us to multiply a list of natural numbers by a natural number. However, we can generalize this further to work with any list of <code>X</code> where scalar multiplication between <code>R</code> and <code>X</code> is already defined:</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-2981">def</span> <span class="const token" data-binding="const-Overloading.listSMul" data-verso-hover="638">listSMul</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-Overloading.SMul" data-verso-hover="634">SMul</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="39">R</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="39">X</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="430">r</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="39">R</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="639">l</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-List" data-verso-hover="20">List</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="39">X</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-List" data-verso-hover="20">List</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="39">X</span> <span class="unknown token" data-binding="">:=</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-3040" data-verso-hover="25">match</span> <span class="var token" data-binding="var-_uniq.15" data-verso-hover="639">l</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-3040" data-verso-hover="25">with</span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.54" data-verso-hover="271">x</span> <span class="unknown token" data-binding="">::</span> <span class="var token" data-binding="var-_uniq.55" data-verso-hover="639">xs</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-Overloading.SMul.smul" data-verso-hover="635">smul</span> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="430">r</span> <span class="var token" data-binding="var-_uniq.54" data-verso-hover="271">x</span> <span class="unknown token" data-binding="">::</span> <span class="const token" data-binding="const-Overloading.listSMul" data-verso-hover="638">listSMul</span> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="430">r</span> <span class="var token" data-binding="var-_uniq.55" data-verso-hover="639">xs</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-3108">instance</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Overloading.SMul" data-verso-hover="634">SMul</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">⟨</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-3138">fun</span> <span class="var token" data-binding="var-_uniq.250" data-verso-hover="4">x</span> <span class="var token" data-binding="var-_uniq.253" data-verso-hover="4">y</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.250" data-verso-hover="4">x</span> <span class="unknown token" data-binding="">*</span> <span class="var token" data-binding="var-_uniq.253" data-verso-hover="4">y</span><span class="unknown token" data-binding="">⟩</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-3158">instance</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-Overloading.SMul" data-verso-hover="634">SMul</span> <span class="var token" data-binding="var-_uniq.325" data-verso-hover="39">R</span> <span class="var token" data-binding="var-_uniq.329" data-verso-hover="39">X</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Overloading.SMul" data-verso-hover="634">SMul</span> <span class="var token" data-binding="var-_uniq.325" data-verso-hover="39">R</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-List" data-verso-hover="20">List</span> <span class="var token" data-binding="var-_uniq.329" data-verso-hover="39">X</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">⟨</span><span class="const token" data-binding="const-Overloading.listSMul" data-verso-hover="638">listSMul</span><span class="unknown token" data-binding="">⟩</span>
<span class="unknown token" data-binding=""></span></code><p>
              Now we can scalar multiply not only lists of natural numbers but also lists of any type <code>X</code> where <code>smul</code> is defined. We can even apply this recursively to lists of lists:</p>
            <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">[10, 20]
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-3399">#eval</span></span> <span class="const token" data-binding="const-Overloading.SMul.smul" data-verso-hover="635">smul</span> <span class="unknown token" data-binding="">10</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">]</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">[[10, 20], [30, 40]]
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-3420">#eval</span></span> <span class="const token" data-binding="const-Overloading.SMul.smul" data-verso-hover="635">smul</span> <span class="unknown token" data-binding="">10</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">3</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">4</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">]</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">[[[10, 20], [30, 40]], [[50, 60], [70, 80]]]
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-3451">#eval</span></span> <span class="const token" data-binding="const-Overloading.SMul.smul" data-verso-hover="635">smul</span> <span class="unknown token" data-binding="">10</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">3</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">4</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">5</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">6</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">7</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">8</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">]</span>
<span class="unknown token" data-binding=""></span></code><p>
              In these examples, <code>smul</code> is overloaded based on the types involved, allowing flexible behavior for scalar multiplication.</p>
            <p>
              Previously, for <code>size</code> and <code>smul</code>, the output type was either known or closely related to the input types. A more advanced example is <strong>matrix multiplication</strong>, where the output type is different from any of the input types. Multiplying two matrices <code>A : Float^[n, m]</code> and <code>B : Float^[m, k]</code> results in a matrix of type <code>Float^[n, k]</code>. The output type is fully determined by the input types but is not directly one of them. We can express this relationship using an <strong>output parameter</strong>:</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.classTk-4128">class</span> <span class="const token" data-binding="const-Overloading.MyMul" data-verso-hover="640">MyMul</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="39">X</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="39">Y</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="">Type</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="641">Z</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-outParam" data-verso-hover="642">outParam</span> <span class="sort token" data-binding="">Type</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-null-4173">where</span>
  <span class="const token" data-binding="const-Overloading.MyMul.mymul" data-verso-hover="643">mymul</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="39">X</span> <span class="unknown token" data-binding="">-&gt;</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="39">Y</span> <span class="unknown token" data-binding="">-&gt;</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="641">Z</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.export-4202" data-verso-hover="636">export</span> <span class="unknown token" data-binding="">MyMul</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Overloading.MyMul.mymul" data-verso-hover="643">mymul</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
              The <code>outParam</code> keyword tells Lean’s type inference that the output type <code>Z</code> is determined by the input types <code>X</code> and <code>Y</code>. We can then define an instance for matrix multiplication:</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-4419">instance</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Overloading.MyMul" data-verso-hover="640">MyMul</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span><span class="unknown token" data-binding="">^[</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="4">n</span><span class="unknown token" data-binding="">,</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="4">m</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span><span class="unknown token" data-binding="">^[</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="4">m</span><span class="unknown token" data-binding="">,</span><span class="var token" data-binding="var-_uniq.31" data-verso-hover="4">k</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span><span class="unknown token" data-binding="">^[</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="4">n</span><span class="unknown token" data-binding="">,</span><span class="var token" data-binding="var-_uniq.31" data-verso-hover="4">k</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-4478">where</span>
  <span class="const token" data-binding="const-Overloading.MyMul.mymul" data-verso-hover="644">mymul</span> <span class="var token" data-binding="var-_uniq.75" data-verso-hover="59">A</span> <span class="var token" data-binding="var-_uniq.78" data-verso-hover="645">B</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">⊞</span> <span class="var token" data-binding="var-_uniq.81" data-verso-hover="32">i</span> <span class="var token" data-binding="var-_uniq.84" data-verso-hover="114">j</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">∑</span> <span class="var token" data-binding="var-_uniq.94" data-verso-hover="58">l</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.75" data-verso-hover="59">A</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.81" data-verso-hover="32">i</span><span class="unknown token" data-binding="">,</span><span class="var token" data-binding="var-_uniq.94" data-verso-hover="58">l</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">*</span> <span class="var token" data-binding="var-_uniq.78" data-verso-hover="645">B</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.94" data-verso-hover="58">l</span><span class="unknown token" data-binding="">,</span><span class="var token" data-binding="var-_uniq.84" data-verso-hover="114">j</span><span class="unknown token" data-binding="">]</span>

<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">⊞[13.000000, 3000.000000, 24.000000, 4000.000000]
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-4534">#eval</span></span> <span class="const token" data-binding="const-Overloading.MyMul.mymul" data-verso-hover="643">mymul</span> <span class="unknown token" data-binding="">⊞[</span><span class="unknown token" data-binding="">10.0</span><span class="unknown token" data-binding="">,</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">;</span><span class="unknown token" data-binding="">0</span><span class="unknown token" data-binding="">,</span><span class="unknown token" data-binding="">1000</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">⊞[</span><span class="unknown token" data-binding="">1.0</span><span class="unknown token" data-binding="">,</span><span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">;</span><span class="unknown token" data-binding="">3</span><span class="unknown token" data-binding="">,</span><span class="unknown token" data-binding="">4</span><span class="unknown token" data-binding="">]</span>
<span class="unknown token" data-binding=""></span></code><p>
              Lean already comes with a variety of typeclasses for <strong>heterogeneous operations</strong>, such as <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-HAdd" data-verso-hover="646">HAdd</span></code>, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-HMul" data-verso-hover="647">HMul</span></code>, and others, which are used every time you write <code>+</code>, <code>*</code>, or similar operations. These typeclasses enable function overloading for basic operators, providing an expressive and flexible way to define operations for a variety of types.</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-4947" data-verso-hover="191">set_option</span> <span class="option token" data-binding="option-Lean.pp.notation" data-verso-hover="648">pp.notation</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-4947" data-verso-hover="191">false</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.in-4947">in</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">HAdd.hAdd 2 3 : Nat</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-4979">#check</span></span> <span class="unknown token" data-binding="">2</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">3</span> 
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">5
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-4993">#eval</span></span> <span class="unknown token" data-binding="">2</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">3</span> 
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-5006" data-verso-hover="191">set_option</span> <span class="option token" data-binding="option-Lean.pp.notation" data-verso-hover="648">pp.notation</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-5006" data-verso-hover="191">false</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.in-5006">in</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">HAppend.hAppend (List.cons 1 (List.cons 2 (List.cons 3 List.nil)))
  (List.cons 4 (List.cons 5 (List.cons 6 List.nil))) : List Nat</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-5038">#check</span></span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">3</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">++</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">4</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">5</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">6</span><span class="unknown token" data-binding="">]</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">[1, 2, 3, 4, 5, 6]
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-5068">#eval</span></span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">3</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">++</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">4</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">5</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">6</span><span class="unknown token" data-binding="">]</span>
<span class="unknown token" data-binding=""></span></code><p>
              By turning off notation, <code>set_option pp.notation false</code>, we can see that <code>+</code> is a syntax for <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="152">HAdd.hAdd</span></code> and <code>++</code> is syntax for <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-HAppend.hAppend" data-verso-hover="649">HAppend.hAppend</span></code></p>
            <section>
              <h3 id="Scientific-Computing-in-Lean--Miscellaneous--Typeclasses-as-Interfaces-and-Function-Overloading--Function-overloading--Where-is-the-Overloaded-Function-Defined">
                Where is the Overloaded Function Defined?</h3>
              <p>
                When dealing with overloaded functions in Lean, it's important to know how to trace back to where specific implementations are defined. Overloaded functions, like <code>HAdd.hAdd</code>, have different implementations depending on the types they work with. Simply navigating to the definition of the typeclass <code>HAdd</code> will not show the specific implementations; it will only take you to the typeclass itself.</p>
              <p>
                To find the exact definition of an overloaded function, you can use several techniques. Let’s explore these methods with an example.</p>
              <section>
                <h4 id="Scientific-Computing-in-Lean--Miscellaneous--Typeclasses-as-Interfaces-and-Function-Overloading--Function-overloading--Where-is-the-Overloaded-Function-Defined--Finding-the-Definition-Using--missing">
                  Finding the Definition Using <code>#synth</code></h4>
                <p>
                  The <code>#synth</code> command can be used to discover which instance of a typeclass is being utilized. For example, if you want to find out where negation for integers is defined, you can use:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Int.instNegInt</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.synth-6189">#synth</span></span> <span class="const token" data-binding="const-Neg" data-verso-hover="650">Neg</span> <span class="const token" data-binding="const-Int" data-verso-hover="651">Int</span>
<span class="unknown token" data-binding=""></span></code><p>
                  The output of this command will show which instance of the <code>Neg</code> typeclass is being used for integers:</p>
                <div class="information">
                  <pre>Int.instNegInt
</pre></div>
                <p>
                  This tells us that the instance for negation on integers is <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Int.instNegInt" data-verso-hover="652">Int.instNegInt</span></code>. To view the details of this instance, you can print it out:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">def Int.instNegInt : Neg ℤ :=
{ neg := Int.neg }</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.print-6531">#print</span></span> <span class="const token" data-binding="const-Int.instNegInt" data-verso-hover="652">Int.instNegInt</span>
<span class="unknown token" data-binding=""></span></code><p>
                  The output will provide the definition of the instance:</p>
                <pre>def Int.instNegInt : Neg ℤ := { neg := Int.neg } 
</pre><p>
                  Here, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Int.instNegInt" data-verso-hover="652">Int.instNegInt</span></code> is defined as an instance of the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Neg" data-verso-hover="650">Neg</span></code> typeclass for integers, with <code>neg</code> being implemented by the function <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Int.neg" data-verso-hover="653">Int.neg</span></code>. This shows how the <code>-</code> operator for integers is handled.</p>
                </section>
              <section>
                <h4 id="Scientific-Computing-in-Lean--Miscellaneous--Typeclasses-as-Interfaces-and-Function-Overloading--Function-overloading--Where-is-the-Overloaded-Function-Defined--Alternative-Method-Using--missing">
                  Alternative Method: Using <code>pp.all</code></h4>
                <p>
                  Another method to locate the specific instance is by using the <code>pp.all</code> option, which allows you to see all implicit arguments in your code. This can be particularly useful for understanding which instance is applied:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-7161" data-verso-hover="191">set_option</span> <span class="option token" data-binding="option-Lean.pp.all" data-verso-hover="654">pp.all</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-7161" data-verso-hover="191">true</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.in-7161">in</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">fun (x : Int) =&gt; @Neg.neg.{0} Int Int.instNegInt x : Int → Int</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-7187">#check</span></span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-7194">fun</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="655">x</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Int" data-verso-hover="651">Int</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">-</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="655">x</span>
<span class="unknown token" data-binding=""></span></code><p>
                  The result of this command will show:</p>
                <pre>fun (x : Int) =&gt; @Neg.neg.{0} Int Int.instNegInt x : Int → Int
</pre><p>
                  This output indicates that the negation operation for integers uses the instance <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Int.instNegInt" data-verso-hover="652">Int.instNegInt</span></code>, showing that <code>Neg.neg</code> is applied with the specific instance for integers.</p>
                <p>
                  By using these techniques, you can effectively trace back from an overloaded function to its specific instance, helping you understand how different types are handled by Lean’s typeclass system.</p>
                </section>
              </section>
            <section>
              <h3 id="Scientific-Computing-in-Lean--Miscellaneous--Typeclasses-as-Interfaces-and-Function-Overloading--Function-overloading--Defining-Functions-Inductively-on-the-Type">
                Defining Functions "Inductively" on the Type</h3>
              <p>
                In Lean, defining functions "inductively" on types involves creating instances for various cases of a type in order to handle arbitrary nesting and combinations of types such as lists, arrays, and products. This technique resembles mathematical induction, where we handle base cases and then generalize to more complex cases. Although Lean's <code>Type</code> is not an inductive data type, we can mimic inductive definitions by providing instances for each specific case we want to cover. This approach allows us to define flexible functions over a subset of types.</p>
              <section>
                <h4 id="Scientific-Computing-in-Lean--Miscellaneous--Typeclasses-as-Interfaces-and-Function-Overloading--Function-overloading--Defining-Functions-Inductively-on-the-Type--Example-Summing-Nested-Structures">
                  Example: Summing Nested Structures</h4>
                <p>
                  Let’s define a function <code>sum</code> that computes the sum of all natural numbers in an expression that can be an arbitrary combination of lists, arrays, and products. For example, we want <code>sum (#[1,2], [(10,20),(5,15)], 100)</code> to equal <code>163</code>. Here, the argument is of type <code>Array Nat × List (Nat × Nat) × Nat</code>.</p>
                <p>
                  First, define a typeclass <code>Sum</code> for our function:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.classTk-8824">class</span> <span class="const token" data-binding="const-InductiveOverload.Sum" data-verso-hover="656">Sum</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="39">A</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="">Type</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-null-8845">where</span>
  <span class="const token" data-binding="const-InductiveOverload.Sum.sum" data-verso-hover="657">sum</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="39">A</span> <span class="unknown token" data-binding="">-&gt;</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.export-8869" data-verso-hover="636">export</span> <span class="unknown token" data-binding="">Sum</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-InductiveOverload.Sum.sum" data-verso-hover="657">sum</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><section>
                  <h5 id="Scientific-Computing-in-Lean--Miscellaneous--Typeclasses-as-Interfaces-and-Function-Overloading--Function-overloading--Defining-Functions-Inductively-on-the-Type--Example-Summing-Nested-Structures--Base-Case-Natural-Numbers">
                    Base Case: Natural Numbers</h5>
                  <p>
                    We start by defining the <code>sum</code> function for the base case, which is <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span></code>:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-9014">instance</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-InductiveOverload.Sum" data-verso-hover="656">Sum</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-9033">where</span>
  <span class="const token" data-binding="const-InductiveOverload.Sum.sum" data-verso-hover="658">sum</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="4">n</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="4">n</span>
<span class="unknown token" data-binding=""></span></code><p>
                    This instance handles the simplest case where the type is a natural number itself.</p>
                  </section>
                <section>
                  <h5 id="Scientific-Computing-in-Lean--Miscellaneous--Typeclasses-as-Interfaces-and-Function-Overloading--Function-overloading--Defining-Functions-Inductively-on-the-Type--Example-Summing-Nested-Structures--Inductive-Step-Lists">
                    Inductive Step: Lists</h5>
                  <p>
                    To handle lists of natural numbers or other types, we need to define how to sum elements of lists. For this, we assume that we have a <code>Sum</code> instance for the type of list elements. Here's how we define <code>Sum</code> for lists:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-9396">instance</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-InductiveOverload.Sum" data-verso-hover="656">Sum</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="39">A</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-InductiveOverload.Sum" data-verso-hover="656">Sum</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-List" data-verso-hover="20">List</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="39">A</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-9428">where</span>
  <span class="const token" data-binding="const-InductiveOverload.Sum.sum" data-verso-hover="628">sum</span> <span class="var token" data-binding="var-_uniq.16" data-verso-hover="629">l</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.16" data-verso-hover="629">l</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-List.foldl" data-verso-hover="659">foldl</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-9454">fun</span> <span class="var token" data-binding="var-_uniq.28" data-verso-hover="4">acc</span> <span class="var token" data-binding="var-_uniq.31" data-verso-hover="660">a</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.28" data-verso-hover="4">acc</span> <span class="unknown token" data-binding="">+</span> <span class="const token" data-binding="const-InductiveOverload.Sum.sum" data-verso-hover="657">sum</span> <span class="var token" data-binding="var-_uniq.31" data-verso-hover="660">a</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">0</span>
<span class="unknown token" data-binding=""></span></code><p>
                    This instance uses <code>foldl</code> to accumulate the sum of a list by applying the <code>sum</code> function to each element and adding the results.</p>
                  <p>
                    Now, we can compute the sum of lists of natural numbers:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">10
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-9684">#eval</span></span> <span class="const token" data-binding="const-InductiveOverload.Sum.sum" data-verso-hover="657">sum</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">3</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">4</span><span class="unknown token" data-binding="">]</span> 
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">10
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-9708">#eval</span></span> <span class="const token" data-binding="const-InductiveOverload.Sum.sum" data-verso-hover="657">sum</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">3</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">4</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">]</span>
<span class="unknown token" data-binding=""></span></code></section>
                <section>
                  <h5 id="Scientific-Computing-in-Lean--Miscellaneous--Typeclasses-as-Interfaces-and-Function-Overloading--Function-overloading--Defining-Functions-Inductively-on-the-Type--Example-Summing-Nested-Structures--Inductive-Step-Products">
                    Inductive Step: Products</h5>
                  <p>
                    Next, we handle products of two types. To sum the elements of a product, we need <code>Sum</code> instances for both components of the product:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-9913">instance</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-InductiveOverload.Sum" data-verso-hover="656">Sum</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="39">X</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-InductiveOverload.Sum" data-verso-hover="656">Sum</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="39">Y</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-InductiveOverload.Sum" data-verso-hover="656">Sum</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Prod" data-verso-hover="70">Prod</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="39">X</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="39">Y</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-9955">where</span>
  <span class="const token" data-binding="const-InductiveOverload.Sum.sum" data-verso-hover="661">sum</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-9970">fun</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.52" data-verso-hover="271">x</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.53" data-verso-hover="359">y</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-InductiveOverload.Sum.sum" data-verso-hover="657">sum</span> <span class="var token" data-binding="var-_uniq.52" data-verso-hover="271">x</span> <span class="unknown token" data-binding="">+</span> <span class="const token" data-binding="const-InductiveOverload.Sum.sum" data-verso-hover="657">sum</span> <span class="var token" data-binding="var-_uniq.53" data-verso-hover="359">y</span>
<span class="unknown token" data-binding=""></span></code><p>
                    This instance sums the components of a product by applying <code>sum</code> to each component and adding the results.</p>
                  </section>
                <section>
                  <h5 id="Scientific-Computing-in-Lean--Miscellaneous--Typeclasses-as-Interfaces-and-Function-Overloading--Function-overloading--Defining-Functions-Inductively-on-the-Type--Example-Summing-Nested-Structures--Handling-More-Complex-Cases">
                    Handling More Complex Cases</h5>
                  <p>
                    Our current implementation of <code>sum</code> effectively handles nested lists and products but encounters issues when dealing with elements that are not inherently summable. For example:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-10347">#eval</span> <span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">failed to synthesize
  Sum (List (String × ?m.43))
Additional diagnostic information may be available using the `set_option diagnostics true` command.</code></span></span><span class="const token" data-binding="const-InductiveOverload.Sum.sum" data-verso-hover="657">sum</span></span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">(</span><span class="literal string token" data-binding="" data-verso-hover="662">"dog"</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">15</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">(</span><span class="literal string token" data-binding="" data-verso-hover="663">"cat"</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">(</span><span class="literal string token" data-binding="" data-verso-hover="664">"elephant"</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">400</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">]</span>
<span class="unknown token" data-binding=""></span></code><p>
                    In this case, <code>sum</code> fails because tuples containing a string and a number do not have a direct <code>Sum</code> instance defined.</p>
                  <p>
                    To address such scenarios, one approach is to provide a default <code>Sum</code> instance for any type. This instance would act as a fallback when no more specific <code>Sum</code> instance is applicable:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-10719">instance</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namedPrio-10728">priority</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-prioLow-10741" data-verso-hover="665">low</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-InductiveOverload.Sum" data-verso-hover="656">Sum</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="39">A</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-10754">where</span>
  <span class="const token" data-binding="const-InductiveOverload.Sum.sum" data-verso-hover="666">sum</span> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="660">a</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">0</span>
<span class="unknown token" data-binding=""></span></code><p>
                    We assign a low priority to this default instance because it is intended to be used only as a fallback. By giving it low priority, Lean will prefer more specific <code>Sum</code> instances over this default one, preventing it from overriding cases where a more appropriate instance exists. This approach helps ensure that the default instance does not inadvertently mask other <code>Sum</code> implementations and is only used when no other suitable instance can be found.</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">417
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-11238">#eval</span></span> <span class="const token" data-binding="const-InductiveOverload.Sum.sum" data-verso-hover="657">sum</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">(</span><span class="literal string token" data-binding="" data-verso-hover="662">"dog"</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">15</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">(</span><span class="literal string token" data-binding="" data-verso-hover="663">"cat"</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">(</span><span class="literal string token" data-binding="" data-verso-hover="664">"elephant"</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">400</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">]</span>
<span class="unknown token" data-binding=""></span></code></section>
                </section>
              <section>
                <h4 id="Scientific-Computing-in-Lean--Miscellaneous--Typeclasses-as-Interfaces-and-Function-Overloading--Function-overloading--Defining-Functions-Inductively-on-the-Type--Working-with-Functions-of-Arbitrary-Arity">
                  Working with Functions of Arbitrary Arity</h4>
                <p>
                  One important application of defining functions inductively is to handle functions with arbitrary arity. For instance, consider uncurry functions, which transform functions from tuples into functions with multiple arguments. While one might want to define an uncurry function like this:</p>
                <pre>def uncurry (f : X₁ → ... → Xₙ → Y) (x : X₁ × ... × Xₙ) : Y := f x.1 ... x.n
</pre><p>
                  Lean does not support ellipses (<code>...</code>) for arbitrary arity directly. Instead, we use typeclasses to define a general <code>Uncurry</code> typeclass:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.classTk-11883">class</span> <span class="const token" data-binding="const-InductiveOverload.Uncurry" data-verso-hover="667">Uncurry</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="39">F</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="">Type</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="641">Xs</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="641">Y</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-outParam" data-verso-hover="642">outParam</span> <span class="sort token" data-binding="">Type</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-null-11931">where</span>
  <span class="const token" data-binding="const-InductiveOverload.Uncurry.uncurry" data-verso-hover="668">uncurry</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="39">F</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="641">Xs</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="641">Y</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.export-11965" data-verso-hover="636">export</span> <span class="unknown token" data-binding="">Uncurry</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-InductiveOverload.Uncurry.uncurry" data-verso-hover="668">uncurry</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
                  Here, <code>F</code> represents a function type <code>X1 → ... → Xn → Y</code>, and <code>Xs</code> represents the product type <code>X1 × ... × Xn</code>.</p>
                <p>
                  We define instances for different numbers of arguments by induction. For <code>n = 1</code>, we have:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-12216">instance</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-InductiveOverload.Uncurry" data-verso-hover="667">Uncurry</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="39">X</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="39">Y</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="39">X</span> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="39">Y</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-12249">where</span>
  <span class="const token" data-binding="const-InductiveOverload.Uncurry.uncurry" data-verso-hover="669">uncurry</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-12268">fun</span> <span class="var token" data-binding="var-_uniq.29" data-verso-hover="345">f</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.29" data-verso-hover="345">f</span>
<span class="unknown token" data-binding=""></span></code><p>
                  For the inductive step, where we have <code>n + 1</code> arguments:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-12350">instance</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-InductiveOverload.Uncurry" data-verso-hover="667">Uncurry</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="39">F</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="39">Xs</span> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="39">Y</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-InductiveOverload.Uncurry" data-verso-hover="667">Uncurry</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.19" data-verso-hover="39">X</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="39">F</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.19" data-verso-hover="39">X</span> <span class="unknown token" data-binding="">×</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="39">Xs</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="39">Y</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-12408">where</span>
  <span class="const token" data-binding="const-InductiveOverload.Uncurry.uncurry" data-verso-hover="670">uncurry</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-12427">fun</span> <span class="var token" data-binding="var-_uniq.44" data-verso-hover="671">f</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.72" data-verso-hover="271">x</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.73" data-verso-hover="672">xs</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-InductiveOverload.Uncurry.uncurry" data-verso-hover="668">Uncurry.uncurry</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.44" data-verso-hover="671">f</span> <span class="var token" data-binding="var-_uniq.72" data-verso-hover="271">x</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.73" data-verso-hover="672">xs</span>
<span class="unknown token" data-binding=""></span></code><p>
                  And a simple test:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">10
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-12501">#eval</span></span> <span class="const token" data-binding="const-InductiveOverload.Uncurry.uncurry" data-verso-hover="668">uncurry</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-12516">fun</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="4">a</span> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="4">b</span> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="4">c</span> <span class="var token" data-binding="var-_uniq.13" data-verso-hover="4">d</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="4">a</span> <span class="unknown token" data-binding="">+</span> <span class="var token" data-binding="var-_uniq.9" data-verso-hover="4">b</span> <span class="unknown token" data-binding="">+</span> <span class="var token" data-binding="var-_uniq.11" data-verso-hover="4">c</span> <span class="unknown token" data-binding="">+</span> <span class="var token" data-binding="var-_uniq.13" data-verso-hover="4">d</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span><span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">,</span><span class="unknown token" data-binding="">3</span><span class="unknown token" data-binding="">,</span><span class="unknown token" data-binding="">4</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
                  This general <code>uncurry</code> function is already provided by mathlib with <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Function.HasUncurry.uncurry" data-verso-hover="365">Function.HasUncurry.uncurry</span></code> and notation <code>↿f</code> for <code>Function.HasUncurry.uncurry f</code>.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">10
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-12737">#eval</span></span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">↿</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-12747">fun</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="4">a</span> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="4">b</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="4">c</span> <span class="var token" data-binding="var-_uniq.16" data-verso-hover="4">d</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="4">a</span> <span class="unknown token" data-binding="">+</span> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="4">b</span> <span class="unknown token" data-binding="">+</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="4">c</span> <span class="unknown token" data-binding="">+</span> <span class="var token" data-binding="var-_uniq.16" data-verso-hover="4">d</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span><span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">,</span><span class="unknown token" data-binding="">3</span><span class="unknown token" data-binding="">,</span><span class="unknown token" data-binding="">4</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code></section>
              <section>
                <h4 id="Scientific-Computing-in-Lean--Miscellaneous--Typeclasses-as-Interfaces-and-Function-Overloading--Function-overloading--Defining-Functions-Inductively-on-the-Type--Exercise">
                  Exercise</h4>
                <ol start="1">
                  <li>
                    <p>
                      Privide overload of <code>sum</code> for <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Array" data-verso-hover="0">Array</span></code>. The following whould work</p>
                    </li>
                  </ol>
                <pre>example : sum (#[1,3,4], [#[(10,5),(20,8)], #[100]], 1000) = 1251 := by 
  native_decide
</pre><div class="collapsible" onclick="this.classList.toggle('expanded');">
                  <div class="collapsible-header">
                    Solution</div>
                  <div class="collapsible-content">
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-13007">instance</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-InductiveOverload.Sum" data-verso-hover="656">Sum</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="39">A</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-InductiveOverload.Sum" data-verso-hover="656">Sum</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Array" data-verso-hover="0">Array</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="39">A</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-13040">where</span>
  <span class="const token" data-binding="const-InductiveOverload.Sum.sum" data-verso-hover="673">sum</span> <span class="var token" data-binding="var-_uniq.16" data-verso-hover="674">l</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.16" data-verso-hover="674">l</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Array.foldl" data-verso-hover="675">foldl</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-13066">fun</span> <span class="var token" data-binding="var-_uniq.30" data-verso-hover="4">acc</span> <span class="var token" data-binding="var-_uniq.33" data-verso-hover="660">a</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.30" data-verso-hover="4">acc</span> <span class="unknown token" data-binding="">+</span> <span class="const token" data-binding="const-InductiveOverload.Sum.sum" data-verso-hover="657">sum</span> <span class="var token" data-binding="var-_uniq.33" data-verso-hover="660">a</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">0</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-13095">example</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-InductiveOverload.Sum.sum" data-verso-hover="657">sum</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">#[</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span><span class="unknown token" data-binding="">3</span><span class="unknown token" data-binding="">,</span><span class="unknown token" data-binding="">4</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">#[</span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">10</span><span class="unknown token" data-binding="">,</span><span class="unknown token" data-binding="">5</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">20</span><span class="unknown token" data-binding="">,</span><span class="unknown token" data-binding="">8</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">#[</span><span class="unknown token" data-binding="">100</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">1000</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span> <span class="unknown token" data-binding="">1251</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-18440389239125725827-13164-13166"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-13164" data-verso-hover="69">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-18440389239125725827-13164-13166"><div class="tactic-state"><div class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-InductiveOverload.Sum.sum" data-verso-hover="657">sum</span> (#[1, 3, 4], [#[(10, 5), (20, 8)], #[100]], 1000)<span class="const token" data-binding="const-Eq" data-verso-hover="71"> = </span>1251</span></span></div></div></span>   
  <span class="tactic"><label for="tactic-state-7-13172-13185"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.nativeDecide-13172" data-verso-hover="676">native_decide</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-13172-13185"><div class="tactic-state">All goals completed! 🐙</div></span>
<span class="unknown token" data-binding=""></span></code></div>
                  </div>
                <ol start="2">
                  <li>
                    <p>
                      Define function that computes the size of product type i.e. <code>prodSize (X₁ × ... × Xₙ) = n</code>.
   Also implement "flat" version which takes into account associativity of product i.e. it counts
   the size of the product irrespective of the product bracketing. Make the following work</p>
                    </li>
                  </ol>
                <pre>example : prodSize (Nat × Nat × Nat) = 3 := by decide
example : prodSize ((Nat × Nat) × Nat) = 2 := by decide
   
example : flatProdSize (Nat x Nat x Nat) = 3 := by decide
example : flatProdSize ((Nat x Nat) x Nat) = 3 := by decide
</pre><div class="collapsible" onclick="this.classList.toggle('expanded');">
                  <div class="collapsible-header">
                    Solution</div>
                  <div class="collapsible-content">
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.classTk-13754">class</span> <span class="const token" data-binding="const-InductiveOverload.ProdSize" data-verso-hover="677">ProdSize</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="39">X</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="">Type</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-null-13780">where</span>
  <span class="const token" data-binding="const-InductiveOverload.ProdSize.prodSize" data-verso-hover="678">prodSize</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span>
  
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.export-13806" data-verso-hover="636">export</span> <span class="unknown token" data-binding="">ProdSize</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-InductiveOverload.ProdSize.prodSize" data-verso-hover="678">prodSize</span><span class="unknown token" data-binding="">)</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-13834">instance</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namedPrio-13843">priority</span><span class="unknown token" data-binding="">:=</span><span class="keyword token" data-binding="kw-occ-prioLow-13854" data-verso-hover="665">low</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="39">X</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-InductiveOverload.ProdSize" data-verso-hover="677">ProdSize</span> <span class="var token" data-binding="var-_uniq.13" data-verso-hover="39">X</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-13876">where</span>
  <span class="const token" data-binding="const-InductiveOverload.ProdSize.prodSize" data-verso-hover="242">prodSize</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">1</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-13899">instance</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namedPrio-13908">priority</span><span class="unknown token" data-binding="">:=</span><span class="keyword token" data-binding="kw-occ-prioLow-13919" data-verso-hover="665">low</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.38" data-verso-hover="39">X</span> <span class="var token" data-binding="var-_uniq.41" data-verso-hover="39">Y</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-InductiveOverload.ProdSize" data-verso-hover="677">ProdSize</span> <span class="var token" data-binding="var-_uniq.41" data-verso-hover="39">Y</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-InductiveOverload.ProdSize" data-verso-hover="677">ProdSize</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.38" data-verso-hover="39">X</span><span class="unknown token" data-binding="">×</span><span class="var token" data-binding="var-_uniq.41" data-verso-hover="39">Y</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-13961">where</span>
  <span class="const token" data-binding="const-InductiveOverload.ProdSize.prodSize" data-verso-hover="242">prodSize</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">+</span> <span class="const token" data-binding="const-InductiveOverload.ProdSize.prodSize" data-verso-hover="678">prodSize</span> <span class="var token" data-binding="var-_uniq.41" data-verso-hover="39">Y</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-13997">example</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-InductiveOverload.ProdSize.prodSize" data-verso-hover="678">prodSize</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span> <span class="unknown token" data-binding="">×</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span> <span class="unknown token" data-binding="">×</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span> <span class="unknown token" data-binding="">3</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-18293269252760092138-14043-14045"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-14043" data-verso-hover="69">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-18293269252760092138-14043-14045"><div class="tactic-state"><div class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-InductiveOverload.ProdSize.prodSize" data-verso-hover="678">prodSize</span> (<span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span><span class="const token" data-binding="const-Prod" data-verso-hover="70"> × </span><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span><span class="const token" data-binding="const-Prod" data-verso-hover="70"> × </span><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span>)<span class="const token" data-binding="const-Eq" data-verso-hover="71"> = </span>3</span></span></div></div></span> <span class="tactic"><label for="tactic-state-7-14046-14052"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-14046" data-verso-hover="72">decide</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-14046-14052"><div class="tactic-state">All goals completed! 🐙</div></span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-14053">example</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-InductiveOverload.ProdSize.prodSize" data-verso-hover="678">prodSize</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span> <span class="unknown token" data-binding="">×</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">×</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span> <span class="unknown token" data-binding="">2</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-4941648555420439363-14101-14103"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-14101" data-verso-hover="69">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-4941648555420439363-14101-14103"><div class="tactic-state"><div class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-InductiveOverload.ProdSize.prodSize" data-verso-hover="678">prodSize</span> ((<span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span><span class="const token" data-binding="const-Prod" data-verso-hover="70"> × </span><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span>)<span class="const token" data-binding="const-Prod" data-verso-hover="70"> × </span><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span>)<span class="const token" data-binding="const-Eq" data-verso-hover="71"> = </span>2</span></span></div></div></span> <span class="tactic"><label for="tactic-state-7-14104-14110"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-14104" data-verso-hover="72">decide</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-14104-14110"><div class="tactic-state">All goals completed! 🐙</div></span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.classTk-14112">class</span> <span class="const token" data-binding="const-InductiveOverload.FlatProdSize" data-verso-hover="679">FlatProdSize</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.276" data-verso-hover="39">X</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="">Type</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-null-14142">where</span>
  <span class="const token" data-binding="const-InductiveOverload.FlatProdSize.flatProdSize" data-verso-hover="680">flatProdSize</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span>
  
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.export-14172" data-verso-hover="636">export</span> <span class="unknown token" data-binding="">FlatProdSize</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-InductiveOverload.FlatProdSize.flatProdSize" data-verso-hover="680">flatProdSize</span><span class="unknown token" data-binding="">)</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-14208">instance</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namedPrio-14217">priority</span><span class="unknown token" data-binding="">:=</span><span class="keyword token" data-binding="kw-occ-prioLow-14228" data-verso-hover="665">low</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.287" data-verso-hover="39">X</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-InductiveOverload.FlatProdSize" data-verso-hover="679">FlatProdSize</span> <span class="var token" data-binding="var-_uniq.287" data-verso-hover="39">X</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-14254">where</span>
  <span class="const token" data-binding="const-InductiveOverload.FlatProdSize.flatProdSize" data-verso-hover="242">flatProdSize</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">1</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-14281">instance</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namedPrio-14290">priority</span><span class="unknown token" data-binding="">:=</span><span class="keyword token" data-binding="kw-occ-prioLow-14301" data-verso-hover="665">low</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.312" data-verso-hover="39">X</span> <span class="var token" data-binding="var-_uniq.315" data-verso-hover="39">Y</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-InductiveOverload.FlatProdSize" data-verso-hover="679">FlatProdSize</span> <span class="var token" data-binding="var-_uniq.312" data-verso-hover="39">X</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-InductiveOverload.FlatProdSize" data-verso-hover="679">FlatProdSize</span> <span class="var token" data-binding="var-_uniq.315" data-verso-hover="39">Y</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">:</span> 
    <span class="const token" data-binding="const-InductiveOverload.FlatProdSize" data-verso-hover="679">FlatProdSize</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.312" data-verso-hover="39">X</span><span class="unknown token" data-binding="">×</span><span class="var token" data-binding="var-_uniq.315" data-verso-hover="39">Y</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-14373">where</span>
  <span class="const token" data-binding="const-InductiveOverload.FlatProdSize.flatProdSize" data-verso-hover="242">flatProdSize</span> <span class="unknown token" data-binding="">:=</span> <span class="const token" data-binding="const-InductiveOverload.FlatProdSize.flatProdSize" data-verso-hover="680">flatProdSize</span> <span class="var token" data-binding="var-_uniq.312" data-verso-hover="39">X</span> <span class="unknown token" data-binding="">+</span> <span class="const token" data-binding="const-InductiveOverload.FlatProdSize.flatProdSize" data-verso-hover="680">flatProdSize</span> <span class="var token" data-binding="var-_uniq.315" data-verso-hover="39">Y</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-14430">example</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-InductiveOverload.FlatProdSize.flatProdSize" data-verso-hover="680">flatProdSize</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span> <span class="unknown token" data-binding="">×</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span> <span class="unknown token" data-binding="">×</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span> <span class="unknown token" data-binding="">3</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-10043910355426567236-14480-14482"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-14480" data-verso-hover="69">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-10043910355426567236-14480-14482"><div class="tactic-state"><div class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-InductiveOverload.FlatProdSize.flatProdSize" data-verso-hover="680">flatProdSize</span> (<span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span><span class="const token" data-binding="const-Prod" data-verso-hover="70"> × </span><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span><span class="const token" data-binding="const-Prod" data-verso-hover="70"> × </span><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span>)<span class="const token" data-binding="const-Eq" data-verso-hover="71"> = </span>3</span></span></div></div></span> <span class="tactic"><label for="tactic-state-7-14483-14489"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-14483" data-verso-hover="72">decide</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-14483-14489"><div class="tactic-state">All goals completed! 🐙</div></span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-14490">example</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-InductiveOverload.FlatProdSize.flatProdSize" data-verso-hover="680">flatProdSize</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span> <span class="unknown token" data-binding="">×</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">×</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span> <span class="unknown token" data-binding="">3</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-293562018718869346-14542-14544"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-14542" data-verso-hover="69">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-293562018718869346-14542-14544"><div class="tactic-state"><div class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-InductiveOverload.FlatProdSize.flatProdSize" data-verso-hover="680">flatProdSize</span> ((<span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span><span class="const token" data-binding="const-Prod" data-verso-hover="70"> × </span><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span>)<span class="const token" data-binding="const-Prod" data-verso-hover="70"> × </span><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span>)<span class="const token" data-binding="const-Eq" data-verso-hover="71"> = </span>3</span></span></div></div></span> <span class="tactic"><label for="tactic-state-7-14545-14551"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-14545" data-verso-hover="72">decide</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-14545-14551"><div class="tactic-state">All goals completed! 🐙</div></span>
<span class="unknown token" data-binding=""></span></code></div>
                  </div>
                <ol start="3">
                  <li>
                    <p>
                      Define function curry that takes a function <code>f : X₁ × ... × Xₙ → Y</code> and produces function <code>g : X₁ → ... → Xₙ → Y</code>.</p>
                    </li>
                  </ol>
                <div class="collapsible" onclick="this.classList.toggle('expanded');">
                  <div class="collapsible-header">
                    Solution</div>
                  <div class="collapsible-content">
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.classTk-14721">class</span> <span class="const token" data-binding="const-InductiveOverload.Curry" data-verso-hover="681">Curry</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="39">Xs</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="39">Y</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="">Type</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="641">F</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-outParam" data-verso-hover="642">outParam</span> <span class="sort token" data-binding="">Type</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-null-14767">where</span>
  <span class="const token" data-binding="const-InductiveOverload.Curry.curry" data-verso-hover="682">curry</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="39">Xs</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="39">Y</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="641">F</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-14801">instance</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namedPrio-14810">priority</span><span class="unknown token" data-binding="">:=</span><span class="keyword token" data-binding="kw-occ-prioLow-14821" data-verso-hover="665">low</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="39">X</span> <span class="var token" data-binding="var-_uniq.29" data-verso-hover="39">Y</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-InductiveOverload.Curry" data-verso-hover="681">Curry</span> <span class="var token" data-binding="var-_uniq.26" data-verso-hover="39">X</span> <span class="var token" data-binding="var-_uniq.29" data-verso-hover="39">Y</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="39">X</span><span class="unknown token" data-binding="">→</span><span class="var token" data-binding="var-_uniq.29" data-verso-hover="39">Y</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-14852">where</span>
  <span class="const token" data-binding="const-InductiveOverload.Curry.curry" data-verso-hover="669">curry</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-14869">fun</span> <span class="var token" data-binding="var-_uniq.47" data-verso-hover="345">f</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.47" data-verso-hover="345">f</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-14881">instance</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-InductiveOverload.Curry" data-verso-hover="681">Curry</span> <span class="var token" data-binding="var-_uniq.74" data-verso-hover="39">Xs</span> <span class="var token" data-binding="var-_uniq.78" data-verso-hover="39">Y</span> <span class="var token" data-binding="var-_uniq.82" data-verso-hover="39">F</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-InductiveOverload.Curry" data-verso-hover="681">Curry</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.90" data-verso-hover="39">X</span><span class="unknown token" data-binding="">×</span><span class="var token" data-binding="var-_uniq.74" data-verso-hover="39">Xs</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.78" data-verso-hover="39">Y</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.90" data-verso-hover="39">X</span><span class="unknown token" data-binding="">→</span><span class="var token" data-binding="var-_uniq.82" data-verso-hover="39">F</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-14931">where</span>
  <span class="const token" data-binding="const-InductiveOverload.Curry.curry" data-verso-hover="683">curry</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-14948">fun</span> <span class="var token" data-binding="var-_uniq.115" data-verso-hover="684">f</span> <span class="var token" data-binding="var-_uniq.119" data-verso-hover="271">x</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-InductiveOverload.Curry.curry" data-verso-hover="682">Curry.curry</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-14972">fun</span> <span class="var token" data-binding="var-_uniq.127" data-verso-hover="672">xs</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.115" data-verso-hover="684">f</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.119" data-verso-hover="271">x</span><span class="unknown token" data-binding="">,</span><span class="var token" data-binding="var-_uniq.127" data-verso-hover="672">xs</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>

<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">10
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-14993">#eval</span></span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-InductiveOverload.Curry.curry" data-verso-hover="682">Curry.curry</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-15012">fun</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.308" data-verso-hover="4">a</span><span class="unknown token" data-binding="">,</span><span class="var token" data-binding="var-_uniq.309" data-verso-hover="4">b</span><span class="unknown token" data-binding="">,</span><span class="var token" data-binding="var-_uniq.310" data-verso-hover="4">c</span><span class="unknown token" data-binding="">,</span><span class="var token" data-binding="var-_uniq.311" data-verso-hover="4">d</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℕ</span><span class="unknown token" data-binding="">×</span><span class="unknown token" data-binding="">ℕ</span><span class="unknown token" data-binding="">×</span><span class="unknown token" data-binding="">ℕ</span><span class="unknown token" data-binding="">×</span><span class="unknown token" data-binding="">ℕ</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.308" data-verso-hover="4">a</span> <span class="unknown token" data-binding="">+</span> <span class="var token" data-binding="var-_uniq.309" data-verso-hover="4">b</span> <span class="unknown token" data-binding="">+</span> <span class="var token" data-binding="var-_uniq.310" data-verso-hover="4">c</span> <span class="unknown token" data-binding="">+</span> <span class="var token" data-binding="var-_uniq.311" data-verso-hover="4">d</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">2</span> <span class="unknown token" data-binding="">3</span> <span class="unknown token" data-binding="">4</span>
<span class="unknown token" data-binding=""></span></code></div>
                  </div>
                <ol start="4">
                  <li>
                    <p>
                      Define function that returns i-th element of product type <code>X₁ × ... × Xₙ</code>. This is somewhat tricky as you have to do induction in <code>i</code> and <code>n</code>.</p>
                    </li>
                  </ol>
                <div class="collapsible" onclick="this.classList.toggle('expanded');">
                  <div class="collapsible-header">
                    Solution</div>
                  <div class="collapsible-content">
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.classTk-15260">class</span> <span class="const token" data-binding="const-InductiveOverload.ProdGet" data-verso-hover="685">ProdGet</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="39">Xs</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="">Type</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="4">n</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="641">Xn</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-outParam" data-verso-hover="642">outParam</span> <span class="sort token" data-binding="">Type</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-null-15317">where</span>
  <span class="const token" data-binding="const-InductiveOverload.ProdGet.get" data-verso-hover="686">get</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="39">Xs</span> <span class="unknown token" data-binding="">-&gt;</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="641">Xn</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-15341">instance</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namedPrio-15350">priority</span><span class="unknown token" data-binding="">:=</span><span class="keyword token" data-binding="kw-occ-prioLow-15361" data-verso-hover="665">low</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-InductiveOverload.ProdGet" data-verso-hover="685">ProdGet</span> <span class="var token" data-binding="var-_uniq.24" data-verso-hover="39">X</span> <span class="unknown token" data-binding="">0</span> <span class="var token" data-binding="var-_uniq.24" data-verso-hover="39">X</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-15382">where</span>
  <span class="const token" data-binding="const-InductiveOverload.ProdGet.get" data-verso-hover="687">get</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-15397">fun</span> <span class="var token" data-binding="var-_uniq.47" data-verso-hover="271">x</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.47" data-verso-hover="271">x</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-15409">instance</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-InductiveOverload.ProdGet" data-verso-hover="685">ProdGet</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.67" data-verso-hover="39">X</span> <span class="unknown token" data-binding="">×</span> <span class="var token" data-binding="var-_uniq.73" data-verso-hover="39">Xs</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">0</span> <span class="var token" data-binding="var-_uniq.67" data-verso-hover="39">X</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-15442">where</span>
  <span class="const token" data-binding="const-InductiveOverload.ProdGet.get" data-verso-hover="688">get</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-15457">fun</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.124" data-verso-hover="271">x</span><span class="unknown token" data-binding="">,</span><span class="var token" data-binding="var-_uniq.125" data-verso-hover="672">xs</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.124" data-verso-hover="271">x</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-15474">instance</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-InductiveOverload.ProdGet" data-verso-hover="685">ProdGet</span> <span class="var token" data-binding="var-_uniq.205" data-verso-hover="39">Xs</span> <span class="var token" data-binding="var-_uniq.209" data-verso-hover="4">n</span> <span class="var token" data-binding="var-_uniq.213" data-verso-hover="39">Xn</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-InductiveOverload.ProdGet" data-verso-hover="685">ProdGet</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.221" data-verso-hover="39">X</span> <span class="unknown token" data-binding="">×</span> <span class="var token" data-binding="var-_uniq.205" data-verso-hover="39">Xs</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.209" data-verso-hover="4">n</span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.213" data-verso-hover="39">Xn</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-15530">where</span>
  <span class="const token" data-binding="const-InductiveOverload.ProdGet.get" data-verso-hover="689">get</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-15545">fun</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.340" data-verso-hover="271">x</span><span class="unknown token" data-binding="">,</span><span class="var token" data-binding="var-_uniq.341" data-verso-hover="672">xs</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-InductiveOverload.ProdGet.get" data-verso-hover="686">ProdGet.get</span> <span class="var token" data-binding="var-_uniq.303" data-verso-hover="4">n</span> <span class="var token" data-binding="var-_uniq.341" data-verso-hover="672">xs</span>

<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">1
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-15577">#eval</span></span> <span class="const token" data-binding="const-InductiveOverload.ProdGet.get" data-verso-hover="686">ProdGet.get</span> <span class="unknown token" data-binding="">0</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span><span class="literal string token" data-binding="" data-verso-hover="29">"hello"</span><span class="unknown token" data-binding="">,</span><span class="unknown token" data-binding="">3.1415</span><span class="unknown token" data-binding="">)</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">"hello"
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-15616">#eval</span></span> <span class="const token" data-binding="const-InductiveOverload.ProdGet.get" data-verso-hover="686">ProdGet.get</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span><span class="literal string token" data-binding="" data-verso-hover="29">"hello"</span><span class="unknown token" data-binding="">,</span><span class="unknown token" data-binding="">3.1415</span><span class="unknown token" data-binding="">)</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">3.141500
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-15655">#eval</span></span> <span class="const token" data-binding="const-InductiveOverload.ProdGet.get" data-verso-hover="686">ProdGet.get</span> <span class="unknown token" data-binding="">2</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span><span class="literal string token" data-binding="" data-verso-hover="29">"hello"</span><span class="unknown token" data-binding="">,</span><span class="unknown token" data-binding="">3.1415</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code></div>
                  </div>
                <ol start="5">
                  <li>
                    <p>
                      Again define function that returns <code>i-th</code> element of product type but now ignores associativity of the product i.e. <code>get 0 ((0,1),(2,3)) = 0</code> because previously we got <code>get 0 ((0,1),(2,3)) = (0,1)</code>.</p>
                    </li>
                  <li>
                    <p>
                      Define complete interface for product types that allows you to get, set and modify elements of arbitrary product type.</p>
                    </li>
                  </ol>
                </section>
              <section>
                <h4 id="Scientific-Computing-in-Lean--Miscellaneous--Typeclasses-as-Interfaces-and-Function-Overloading--Function-overloading--Defining-Functions-Inductively-on-the-Type--Polymorphism-Over-Types-and-Terms">
                  Polymorphism Over Types and Terms</h4>
                <p>
                  In the earlier sections, we defined a polymorphic function <code>size</code> that operates on collections like <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List" data-verso-hover="20">List</span></code> or <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Array" data-verso-hover="0">Array</span></code>. However, what if we want to extend this functionality to types themselves? For instance, we might want <code>size Bool = 2</code>, <code>size Unit = 1</code>, and <code>size Empty = 0</code>. The initial approach we used would require adding instances for <code>Size Type</code>, which is problematic because we cannot directly provide a <code>size</code> for any arbitrary type.</p>
                <p>
                  To solve this, we need to redefine the typeclass <code>Size</code> so that it can handle both types and values. The key idea is to make the argument of the <code>size</code> function part of the typeclass itself rather than a parameter of the function:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.classTk-16872">class</span> <span class="const token" data-binding="const-OverloadTypeAndTerm.Size" data-verso-hover="690">Size</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="691">A</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-16888" data-verso-hover="618">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="660">a</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="691">A</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-null-16904">where</span>
  <span class="const token" data-binding="const-OverloadTypeAndTerm.Size.size" data-verso-hover="692">size</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-16924">instance</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.16" data-verso-hover="134">A</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.19" data-verso-hover="629">l</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-List" data-verso-hover="20">List</span> <span class="var token" data-binding="var-_uniq.16" data-verso-hover="134">A</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-OverloadTypeAndTerm.Size" data-verso-hover="690">Size</span> <span class="var token" data-binding="var-_uniq.19" data-verso-hover="629">l</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-16959">where</span>
  <span class="const token" data-binding="const-OverloadTypeAndTerm.Size.size" data-verso-hover="242">size</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.19" data-verso-hover="629">l</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-List.length" data-verso-hover="550">length</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-16985">instance</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.51" data-verso-hover="134">A</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.54" data-verso-hover="674">a</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Array" data-verso-hover="0">Array</span> <span class="var token" data-binding="var-_uniq.51" data-verso-hover="134">A</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-OverloadTypeAndTerm.Size" data-verso-hover="690">Size</span> <span class="var token" data-binding="var-_uniq.54" data-verso-hover="674">a</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-17021">where</span>
  <span class="const token" data-binding="const-OverloadTypeAndTerm.Size.size" data-verso-hover="242">size</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.54" data-verso-hover="674">a</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Array.size" data-verso-hover="693">size</span>
<span class="unknown token" data-binding=""></span></code><p>
                  In this refined definition, <code>Size</code> is parameterized by a value <code>a</code> of type <code>A</code>, which allows us to define instances for specific types. For example:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-17207">instance</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-OverloadTypeAndTerm.Size" data-verso-hover="690">Size</span> <span class="const token" data-binding="const-Bool" data-verso-hover="594">Bool</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-17228">where</span>
  <span class="const token" data-binding="const-OverloadTypeAndTerm.Size.size" data-verso-hover="242">size</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">2</span>
<span class="unknown token" data-binding=""></span></code><p>
                  Notice that we use <code>A : Type u</code> instead of just <code>A : Type</code>. The reason for this is that Lean uses a concept called <strong>universe polymorphism</strong>. If we simply wrote <code>A : Type</code>, it would restrict <code>A</code> to the lowest universe level, <code>Type 0</code>, which contains types like <code>Nat</code> or <code>Bool</code>. However, for the above instance <code>Size Bool</code> we need <code>A = Type</code> thus <code>A : Type 1</code>. Lean's type theory is stratified into multiple <strong>universes</strong> to avoid paradoxes like Russell's paradox.</p>
                <p>
                  To see this in action, you can run the following command:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Type : Type 1</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-17800">#check</span></span> <span class="sort token" data-binding="">Type</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
                  <pre>Type : Type 1
</pre></div>
                <p>
                  This tells us that <code>Type</code> itself lives in <code>Type 1</code>, meaning that <code>Type 0 : Type 1</code>. More generally, <code>Type u</code> refers to a type in any universe level <code>u</code>, where <code>Type u : Type (u+1)</code>. By using <code>A : Type u</code>, we allow <code>A</code> to belong to <strong>any universe level</strong>, making <code>Size</code> more flexible and applicable to a wider range of types, including types themselves like <code>Bool</code>, <code>Unit</code>, and <code>Empty</code>.</p>
                <p>
                  We achieved a more general <code>size</code> function that works polymorphically not only over collections but also over types themselves.</p>
                </section>
              <section>
                <h4 id="Scientific-Computing-in-Lean--Miscellaneous--Typeclasses-as-Interfaces-and-Function-Overloading--Function-overloading--Defining-Functions-Inductively-on-the-Type--Exercises">
                  Exercises</h4>
                <ol start="1">
                  <li>
                    <p>
                      Define a function <code>first?</code> that returns the first element of a value <code>x</code> wrapped in an <code>Option</code>. If <code>x</code> is empty, the function should return <code>none</code>. We want the following results:</p>
                    </li>
                  </ol>
                <pre>example : first? [1, 2, 3] = .some 1 := by decide
example : first? Bool = .some false := by decide
example : first? ([] : List ℕ) = none := by decide
example : first? Empty = none := by decide
</pre><div class="collapsible" onclick="this.classList.toggle('expanded');">
                  <div class="collapsible-header">
                    Solution</div>
                  <div class="collapsible-content">
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.classTk-18799">class</span> <span class="const token" data-binding="const-OverloadTypeAndTerm.First" data-verso-hover="694">First</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="691">A</span> <span class="unknown token" data-binding="">:</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-18816" data-verso-hover="618">Type</span> <span class="unknown token" data-binding="">u</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="660">a</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="691">A</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="695">B</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-outParam" data-verso-hover="642">outParam</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-18847" data-verso-hover="618">Type</span> <span class="unknown token" data-binding="">v</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-null-18856">where</span>
  <span class="const token" data-binding="const-OverloadTypeAndTerm.First.first?" data-verso-hover="696">first?</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Option" data-verso-hover="697">Option</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="695">B</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.export-18883" data-verso-hover="636">export</span> <span class="unknown token" data-binding="">First</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-OverloadTypeAndTerm.First.first?" data-verso-hover="696">first?</span><span class="unknown token" data-binding="">)</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-18906">instance</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="629">l</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-List" data-verso-hover="20">List</span> <span class="var token" data-binding="var-_uniq.23" data-verso-hover="134">A</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-OverloadTypeAndTerm.First" data-verso-hover="694">First</span> <span class="var token" data-binding="var-_uniq.26" data-verso-hover="629">l</span> <span class="var token" data-binding="var-_uniq.23" data-verso-hover="134">A</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-18940">where</span>
  <span class="const token" data-binding="const-OverloadTypeAndTerm.First.first?" data-verso-hover="698">first?</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.26" data-verso-hover="629">l</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-List.head?" data-verso-hover="699">head?</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-18967">instance</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-OverloadTypeAndTerm.First" data-verso-hover="694">First</span> <span class="const token" data-binding="const-Bool" data-verso-hover="594">Bool</span> <span class="const token" data-binding="const-Bool" data-verso-hover="594">Bool</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-18994">where</span>
  <span class="const token" data-binding="const-OverloadTypeAndTerm.First.first?" data-verso-hover="700">first?</span> <span class="unknown token" data-binding="">:=</span> <span class="const token" data-binding="const-Option.some" data-verso-hover="701">.some</span> <span class="const token" data-binding="const-Bool.false" data-verso-hover="702">false</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-19025">instance</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-OverloadTypeAndTerm.First" data-verso-hover="694">First</span> <span class="const token" data-binding="const-Empty" data-verso-hover="703">Empty</span> <span class="const token" data-binding="const-Empty" data-verso-hover="703">Empty</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-19054">where</span>
  <span class="const token" data-binding="const-OverloadTypeAndTerm.First.first?" data-verso-hover="704">first?</span> <span class="unknown token" data-binding="">:=</span> <span class="const token" data-binding="const-Option.none" data-verso-hover="705">.none</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-19079">instance</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-OverloadTypeAndTerm.First" data-verso-hover="694">First</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Fin" data-verso-hover="54">Fin</span> <span class="var token" data-binding="var-_uniq.113" data-verso-hover="4">n</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Fin" data-verso-hover="54">Fin</span> <span class="var token" data-binding="var-_uniq.113" data-verso-hover="4">n</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-19112">where</span>
  <span class="const token" data-binding="const-OverloadTypeAndTerm.First.first?" data-verso-hover="706">first?</span> <span class="unknown token" data-binding="">:=</span>
    <span class="keyword token" data-binding="kw-occ-termDepIfThenElse-19134" data-verso-hover="535">if</span> <span class="var token" data-binding="var-_uniq.164" data-verso-hover="707">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.119" data-verso-hover="4">n</span> <span class="unknown token" data-binding="">≠</span> <span class="unknown token" data-binding="">0</span> <span class="keyword token" data-binding="kw-occ-termDepIfThenElse-19134" data-verso-hover="535">then</span>
      <span class="const token" data-binding="const-Option.some" data-verso-hover="701">.some</span> <span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">0</span><span class="unknown token" data-binding="">,</span> <span class="tactic"><label for="tactic-state-1232174279389253076-19172-19174"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-19172" data-verso-hover="69">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-1232174279389253076-19172-19174"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.119" data-verso-hover="4">n</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.164" data-verso-hover="707">h</span></td><td class="colon">:</td><td class="type"><span class="var token" data-binding="var-_uniq.119" data-verso-hover="4">n</span><span class="const token" data-binding="const-Ne" data-verso-hover="251"> ≠ </span>0</td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type">0<span class="const token" data-binding="const-LT.lt" data-verso-hover="150"> &lt; </span><span class="var token" data-binding="var-_uniq.119" data-verso-hover="4">n</span></span></span></div></div></span> <span class="tactic"><label for="tactic-state-7-19175-19180"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-19175" data-verso-hover="151">omega</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-19175-19180"><div class="tactic-state">All goals completed! 🐙</div></span><span class="unknown token" data-binding="">⟩</span>
    <span class="keyword token" data-binding="kw-occ-termDepIfThenElse-19134" data-verso-hover="535">else</span>
      <span class="const token" data-binding="const-Option.none" data-verso-hover="705">.none</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-19206">example</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-OverloadTypeAndTerm.First.first?" data-verso-hover="696">first?</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">3</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">=</span> <span class="const token" data-binding="const-Option.some" data-verso-hover="701">.some</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-15617833075444188458-19246-19248"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-19246" data-verso-hover="69">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-15617833075444188458-19246-19248"><div class="tactic-state"><div class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-OverloadTypeAndTerm.First.first?" data-verso-hover="696">first?</span> [1, 2, 3]<span class="const token" data-binding="const-Eq" data-verso-hover="71"> = </span><span class="const token" data-binding="const-Option.some" data-verso-hover="701">some</span> 1</span></span></div></div></span> <span class="tactic"><label for="tactic-state-7-19249-19255"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-19249" data-verso-hover="72">decide</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-19249-19255"><div class="tactic-state">All goals completed! 🐙</div></span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-19256">example</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-OverloadTypeAndTerm.First.first?" data-verso-hover="696">first?</span> <span class="const token" data-binding="const-Bool" data-verso-hover="594">Bool</span> <span class="unknown token" data-binding="">=</span> <span class="const token" data-binding="const-Option.some" data-verso-hover="701">.some</span> <span class="const token" data-binding="const-Bool.false" data-verso-hover="702">false</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-10859335389152743483-19295-19297"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-19295" data-verso-hover="69">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-10859335389152743483-19295-19297"><div class="tactic-state"><div class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-OverloadTypeAndTerm.First.first?" data-verso-hover="696">first?</span> <span class="const token" data-binding="const-Bool" data-verso-hover="594">Bool</span><span class="const token" data-binding="const-Eq" data-verso-hover="71"> = </span><span class="const token" data-binding="const-Option.some" data-verso-hover="701">some</span> <span class="const token" data-binding="const-Bool.false" data-verso-hover="702">false</span></span></span></div></div></span> <span class="tactic"><label for="tactic-state-7-19298-19304"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-19298" data-verso-hover="72">decide</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-19298-19304"><div class="tactic-state">All goals completed! 🐙</div></span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-19305">example</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-OverloadTypeAndTerm.First.first?" data-verso-hover="696">first?</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-List" data-verso-hover="20">List</span> <span class="unknown token" data-binding="">ℕ</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span> <span class="const token" data-binding="const-Option.none" data-verso-hover="705">none</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-12691227087949587404-19348-19350"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-19348" data-verso-hover="69">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12691227087949587404-19348-19350"><div class="tactic-state"><div class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-OverloadTypeAndTerm.First.first?" data-verso-hover="696">first?</span> []<span class="const token" data-binding="const-Eq" data-verso-hover="71"> = </span>none</span></span></div></div></span> <span class="tactic"><label for="tactic-state-7-19351-19357"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-19351" data-verso-hover="72">decide</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-19351-19357"><div class="tactic-state">All goals completed! 🐙</div></span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-19358">example</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-OverloadTypeAndTerm.First.first?" data-verso-hover="696">first?</span> <span class="const token" data-binding="const-Empty" data-verso-hover="703">Empty</span> <span class="unknown token" data-binding="">=</span> <span class="const token" data-binding="const-Option.none" data-verso-hover="705">none</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-16663212619733665660-19391-19393"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-19391" data-verso-hover="69">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-16663212619733665660-19391-19393"><div class="tactic-state"><div class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-OverloadTypeAndTerm.First.first?" data-verso-hover="696">first?</span> <span class="const token" data-binding="const-Empty" data-verso-hover="703">Empty</span><span class="const token" data-binding="const-Eq" data-verso-hover="71"> = </span>none</span></span></div></div></span> <span class="tactic"><label for="tactic-state-7-19394-19400"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-19394" data-verso-hover="72">decide</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-19394-19400"><div class="tactic-state">All goals completed! 🐙</div></span>
<span class="unknown token" data-binding=""></span></code></div>
                  </div>
                <ol start="2">
                  <li>
                    <p>
                      General pair function. Define function <code>pair</code> that for two types <code>X</code> and <code>Y</code> returns <code>X × Y</code> but for two elements <code>(x : X)</code> and <code>(y : Y)</code> returns <code>(x,y)</code>.</p>
                    </li>
                  </ol>
                <pre>example {X Y : Type} : pair X Y = X × Y := by rfl
example {X Y : Type} (x : X) (y : Y) : pair x y = (x,y) := by rfl
</pre><div class="collapsible" onclick="this.classList.toggle('expanded');">
                  <div class="collapsible-header">
                    Solution</div>
                  <div class="collapsible-content">
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.classTk-19719">class</span> <span class="const token" data-binding="const-OverloadTypeAndTerm.Pair" data-verso-hover="708">Pair</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="134">X</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="135">Y</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="">Type*</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="271">x</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="134">X</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="359">y</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="135">Y</span><span class="unknown token" data-binding="">)</span> 
           <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="709">XY</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-outParam" data-verso-hover="642">outParam</span> <span class="sort token" data-binding="">Type*</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-null-19794">where</span>
  <span class="const token" data-binding="const-OverloadTypeAndTerm.Pair.pair" data-verso-hover="710">pair</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="709">XY</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.export-19813" data-verso-hover="636">export</span> <span class="unknown token" data-binding="">Pair</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-OverloadTypeAndTerm.Pair.pair" data-verso-hover="710">pair</span><span class="unknown token" data-binding="">)</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-19833">instance</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.29" data-verso-hover="134">X</span> <span class="var token" data-binding="var-_uniq.32" data-verso-hover="135">Y</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="">Type*</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-OverloadTypeAndTerm.Pair" data-verso-hover="708">Pair</span> <span class="var token" data-binding="var-_uniq.29" data-verso-hover="134">X</span> <span class="var token" data-binding="var-_uniq.32" data-verso-hover="135">Y</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.type-19868" data-verso-hover="618">Type</span> <span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-19876">where</span>
  <span class="const token" data-binding="const-OverloadTypeAndTerm.Pair.pair" data-verso-hover="711">pair</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.29" data-verso-hover="134">X</span> <span class="unknown token" data-binding="">×</span> <span class="var token" data-binding="var-_uniq.32" data-verso-hover="135">Y</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-19900">instance</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.83" data-verso-hover="134">X</span> <span class="var token" data-binding="var-_uniq.86" data-verso-hover="135">Y</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="">Type*</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.88" data-verso-hover="271">x</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.83" data-verso-hover="134">X</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.90" data-verso-hover="359">y</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.86" data-verso-hover="135">Y</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-OverloadTypeAndTerm.Pair" data-verso-hover="708">Pair</span> <span class="var token" data-binding="var-_uniq.88" data-verso-hover="271">x</span> <span class="var token" data-binding="var-_uniq.90" data-verso-hover="359">y</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.83" data-verso-hover="134">X</span><span class="unknown token" data-binding="">×</span><span class="var token" data-binding="var-_uniq.86" data-verso-hover="135">Y</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-19957">where</span>
  <span class="const token" data-binding="const-OverloadTypeAndTerm.Pair.pair" data-verso-hover="712">pair</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.88" data-verso-hover="271">x</span><span class="unknown token" data-binding="">,</span><span class="var token" data-binding="var-_uniq.90" data-verso-hover="359">y</span><span class="unknown token" data-binding="">)</span>


<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-19981">example</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.157" data-verso-hover="39">X</span> <span class="var token" data-binding="var-_uniq.159" data-verso-hover="39">Y</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="">Type</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-OverloadTypeAndTerm.Pair.pair" data-verso-hover="710">pair</span> <span class="var token" data-binding="var-_uniq.157" data-verso-hover="39">X</span> <span class="var token" data-binding="var-_uniq.159" data-verso-hover="39">Y</span> <span class="unknown token" data-binding="">=</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.157" data-verso-hover="39">X</span> <span class="unknown token" data-binding="">×</span> <span class="var token" data-binding="var-_uniq.159" data-verso-hover="39">Y</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-17508512895128669759-20027-20029"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-20027" data-verso-hover="69">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-17508512895128669759-20027-20029"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.157" data-verso-hover="39">X</span></td><td class="colon">:</td><td class="type"><span class="sort token" data-binding="">Type</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.159" data-verso-hover="39">Y</span></td><td class="colon">:</td><td class="type"><span class="sort token" data-binding="">Type</span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-OverloadTypeAndTerm.Pair.pair" data-verso-hover="710">pair</span> <span class="var token" data-binding="var-_uniq.157" data-verso-hover="39">X</span> <span class="var token" data-binding="var-_uniq.159" data-verso-hover="39">Y</span><span class="const token" data-binding="const-Eq" data-verso-hover="71"> = </span>(<span class="var token" data-binding="var-_uniq.157" data-verso-hover="39">X</span><span class="const token" data-binding="const-Prod" data-verso-hover="70"> × </span><span class="var token" data-binding="var-_uniq.159" data-verso-hover="39">Y</span>)</span></span></div></div></span> <span class="tactic"><label for="tactic-state-7-20030-20033"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRfl-20030" data-verso-hover="276">rfl</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-20030-20033"><div class="tactic-state">All goals completed! 🐙</div></span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-20034">example</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.205" data-verso-hover="39">X</span> <span class="var token" data-binding="var-_uniq.207" data-verso-hover="39">Y</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="">Type</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.209" data-verso-hover="271">x</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.205" data-verso-hover="39">X</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.211" data-verso-hover="359">y</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.207" data-verso-hover="39">Y</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-OverloadTypeAndTerm.Pair.pair" data-verso-hover="710">pair</span> <span class="var token" data-binding="var-_uniq.209" data-verso-hover="271">x</span> <span class="var token" data-binding="var-_uniq.211" data-verso-hover="359">y</span> <span class="unknown token" data-binding="">=</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.209" data-verso-hover="271">x</span><span class="unknown token" data-binding="">,</span><span class="var token" data-binding="var-_uniq.211" data-verso-hover="359">y</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-4441773318489449222-20093-20095"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-20093" data-verso-hover="69">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-4441773318489449222-20093-20095"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.205" data-verso-hover="39">X</span></td><td class="colon">:</td><td class="type"><span class="sort token" data-binding="">Type</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.207" data-verso-hover="39">Y</span></td><td class="colon">:</td><td class="type"><span class="sort token" data-binding="">Type</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.209" data-verso-hover="271">x</span></td><td class="colon">:</td><td class="type"><span class="var token" data-binding="var-_uniq.205" data-verso-hover="39">X</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.211" data-verso-hover="359">y</span></td><td class="colon">:</td><td class="type"><span class="var token" data-binding="var-_uniq.207" data-verso-hover="39">Y</span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-OverloadTypeAndTerm.Pair.pair" data-verso-hover="710">pair</span> <span class="var token" data-binding="var-_uniq.209" data-verso-hover="271">x</span> <span class="var token" data-binding="var-_uniq.211" data-verso-hover="359">y</span><span class="const token" data-binding="const-Eq" data-verso-hover="71"> = </span>(<span class="var token" data-binding="var-_uniq.209" data-verso-hover="271">x</span>, <span class="var token" data-binding="var-_uniq.211" data-verso-hover="359">y</span>)</span></span></div></div></span> <span class="tactic"><label for="tactic-state-7-20096-20099"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRfl-20096" data-verso-hover="276">rfl</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-20096-20099"><div class="tactic-state">All goals completed! 🐙</div></span>


-- Alternative definition together with notation which requires some knowledge 
-- of metaprogramming.
-- Have a look at this Zulip thread for motivation 
-- https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/.E2.8A.97.20notation.20for.20types.20and.20elements/near/321358639
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.classTk-20394">class</span> <span class="const token" data-binding="const-OverloadTypeAndTerm.Pair'" data-verso-hover="713">Pair'</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.264" data-verso-hover="134">X</span> <span class="var token" data-binding="var-_uniq.267" data-verso-hover="135">Y</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="">Type*</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.269" data-verso-hover="271">x</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.264" data-verso-hover="134">X</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.271" data-verso-hover="359">y</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.267" data-verso-hover="135">Y</span><span class="unknown token" data-binding="">)</span> 
            <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.275" data-verso-hover="709">XY</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-outParam" data-verso-hover="642">outParam</span> <span class="sort token" data-binding="">Type*</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.278" data-verso-hover="714">xy</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-outParam" data-verso-hover="642">outParam</span> <span class="var token" data-binding="var-_uniq.275" data-verso-hover="709">XY</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-null-20490">where</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-20497" data-verso-hover="13">open</span> <span class="unknown token" data-binding="">Lean</span> <span class="unknown token" data-binding="">Elab</span> <span class="unknown token" data-binding="">Term</span> <span class="unknown token" data-binding="">Meta</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.in-20497">in</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.scoped-20525">scoped</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.elab-20525">elab</span> <span class="var token" data-binding="var-_uniq.381" data-verso-hover="715">x</span><span class="unknown token" data-binding="">:</span><span class="const token" data-binding="const-Lean.Parser.Category.term" data-verso-hover="716">term</span> <span class="literal string token" data-binding="" data-verso-hover="717">"⊗"</span> <span class="var token" data-binding="var-_uniq.371" data-verso-hover="715">y</span><span class="unknown token" data-binding="">:</span><span class="const token" data-binding="const-Lean.Parser.Category.term" data-verso-hover="716">term</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Parser.Category.term" data-verso-hover="716">term</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-Lean.MonadQuotation.withFreshMacroScope" data-verso-hover="718">withFreshMacroScope</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-20587">do</span>
  <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Meta.synthInstance" data-verso-hover="719">synthInstance</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Elab.Term.elabType" data-verso-hover="720">elabType</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span> <span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">Pair'</span> <span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.381" data-verso-hover="715">x</span> <span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.371" data-verso-hover="715">y</span> <span class="unknown token" data-binding="">?</span><span class="unknown token" data-binding="">m</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.TSyntax.raw" data-verso-hover="721">raw</span><span class="unknown token" data-binding="">)</span>
  <span class="const token" data-binding="const-Lean.Elab.Term.elabTerm" data-verso-hover="722">elabTerm</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span> <span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">?</span><span class="unknown token" data-binding="">m</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.TSyntax.raw" data-verso-hover="721">raw</span> <span class="const token" data-binding="const-Option.none" data-verso-hover="705">none</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-20688">instance</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.1583" data-verso-hover="134">X</span> <span class="var token" data-binding="var-_uniq.1586" data-verso-hover="135">Y</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="">Type*</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-OverloadTypeAndTerm.Pair'" data-verso-hover="713">Pair'</span> <span class="var token" data-binding="var-_uniq.1583" data-verso-hover="134">X</span> <span class="var token" data-binding="var-_uniq.1586" data-verso-hover="135">Y</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1583" data-verso-hover="134">X</span><span class="unknown token" data-binding="">×</span><span class="var token" data-binding="var-_uniq.1586" data-verso-hover="135">Y</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">⟩</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-20740">instance</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.1650" data-verso-hover="134">X</span> <span class="var token" data-binding="var-_uniq.1653" data-verso-hover="135">Y</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="">Type*</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1655" data-verso-hover="271">x</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.1650" data-verso-hover="134">X</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1657" data-verso-hover="359">y</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.1653" data-verso-hover="135">Y</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-OverloadTypeAndTerm.Pair'" data-verso-hover="713">Pair'</span> <span class="var token" data-binding="var-_uniq.1655" data-verso-hover="271">x</span> <span class="var token" data-binding="var-_uniq.1657" data-verso-hover="359">y</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1655" data-verso-hover="271">x</span><span class="unknown token" data-binding="">,</span><span class="var token" data-binding="var-_uniq.1657" data-verso-hover="359">y</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">⟩</span>

-- Notice that the result it the familiar `X × Y` and `(x,y)` i.e. the notation
-- `⊗` unifies product notation for types and elements.
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">ℕ × ℕ : Type</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-20947">#check</span></span> <span class="unknown token" data-binding="">ℕ</span> <span class="unknown token" data-binding="">⊗</span> <span class="unknown token" data-binding="">ℕ</span>     -- ℕ × ℕ
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">(0, 1) : ℕ × ℕ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-20984">#check</span></span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">0</span><span class="unknown token" data-binding="">:</span><span class="unknown token" data-binding="">ℕ</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">⊗</span> <span class="unknown token" data-binding="">1</span>  -- (0,1)
<span class="unknown token" data-binding=""></span></code></div>
                  </div>
                </section>
              </section>
            </section>
          <section>
            <h2 id="Scientific-Computing-in-Lean--Miscellaneous--Typeclasses-as-Interfaces-and-Function-Overloading--Typeclasses-as-Interfaces">
              Typeclasses as Interfaces</h2>
            <p>
              After exploring function overloading, we can now turn to another powerful application of typeclasses in Lean: defining <strong>interfaces</strong> for types. While function overloading allows different functions to be chosen based on the types of arguments, typeclasses can also be used to define a set of required behaviors for a type.</p>
            <p>
              In this sense, typeclasses in Lean are similar to <strong>interfaces</strong> in object-oriented programming (OOP) languages, where a typeclass defines a set of operations or properties that a type must implement. Unlike traditional OOP, where interfaces are often rigid and tied to specific types, Lean’s typeclass system is more flexible, allowing types to implement typeclasses after they are defined and providing a more modular way to express behaviors.</p>
            <section>
              <h3 id="Scientific-Computing-in-Lean--Miscellaneous--Typeclasses-as-Interfaces-and-Function-Overloading--Typeclasses-as-Interfaces--Defining-an-Array-like-Interface">
                Defining an Array-like Interface</h3>
              <p>
                For example, let's define a typeclass that expresses that a type <code>Arr</code> behaves like an array, providing operations to access an element by index and get the length of the array. This is how we might define such a typeclass in Lean:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.classTk-22209">class</span> <span class="const token" data-binding="const-TCInterfaces.ArrayLike" data-verso-hover="723">ArrayLike</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="39">Arr</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="">Type</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="641">Elem</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-outParam" data-verso-hover="642">outParam</span> <span class="sort token" data-binding="">Type</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-null-22261">where</span>
  <span class="const token" data-binding="const-TCInterfaces.ArrayLike.get" data-verso-hover="724">get</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="39">Arr</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Option" data-verso-hover="697">Option</span> <span class="var token" data-binding="var-_uniq.5" data-verso-hover="641">Elem</span>
  <span class="const token" data-binding="const-TCInterfaces.ArrayLike.length" data-verso-hover="725">length</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="39">Arr</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span>
<span class="unknown token" data-binding=""></span></code><p>
                This defines an interface for any type <code>Arr</code> that behaves like an array. For a type to implement this interface, it must provide definitions for both <code>get</code> and <code>length</code>. The <strong><strong><code>get</code></strong></strong> function retrieves an element by index, returning <code>Option Elem</code> to handle out-of-bounds access. The <strong><strong><code>length</code></strong></strong> function simply returns the length of the array.</p>
              <section>
                <h4 id="Scientific-Computing-in-Lean--Miscellaneous--Typeclasses-as-Interfaces-and-Function-Overloading--Typeclasses-as-Interfaces--Defining-an-Array-like-Interface--Implementing-the-Interface">
                  Implementing the Interface</h4>
                <p>
                  Next, let's implement this interface for specific types, such as <code>List A</code>. Lists in Lean already have a concept of length and indexed access, so this is a natural fit for our <code>ArrayLike</code> interface:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-22917">instance</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="39">A</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-TCInterfaces.ArrayLike" data-verso-hover="723">ArrayLike</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-List" data-verso-hover="20">List</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="39">A</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="39">A</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-22953">where</span>
  <span class="const token" data-binding="const-TCInterfaces.ArrayLike.get" data-verso-hover="726">get</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="629">l</span> <span class="var token" data-binding="var-_uniq.17" data-verso-hover="4">n</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-termDepIfThenElse-22972" data-verso-hover="535">if</span> <span class="var token" data-binding="var-_uniq.52" data-verso-hover="727">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.17" data-verso-hover="4">n</span> <span class="unknown token" data-binding="">&lt;</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="629">l</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-List.length" data-verso-hover="550">length</span> <span class="keyword token" data-binding="kw-occ-termDepIfThenElse-22972" data-verso-hover="535">then</span> <span class="const token" data-binding="const-Option.some" data-verso-hover="701">some</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="629">l</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-List.get" data-verso-hover="555">get</span> <span class="unknown token" data-binding="">⟨</span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="4">n</span><span class="unknown token" data-binding="">,</span><span class="var token" data-binding="var-_uniq.52" data-verso-hover="727">h</span><span class="unknown token" data-binding="">⟩</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-termDepIfThenElse-22972" data-verso-hover="535">else</span> <span class="const token" data-binding="const-Option.none" data-verso-hover="705">none</span>
  <span class="const token" data-binding="const-TCInterfaces.ArrayLike.length" data-verso-hover="628">length</span> <span class="var token" data-binding="var-_uniq.82" data-verso-hover="629">l</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.82" data-verso-hover="629">l</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-List.length" data-verso-hover="550">length</span>
<span class="unknown token" data-binding=""></span></code><p>
                  Here, we define an instance of <code>ArrayLike</code> for <code>List A</code>. The <strong><strong><code>get</code></strong></strong> function checks if the index is within bounds and retrieves the element if possible, returning <code>none</code> if the index is out of range. The <strong><strong><code>length</code></strong></strong> function simply calls the built-in <code>length</code> method of the list.</p>
                </section>
              <section>
                <h4 id="Scientific-Computing-in-Lean--Miscellaneous--Typeclasses-as-Interfaces-and-Function-Overloading--Typeclasses-as-Interfaces--Defining-an-Array-like-Interface--Extending-the-Interface-to-Other-Types">
                  Extending the Interface to Other Types</h4>
                <p>
                  We can extend the <code>ArrayLike</code> interface to other types, such as arrays:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.instance-23468">instance</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="39">A</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-TCInterfaces.ArrayLike" data-verso-hover="723">ArrayLike</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Array" data-verso-hover="0">Array</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="39">A</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.3" data-verso-hover="39">A</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.whereStructInst-23505">where</span>
  <span class="const token" data-binding="const-TCInterfaces.ArrayLike.get" data-verso-hover="728">get</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="674">a</span> <span class="var token" data-binding="var-_uniq.17" data-verso-hover="4">n</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="674">a</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Array.get?" data-verso-hover="729">get?</span> <span class="var token" data-binding="var-_uniq.17" data-verso-hover="4">n</span>
  <span class="const token" data-binding="const-TCInterfaces.ArrayLike.length" data-verso-hover="673">length</span> <span class="var token" data-binding="var-_uniq.31" data-verso-hover="674">a</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.31" data-verso-hover="674">a</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Array.size" data-verso-hover="693">size</span>
<span class="unknown token" data-binding=""></span></code><p>
                  In this instance, we use the built-in <code>get?</code> method of <code>Array</code> for safe element access, which already returns an <code>Option A</code>. The <code>length</code> method is implemented using the <code>size</code> function of arrays.</p>
                </section>
              <section>
                <h4 id="Scientific-Computing-in-Lean--Miscellaneous--Typeclasses-as-Interfaces-and-Function-Overloading--Typeclasses-as-Interfaces--Defining-an-Array-like-Interface--Conclusion">
                  Conclusion</h4>
                <p>
                  Typeclasses in Lean provide a flexible way to define interfaces for types, similar to interfaces in object-oriented languages. By using typeclasses like <code>ArrayLike</code>, we can define operations such as <code>get</code> and <code>length</code>, which can then be implemented for various types like <code>List</code> and <code>Array</code>. This allows us to write generic functions that work across multiple types, promoting code reuse and flexibility.</p>
                <p>
                  Unlike traditional interfaces, typeclasses allow us to retroactively add functionality to types without modifying their original definitions. This makes them a powerful tool for modular, extensible design in Lean, enabling polymorphism and cleaner abstractions in complex codebases.</p>
                </section>
              </section>
            </section>
          </section>
        </main></div>
    </body>
  </html>

