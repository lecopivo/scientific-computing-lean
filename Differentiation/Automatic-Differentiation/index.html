<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Automatic Differentiation</title><link rel="stylesheet" href="../../book.css">
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <script src="../../static/katex/katex.min.js"></script>
    <script src="../../static/math.js"></script>
    <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="../../-verso-js/popper.js"></script>
    <script src="../../-verso-js/tippy.js"></script>
    <link rel="stylesheet" href="../../static/theme.css">
    <link rel="stylesheet" href="../../static/inter/inter.css">
    <link rel="stylesheet" href="../../static/firacode/fira_code.css">
    <link rel="stylesheet" href="../../static/katex/katex.min.css">
    <link rel="stylesheet" href="../../-verso-css/tippy-border.css">
    <style>

.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
}

.hl.lean .keyword {
  font-weight : bold;
}

.hl.lean .var {
  font-style: italic;
  position: relative;
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5em;
  z-index: 300;
  font-size: inherit;
}

.hl.lean .hover-info.messages {
  max-height: 10em;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5em 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5em;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1em;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0em;
}

/*
@media (hover: hover) {
  .hl.lean .has-info:hover > .hover-container > .hover-info:not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .has-info:hover > .hover-container > .hover-info,
  .hl.lean .token:hover > .hover-container > .hover-info:not(.has-info *):not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .token:hover > .hover-container > .hover-info:not(.has-info *) {
    display: inline-block;
    position: absolute;
    top: 1em;
    font-weight: normal;
    font-style: normal;
    width: min-content;
  }
}
*/

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: 0.1rem;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5em;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error {
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2em solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error pre {
    color: red;
}

.hl.lean .has-info.warning {
  text-decoration-color: #efd871;
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color: #efd871;
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: #efd871;
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2em solid #efd871;
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.info {
  text-decoration-color: blue;
}

@media (hover: hover) {
  .hl.lean .has-info.info:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.info {
  background-color: #e5e5e5;
  border-left: 0.2em solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.info {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: sans-serif;
  white-space: normal;
  max-width: 40em;
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1em;
  margin-right: 1em;
  margin-top: 0.5em;
  margin-bottom: 0.5em;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: monospace;
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  left: 2em;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1em;
  padding: 0.5em;
  font-family: sans-serif;
  background-color: #ffffff;
  z-index: 200;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5em;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: block;
}

/*
@media (hover: hover) {
  .hl.lean .tactic:hover > .tactic-toggle:not(:checked) ~ .tactic-state {
    display: block;
    position: absolute;
    left: 0;
    transform: translate(0.25rem, 0);
    z-index: 250;
  }
}
*/

.hl.lean .tactic > label {
  position: relative;
  transition: all 0.5s;
}

@media (hover: hover) {
  .hl.lean .tactic > label:hover {
    border-bottom: 1px dotted #bbbbbb;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  border-radius: 1em;
  height: 0.25em;
  vertical-align: middle;
  width: 0.6em;
  margin-left: 0.1em;
  margin-right: 0.1em;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5em;
}

.hl.lean .tactic-state summary {
  margin-left: -0.5em;
}

.hl.lean .tactic-state details {
  padding-left: 0.5em;
}

.hl.lean .tactic-state .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .tactic-state .goal-name {
  font-style: italic;
  font-family: monospace;
}

.hl.lean .tactic-state .hypotheses td.colon {
  text-align: center;
  min-width: 1em;
}

.hl.lean .tactic-state .hypotheses td.name {
  text-align: right;
}

.hl.lean .tactic-state .hypotheses td.name,
.hl.lean .tactic-state .hypotheses td.type,
.hl.lean .tactic-state .conclusion .type {
  font-family: monospace;
}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #efd871;
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}



.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}

</style><style>
div.TODO {
  border: 5px solid red;
  position: relative;
}
div.TODO::before {
  content: "TODO";
  position: absolute;
  top: 0;
  right: 0;
  color: red;
  font-size: large;
  font-weight: bold;
  transform: rotate(-90deg) translate(-2em);
}
</style><script>
      
window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    fetch("/-verso-docs.json").then((resp) => resp.json()).then((versoDocData) => {

      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        theme: "lean",
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        ignoreAttributes: true,
        onShow(inst) {
          if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          content.className = "hl lean";
          content.style.display = "block";
          content.style.maxHeight = "300px";
          content.style.overflowY = "auto";
          content.style.overflowX = "hidden";
          const hoverId = tgt.dataset.versoHover;
          const hoverInfo = tgt.querySelector(".hover-info");
          if (hoverId) { // Docstrings from the table
            // TODO stop doing an implicit conversion from string to number here
            let data = versoDocData[hoverId];
            if (data) {
              const info = document.createElement("span");
              info.className = "hover-info";
              info.style.display = "block";
              info.innerHTML = data;
              content.appendChild(info);
              /* Render docstrings - TODO server-side */
              if ('undefined' !== typeof marked) {
                  for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                      const str = d.innerText;
                      const html = marked.parse(str);
                      const rendered = document.createElement("div");
                      rendered.classList.add("docstring");
                      rendered.innerHTML = html;
                      d.parentNode.replaceChild(rendered, d);
                  }
              }
            } else {
              content.innerHTML = "Failed to load doc ID: " + hoverId;
            }
          } else if (hoverInfo) { // The inline info, still used for compiler messages
            content.appendChild(hoverInfo.cloneNode(true));
          }
          return content;
        }
      };

      const addTippy = (selector, props) => {
        tippy(selector, Object.assign({}, defaultTippyProps, props));
      };
      addTippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token', {theme: 'lean'});
      addTippy('.hl.lean .has-info.warning', {theme: 'warning message'});
      addTippy('.hl.lean .has-info.info', {theme: 'info message'});
      addTippy('.hl.lean .has-info.error', {theme: 'error message'});

      tippy('.hl.lean .tactic', {
        allowHtml: true,
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        maxWidth: "none",
        onShow(inst) {
          const toggle = inst.reference.querySelector("input.tactic-toggle");
          if (toggle && toggle.checked) {
            return false;
          }
          if (blockedByTippy(inst.reference)) { return false; }
        },
        theme: "tactic",
        placement: 'bottom-start',
        content (tgt) {
          const content = document.createElement("span");
          const state = tgt.querySelector(".tactic-state").cloneNode(true);
          state.style.display = "block";
          content.appendChild(state);
          content.style.display = "block";
          content.className = "hl lean popup";
          return content;
        }
      });
  });
}
</script>
    </head>
  <body>
    <div class="with-toc">
      <header>
        <h1>
          <a href="../../">Scientific Computing in Lean</a></h1>
        <div id="controls">
          <label for="toggle-toc" id="toggle-toc-click">📖</label></div>
        <div id="print">
          <span>🖨</span></div>
        </header>
      <nav id="toc">
        <input type="checkbox" id="toggle-toc" checked="checked"><ol>
          <li>
            <a href="../../Introduction#Scientific-Computing-in-Lean--Introduction">Introduction</a><ol>
              <li>
                <a href="../../Introduction/About#Scientific-Computing-in-Lean--Introduction--About">About</a></li>
              <li>
                <a href="../../Introduction/Introduction#Scientific-Computing-in-Lean--Introduction--Introduction">Introduction</a><ol>
                  <li>
                    <a href="../../Introduction/Introduction#Scientific-Computing-in-Lean--Introduction--Introduction--Why-Lean-for-Scientific-Computing">Why Lean for Scientific Computing?</a></li>
                  </ol>
                </li>
              </ol>
            </li>
          <li>
            <a href="../../Working-with-Arrays#Scientific-Computing-in-Lean--Working-with-Arrays">Working with Arrays</a><ol>
              <li>
                <a href="../../Working-with-Arrays/Basic-Operations#Scientific-Computing-in-Lean--Working-with-Arrays--Basic-Operations">Basic Operations</a><ol>
                  <li>
                    <a href="../../Working-with-Arrays/Basic-Operations#Scientific-Computing-in-Lean--Working-with-Arrays--Basic-Operations--Reshaping-Arrays">Reshaping Arrays</a></li>
                  <li>
                    <a href="../../Working-with-Arrays/Basic-Operations#Scientific-Computing-in-Lean--Working-with-Arrays--Basic-Operations--Exercises">Exercises</a></li>
                  </ol>
                </li>
              <li>
                <a href="../../Working-with-Arrays/Tensor-Operations#Scientific-Computing-in-Lean--Working-with-Arrays--Tensor-Operations">Tensor Operations</a><ol>
                  <li>
                    <a href="../../Working-with-Arrays/Tensor-Operations#Scientific-Computing-in-Lean--Working-with-Arrays--Tensor-Operations--Transformations-and-Reductions">Transformations and Reductions</a></li>
                  <li>
                    <a href="../../Working-with-Arrays/Tensor-Operations#Scientific-Computing-in-Lean--Working-with-Arrays--Tensor-Operations--Convolution-and-Operations-on-Indices">Convolution and Operations on Indices</a></li>
                  <li>
                    <a href="../../Working-with-Arrays/Tensor-Operations#Scientific-Computing-in-Lean--Working-with-Arrays--Tensor-Operations--Pooling-and-Difficulties-with-Dependent-Types">Pooling and Difficulties with Dependent Types</a></li>
                  <li>
                    <a href="../../Working-with-Arrays/Tensor-Operations#Scientific-Computing-in-Lean--Working-with-Arrays--Tensor-Operations--Simple-Neural-Network">Simple Neural Network</a></li>
                  </ol>
                </li>
              <li>
                <a href="../../Working-with-Arrays/Optimizing-Array-Expressions#Scientific-Computing-in-Lean--Working-with-Arrays--Optimizing-Array-Expressions">Optimizing Array Expressions</a><ol>
                  <li>
                    <a href="../../Working-with-Arrays/Optimizing-Array-Expressions#Scientific-Computing-in-Lean--Working-with-Arrays--Optimizing-Array-Expressions--Loop-Fusion">Loop Fusion</a></li>
                  <li>
                    <a href="../../Working-with-Arrays/Optimizing-Array-Expressions#Scientific-Computing-in-Lean--Working-with-Arrays--Optimizing-Array-Expressions--Optimizing-Array-Indexing">Optimizing Array Indexing</a></li>
                  </ol>
                </li>
              </ol>
            </li>
          <li>
            <a href="../../Differentiation#Scientific-Computing-in-Lean--Differentiation">Differentiation</a><ol>
              <li>
                <a href="../../Differentiation/Symbolic-Differentiation#Scientific-Computing-in-Lean--Differentiation--Symbolic-Differentiation">Symbolic Differentiation</a><ol>
                  <li>
                    <a href="../../Differentiation/Symbolic-Differentiation#Scientific-Computing-in-Lean--Differentiation--Symbolic-Differentiation--Notation">Notation</a></li>
                  <li>
                    <a href="../../Differentiation/Symbolic-Differentiation#Scientific-Computing-in-Lean--Differentiation--Symbolic-Differentiation--Examples">Examples</a></li>
                  <li>
                    <a href="../../Differentiation/Symbolic-Differentiation#Scientific-Computing-in-Lean--Differentiation--Symbolic-Differentiation--Gradient">Gradient</a></li>
                  <li>
                    <a href="../../Differentiation/Symbolic-Differentiation#Scientific-Computing-in-Lean--Differentiation--Symbolic-Differentiation--Derivative-Rules">Derivative Rules</a></li>
                  <li>
                    <a href="../../Differentiation/Symbolic-Differentiation#Scientific-Computing-in-Lean--Differentiation--Symbolic-Differentiation--Differentiating-Division-Log-Sqrt-">Differentiating Division, Log, Sqrt, ...</a></li>
                  <li>
                    <a href="../../Differentiation/Symbolic-Differentiation#Scientific-Computing-in-Lean--Differentiation--Symbolic-Differentiation--Abstract-Vector-Spaces">Abstract Vector Spaces</a></li>
                  </ol>
                </li>
              <li>
                <a href="../../Differentiation/Automatic-Differentiation#Scientific-Computing-in-Lean--Differentiation--Automatic-Differentiation">Automatic Differentiation</a><ol>
                  <li>
                    <a href="../../Differentiation/Automatic-Differentiation#Scientific-Computing-in-Lean--Differentiation--Automatic-Differentiation--Forward-Mode">Forward Mode</a></li>
                  <li>
                    <a href="../../Differentiation/Automatic-Differentiation#Scientific-Computing-in-Lean--Differentiation--Automatic-Differentiation--Reverse-Mode">Reverse Mode</a></li>
                  <li>
                    <a href="../../Differentiation/Automatic-Differentiation#Scientific-Computing-in-Lean--Differentiation--Automatic-Differentiation--Derivatives-of-Neural-Network-Layers">Derivatives of Neural Network Layers</a></li>
                  </ol>
                </li>
              <li>
                <a href="../../Differentiation/Function-Transformation#Scientific-Computing-in-Lean--Differentiation--Function-Transformation">Function Transformation</a><ol>
                  <li>
                    <a href="../../Differentiation/Function-Transformation#Scientific-Computing-in-Lean--Differentiation--Function-Transformation--User-Defined-Function-Transformation">User Defined Function Transformation</a></li>
                  </ol>
                </li>
              </ol>
            </li>
          <li>
            <a href="../../Examples#Scientific-Computing-in-Lean--Examples">Examples</a><ol>
              <li>
                <a href="../../Examples/Harmonic-Oscillator#Scientific-Computing-in-Lean--Examples--Harmonic-Oscillator">Harmonic Oscillator</a></li>
              </ol>
            </li>
          </ol>
        </nav>
      <main><section>
          <h1>
            Automatic Differentiation</h1>
          <p>
            In scientific computing a common requirement is to compute derivatives of a program. The important requirement is that the resulting program computing the derivative should be efficient. The problem with symbolic differentiation is that it can produce expressions which are really inefficient. So called <strong>automatic differentiation</strong> addresses this issue an computes derivatives that are also efficient to compute. </p>
          <p>
            Let's have a look how symbolic differentiation can produce large expressions.</p>
          <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-786" data-verso-hover="13">open</span> <span class="unknown token" data-binding="">SciLean</span> <span class="unknown token" data-binding="">Scalar</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">fun x =&gt;
  let y := x * x * x * x * x * x * x;
  let y_1 := x * x * x * x * x * x;
  let y_2 := x * x * x * x * x;
  let y_3 := x * x * x * x;
  let y_4 := x * x * x;
  let y_5 := x * x;
  let dy := x + x;
  let dy := y_5 + dy * x;
  let dy := y_4 + dy * x;
  let dy := y_3 + dy * x;
  let dy := y_2 + dy * x;
  let dy := y_1 + dy * x;
  y + dy * x : ℝ → ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-806">#check</span></span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∂!</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="222">x</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="222">x</span> <span class="unknown token" data-binding="">*</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="222">x</span> <span class="unknown token" data-binding="">*</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="222">x</span> <span class="unknown token" data-binding="">*</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="222">x</span> <span class="unknown token" data-binding="">*</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="222">x</span> <span class="unknown token" data-binding="">*</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="222">x</span> <span class="unknown token" data-binding="">*</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="222">x</span> <span class="unknown token" data-binding="">*</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="222">x</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
            The last example, symbolic differentiation takes and expression with 9 mulplications and produces an expression with 27 multiplications and 7 additions.</p>
          <p>
            If we instead use forward mode derivative(one type of automatic differentiation which we will explain in a moment)</p>
          <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">fun x =&gt;
  let ydy := x * x;
  let ydy_1 := ydy * x;
  let ydy_2 := ydy_1 * x;
  let ydy_3 := ydy_2 * x;
  let ydy_4 := ydy_3 * x;
  let ydy_5 := ydy_4 * x;
  let zdz := ydy_5 * x;
  fun dx =&gt;
  let ydy_6 := dx * x + dx * x;
  let ydy := dx * ydy + ydy_6 * x;
  let ydy := dx * ydy_1 + ydy * x;
  let ydy := dx * ydy_2 + ydy * x;
  let ydy := dx * ydy_3 + ydy * x;
  let ydy := dx * ydy_4 + ydy * x;
  let zdz_1 := dx * ydy_5 + ydy * x;
  (zdz, zdz_1) : ℝ → ℝ → ℝ × ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-1143">#check</span></span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∂&gt;!</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="222">x</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="222">x</span> <span class="unknown token" data-binding="">*</span> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="222">x</span> <span class="unknown token" data-binding="">*</span> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="222">x</span> <span class="unknown token" data-binding="">*</span> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="222">x</span> <span class="unknown token" data-binding="">*</span> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="222">x</span> <span class="unknown token" data-binding="">*</span> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="222">x</span> <span class="unknown token" data-binding="">*</span> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="222">x</span> <span class="unknown token" data-binding="">*</span> <span class="var token" data-binding="var-_uniq.12" data-verso-hover="222">x</span><span class="unknown token" data-binding="">)</span> 
<span class="unknown token" data-binding=""></span></code><p>
            we obtain 21 multiplications and 7 additions. </p>
          <p>
            The difference might not seems to big but if you look at the shape of the result you can see that the the expression reulting from <code>∂</code> contains a big triangular block of multiplications whose size(in terms of multiplications) grows quadratically in the number of multiplications in the original expression. On the other hand when we use <code>∂&gt;</code>, for every multiplication in the original expression we obtain one line with <code>ydy * x</code> and one line with <code>dx * ydy_i + ydy * dx</code>.</p>
          <div class="TODO">
            <p>
              Add table with number of multplications and additions with growing <code>n</code></p>
            </div>
          <section>
            <h2 id="Scientific-Computing-in-Lean--Differentiation--Automatic-Differentiation--Forward-Mode">
              Forward Mode</h2>
            <p>
              The issue with symbolic differentiation is that the chain rule</p>
            <p>
              $$(f\circ g)'(x) = f'(g(x)) g'(x)
$$</p>
            <p>
              repeats \(g\) on the right hand side twice which can lead to doubling of computation everytime we apply chainrule. </p>
            <p>
              The remedy to this problem is to introduce forward mode derivative \( \overrightarrow{\partial} \)</p>
            <p>
              $$\overrightarrow{\partial} f (x,dx) = (f(x), f'(x) dx)
$$</p>
            <p>
              The motivation is that the forward mode derivative computes the value \( f(x) \) and the derivative \( f'(x) dx \) once and at the same time. Both values then can be comnsumed by subsequent computation without ever evaluating \(f\) again. The chain rule for forward mode derivative is</p>
            <p>
              $$\overrightarrow{\partial} \left( f \circ g \right) =  \overrightarrow{\partial} f  \circ  \overrightarrow{\partial} g  
$$</p>
            <p>
              which does not suffer from the problem of repeating \( g \) twice and thus not potentially double the computation. </p>
            <p>
              In SciLean, the forward mode derivative is <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-SciLean.fwdFDeriv" data-verso-hover="345">fwdFDeriv</span></code> which has notaion <code>∂&gt;</code>. It is defined as</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-2887" data-verso-hover="13">open</span> <span class="unknown token" data-binding="">SciLean</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-2900" data-verso-hover="52">variable</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="227">f</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="222">x</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="222">dx</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-2940">example</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∂&gt;</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="227">f</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="222">x</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="222">dx</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="227">f</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="222">x</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">∂</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="227">f</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="222">x</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="222">dx</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-17789806045712156019-2987-2989"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-2987" data-verso-hover="69">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-17789806045712156019-2987-2989"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="227">f</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span> → <span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.6" data-verso-hover="222">x</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.8" data-verso-hover="222">dx</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type">∂&gt; <span class="var token" data-binding="var-_uniq.4" data-verso-hover="227">f</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="222">x</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="222">dx</span><span class="const token" data-binding="const-Eq" data-verso-hover="72"> = </span>(<span class="var token" data-binding="var-_uniq.4" data-verso-hover="227">f</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="222">x</span>, (∂ <span class="var token" data-binding="var-_uniq.4" data-verso-hover="227">f</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="222">x</span>) <span class="var token" data-binding="var-_uniq.8" data-verso-hover="222">dx</span>)</span></span></div></div></span> <span class="tactic"><label for="tactic-state-7-2990-2993"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRfl-2990" data-verso-hover="230">rfl</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-2990-2993"><div class="tactic-state">All goals completed! 🐙</div></span>
<span class="unknown token" data-binding=""></span></code><p>
              In Lean notation the chain rule can be writen as</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-3055" data-verso-hover="13">open</span> <span class="unknown token" data-binding="">SciLean</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-3068" data-verso-hover="52">variable</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="227">f</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="227">g</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.194" data-verso-hover="271">hf</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Differentiable" data-verso-hover="272">Differentiable</span> <span class="unknown token" data-binding="">ℝ</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="227">f</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.209" data-verso-hover="346">hg</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Differentiable" data-verso-hover="272">Differentiable</span> <span class="unknown token" data-binding="">ℝ</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="227">g</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.211" data-verso-hover="222">x</span> <span class="var token" data-binding="var-_uniq.213" data-verso-hover="222">dx</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-3166">example</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∂&gt;</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="227">f</span> <span class="unknown token" data-binding="">∘</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="227">g</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.211" data-verso-hover="222">x</span> <span class="var token" data-binding="var-_uniq.213" data-verso-hover="222">dx</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-3201" data-verso-hover="80">let</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.554" data-verso-hover="222">y</span><span class="unknown token" data-binding="">,</span><span class="var token" data-binding="var-_uniq.555" data-verso-hover="222">dy</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∂&gt;</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="227">g</span> <span class="var token" data-binding="var-_uniq.211" data-verso-hover="222">x</span> <span class="var token" data-binding="var-_uniq.213" data-verso-hover="222">dx</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">;</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∂&gt;</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="227">f</span> <span class="var token" data-binding="var-_uniq.554" data-verso-hover="222">y</span> <span class="var token" data-binding="var-_uniq.555" data-verso-hover="222">dy</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-6807069070377409450-3248-3250"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-3248" data-verso-hover="69">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-6807069070377409450-3248-3250"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="227">f</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span> → <span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.8" data-verso-hover="227">g</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span> → <span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.194" data-verso-hover="271">hf</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Differentiable" data-verso-hover="272">Differentiable</span> <span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="227">f</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.209" data-verso-hover="346">hg</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Differentiable" data-verso-hover="272">Differentiable</span> <span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="227">g</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.211" data-verso-hover="222">x</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.213" data-verso-hover="222">dx</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type">∂&gt; (<span class="var token" data-binding="var-_uniq.4" data-verso-hover="227">f</span><span class="const token" data-binding="const-Function.comp" data-verso-hover="347"> ∘ </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="227">g</span>) <span class="var token" data-binding="var-_uniq.211" data-verso-hover="222">x</span> <span class="var token" data-binding="var-_uniq.213" data-verso-hover="222">dx</span><span class="const token" data-binding="const-Eq" data-verso-hover="72"> =
  </span><span class="keyword token" data-binding="">match</span> ∂&gt; <span class="var token" data-binding="var-_uniq.8" data-verso-hover="227">g</span> <span class="var token" data-binding="var-_uniq.211" data-verso-hover="222">x</span> <span class="var token" data-binding="var-_uniq.213" data-verso-hover="222">dx</span> <span class="keyword token" data-binding="">with</span>
  | (<span class="var token" data-binding="var-_uniq.2272" data-verso-hover="222">y</span>, <span class="var token" data-binding="var-_uniq.2273" data-verso-hover="222">dy</span>) =&gt; ∂&gt; <span class="var token" data-binding="var-_uniq.4" data-verso-hover="227">f</span> <span class="var token" data-binding="var-_uniq.2256" data-verso-hover="222">y</span> <span class="var token" data-binding="var-_uniq.2257" data-verso-hover="222">dy</span></span></span></div></div></span> <span class="tactic"><label for="tactic-state-7-3251-3275"><span class="keyword token" data-binding="kw-occ-Mathlib.Meta.FunTrans.funTransTacStx-3251">fun_trans</span><span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-Function.comp" data-verso-hover="347">Function.comp</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-3251-3275"><div class="tactic-state">All goals completed! 🐙</div></span>
<span class="unknown token" data-binding=""></span></code><p>
              Alternativelly, when we use the notation <code>↿f</code> that uncurries any function we can write the chain rule</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-3392" data-verso-hover="13">open</span> <span class="unknown token" data-binding="">SciLean</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-3405" data-verso-hover="52">variable</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="227">f</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="227">g</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.194" data-verso-hover="271">hf</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Differentiable" data-verso-hover="272">Differentiable</span> <span class="unknown token" data-binding="">ℝ</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="227">f</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.209" data-verso-hover="346">hg</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Differentiable" data-verso-hover="272">Differentiable</span> <span class="unknown token" data-binding="">ℝ</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="227">g</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-3490">example</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">↿</span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∂&gt;</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="227">f</span> <span class="unknown token" data-binding="">∘</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="227">g</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span> <span class="unknown token" data-binding="">↿</span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∂&gt;</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="227">f</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">∘</span> <span class="unknown token" data-binding="">↿</span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∂&gt;</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="227">g</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-3430472423165176549-3553-3555"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-3553" data-verso-hover="69">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-3430472423165176549-3553-3555"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="227">f</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span> → <span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.8" data-verso-hover="227">g</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span> → <span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.194" data-verso-hover="271">hf</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Differentiable" data-verso-hover="272">Differentiable</span> <span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="227">f</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.209" data-verso-hover="346">hg</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Differentiable" data-verso-hover="272">Differentiable</span> <span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="227">g</span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-Function.HasUncurry.uncurry" data-verso-hover="348">↿</span>(∂&gt; <span class="var token" data-binding="var-_uniq.4" data-verso-hover="227">f</span><span class="const token" data-binding="const-Function.comp" data-verso-hover="347"> ∘ </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="227">g</span>)<span class="const token" data-binding="const-Eq" data-verso-hover="72"> = </span><span class="const token" data-binding="const-Function.HasUncurry.uncurry" data-verso-hover="348">↿</span>(∂&gt; <span class="var token" data-binding="var-_uniq.4" data-verso-hover="227">f</span>)<span class="const token" data-binding="const-Function.comp" data-verso-hover="347"> ∘ </span><span class="const token" data-binding="const-Function.HasUncurry.uncurry" data-verso-hover="348">↿</span>(∂&gt; <span class="var token" data-binding="var-_uniq.8" data-verso-hover="227">g</span>)</span></span></div></div></span> <span class="tactic"><label for="tactic-state-7-3556-3608"><span class="keyword token" data-binding="kw-occ-Mathlib.Meta.FunTrans.funTransTacStx-3556">fun_trans</span><span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-Function.comp" data-verso-hover="347">Function.comp</span><span class="unknown token" data-binding="">,</span><span class="const token" data-binding="const-Function.HasUncurry.uncurry" data-verso-hover="348">Function.HasUncurry.uncurry</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-3556-3608"><div class="tactic-state">All goals completed! 🐙</div></span>
<span class="unknown token" data-binding=""></span></code><p>
              In SciLean it is the theorem <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-SciLean.FwdFDeriv.comp_rule" data-verso-hover="349">SciLean.FwdFDeriv.comp_rule</span></code>.</p>
            <section>
              <h3 id="Scientific-Computing-in-Lean--Differentiation--Automatic-Differentiation--Forward-Mode--autodiff-vs-funtrans">
                autodiff vs fun_trans</h3>
              <p>
                So far we have been using the tactic <code>fun_trans</code> to compute derivatives. You might have notices that <code>fun_trans</code> removes all let bindings from the expression. For example</p>
              <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">fun x =&gt; x * x + (x + x) * x : ℝ → ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-3914">#check</span></span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∂</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="222">x</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-3937" data-verso-hover="80">let</span> <span class="var token" data-binding="var-_uniq.65" data-verso-hover="222">y</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="222">x</span><span class="unknown token" data-binding="">*</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="222">x</span><span class="unknown token" data-binding="">;</span> <span class="var token" data-binding="var-_uniq.65" data-verso-hover="222">y</span><span class="unknown token" data-binding="">*</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="222">x</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-SciLean.term_Rewrite_byAssuming__-3921">rewrite_by</span> <span class="tactic"><label for="tactic-state-11003808201540918500-3967-3979"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.Conv.unfold-3967" data-verso-hover="275">unfold</span> <span class="const token" data-binding="const-deriv" data-verso-hover="233">deriv</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11003808201540918500-3967-3979"><div class="tactic-state"><div class="goal"><span class="conclusion"><span class="prefix">| </span><span class="type"><span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.4918" data-verso-hover="222">x</span> =&gt;
  (∂ (<span class="var token" data-binding="var-_uniq.4921" data-verso-hover="222">x</span>:=<span class="var token" data-binding="var-_uniq.4918" data-verso-hover="222">x</span>),
      <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.4935" data-verso-hover="222">y</span> := <span class="var token" data-binding="var-_uniq.4921" data-verso-hover="222">x</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.4921" data-verso-hover="222">x</span>;
      <span class="var token" data-binding="var-_uniq.4935" data-verso-hover="222">y</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.4921" data-verso-hover="222">x</span>)
    1</span></span></div></div></span><span class="unknown token" data-binding="">;</span> <span class="tactic"><label for="tactic-state-8399292846036099162-3981-3990"><span class="keyword token" data-binding="kw-occ-Mathlib.Meta.FunTrans.funTransConvStx-3981">fun_trans</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-8399292846036099162-3981-3990"><div class="tactic-state"><div class="goal"><span class="conclusion"><span class="prefix">| </span><span class="type"><span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.4918" data-verso-hover="222">x</span> =&gt; <span class="var token" data-binding="var-_uniq.4918" data-verso-hover="222">x</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.4918" data-verso-hover="222">x</span><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="141"> + </span>(<span class="var token" data-binding="var-_uniq.4918" data-verso-hover="222">x</span><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="141"> + </span><span class="var token" data-binding="var-_uniq.4918" data-verso-hover="222">x</span>)<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.4918" data-verso-hover="222">x</span></span></span></div></div></span>
<span class="unknown token" data-binding=""></span></code><p>
                we can alternativelly use <code>autodiff</code> tactic</p>
              <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">fun x =&gt;
  let y := x * x;
  let dy := x + x;
  let dz := y + dy * x;
  dz : ℝ → ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-4073">#check</span></span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∂</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="222">x</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-4096" data-verso-hover="80">let</span> <span class="var token" data-binding="var-_uniq.65" data-verso-hover="222">y</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="222">x</span><span class="unknown token" data-binding="">*</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="222">x</span><span class="unknown token" data-binding="">;</span> <span class="var token" data-binding="var-_uniq.65" data-verso-hover="222">y</span><span class="unknown token" data-binding="">*</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="222">x</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-SciLean.term_Rewrite_byAssuming__-4080">rewrite_by</span> <span class="tactic"><label for="tactic-state-10135235375206188345-4126-4134"><span class="keyword token" data-binding="kw-occ-SciLean.Tactic.lautodiffConvStx-4126">autodiff</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-10135235375206188345-4126-4134"><div class="tactic-state"><div class="goal"><span class="conclusion"><span class="prefix">| </span><span class="type"><span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.3954" data-verso-hover="222">x</span> =&gt;
  <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.3970" data-verso-hover="222">y</span> := <span class="var token" data-binding="var-_uniq.3954" data-verso-hover="222">x</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.3954" data-verso-hover="222">x</span>;
  <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.3985" data-verso-hover="222">dy</span> := <span class="var token" data-binding="var-_uniq.3954" data-verso-hover="222">x</span><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="141"> + </span><span class="var token" data-binding="var-_uniq.3954" data-verso-hover="222">x</span>;
  <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.3999" data-verso-hover="222">dz</span> := <span class="var token" data-binding="var-_uniq.3970" data-verso-hover="222">y</span><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="141"> + </span><span class="var token" data-binding="var-_uniq.3985" data-verso-hover="222">dy</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.3954" data-verso-hover="222">x</span>;
  <span class="var token" data-binding="var-_uniq.3999" data-verso-hover="222">dz</span></span></span></div></div></span>
<span class="unknown token" data-binding=""></span></code><p>
                The tactic <code>autodiff</code> behaves very similarly to <code>fun_trans</code> but it carefully handled let bindings which is important for generating efficient code. Internally it uses a slightly modified version of Lean's simplifier and carefully configured <code>fun_trans</code> such that it handles let bindings more carefully and efficiently.</p>
              <p>
                From now one, the rule of thumb it to use <code>fun_trans</code> if you do not care about generating efficient code and want to just prove something using derivatives and to use <code>autodiff</code> when you care about the efficiency of the resulting code.</p>
              <p>
                You might have noticed that let bindings are preserved when using <code>∂!</code> notation. This is because <code>∂!</code> is using the tactic <code>autodiff</code> instead of <code>fun_trans</code>. </p>
              <p>
                Note that when you want to compute efficient derivatives you have to use <code>autodiff</code> <strong>and</strong> forward mode derivative <code>∂&gt;</code>. Using only one of them will not yield the most efficient code. </p>
              </section>
            <section>
              <h3 id="Scientific-Computing-in-Lean--Differentiation--Automatic-Differentiation--Forward-Mode--Relation-to-Dual-Numbers-">
                Relation to Dual Numbers </h3>
              <p>
                One common explanation of forward mode derivative is through dual numbers \(a + \epsilon b \). Similarly to complex numbers \( \mathbb{C}\), which extend reals numbers with complex unit \(i\) that squares to negative one, \(i^2 = -1\), the dual numbers \( \overline{\mathbb{R}}\) extend real numbers with \(\epsilon\) that squares to zero, \(\epsilon^2 = 0\).</p>
              <p>
                We can add and multiply two dual numbers</p>
              <p>
                $$\begin{align}
(a + \epsilon b) + (c + \epsilon d) &= ((a + c) + \epsilon (b + d)) \\
(a + \epsilon b) (c + \epsilon d) &= ((a c) + \epsilon (b c + a d))
\end{align}
$$</p>
              <p>
                Through power series we can also calculate functions like sin, cos or exp</p>
              <p>
                $$\begin{align}
\sin(a + \epsilon b) &= \sin(a) + \epsilon b \cos(a) \\
\cos(a + \epsilon b) &= \cos(a) - \epsilon b \sin(a) \\
\exp(a + \epsilon b) &= \exp(a) + \epsilon b \exp(a)
\end{align}
$$</p>
              <p>
                In general, for an analytical function <code>(f : ℝ → ℝ)</code> we can show that </p>
              <p>
                $$f(a + \epsilon b) = f(a) + \epsilon b f'(a)
$$</p>
              <p>
                Every dual number is just a pair of two real numbers i.e. \( \overline{\mathbb{R}} \cong \mathbb{R} \times \mathbb{R} \) therefore we can think about the forward mode derivative \(\overrightarrow{\partial} f\) as extension of \(f\) to dual numbers</p>
              <p>
                $$\overrightarrow{\partial} f (x + \epsilon dx) = f(x) + \epsilon f'(x)dx
$$</p>
              <div class="TODO">
                <p>
                  Explain this for general function <code>f : X → Y</code> and relate it to complexification of a vector space.</p>
                </div>
              </section>
            <section>
              <h3 id="Scientific-Computing-in-Lean--Differentiation--Automatic-Differentiation--Forward-Mode--Exercises">
                Exercises</h3>
              <ol start="1">
                <li>
                  <p>
                    In section (??) we defined a function <code>foo</code> </p>
                  </li>
                </ol>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-6655">def</span> <span class="const token" data-binding="const-foo" data-verso-hover="291">foo</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">x</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">x</span><span class="unknown token" data-binding="">^</span><span class="unknown token" data-binding="">2</span> <span class="unknown token" data-binding="">+</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">x</span>
<span class="unknown token" data-binding=""></span></code><p>
                In order to compute derivatives with <code>foo</code> you need to derivative generate theorems using <code>def_fun_trans</code> and <code>def_fun_prop</code> macros. Use <code>def_fun_trans</code> macro to generate forward mode derivative rule for <code>foo</code>.</p>
              <ol start="2">
                <li>
                  <p>
                    Newton's method with forward mode AD. In previous chapter (??) we talked about Newton's method. At each iteration we need to compute the function value \( f(x_n)\) and its derivative  \( f'(x_n)\). Instead of evaluating <code>f x</code> and <code>∂! f x</code> use fowrward mode <code>∂&gt;! f x 1</code> to compute the function value and its derivative at the same time.</p>
                  </li>
                <li>
                  <p>
                    Redo the exercises on Newton's method from chapter (??) using forward mode derivative <code>∂&gt;</code> instead of normal derivative <code>∂</code>.</p>
                  </li>
                <li>
                  <p>
                    Prove on paper that the chain rule for forward mode derivative is equivalent to the standard chain rule.</p>
                  </li>
                </ol>
              </section>
            </section>
          <section>
            <h2 id="Scientific-Computing-in-Lean--Differentiation--Automatic-Differentiation--Reverse-Mode">
              Reverse Mode</h2>
            <p>
              Forward mode derivative <code>∂&gt; f</code> is designed to efficiently compute the derivative <code>∂ f</code>. To efficiently compute the gradient <code>∇ f</code> we have to introduce reverse mode derivative <code>&lt;∂ f</code>. </p>
            <p>
              Recall the that definition of the gradient <code>∇ f</code> is adjoint of the derivative</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-7792" data-verso-hover="52">variable</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="228">f</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">×</span><span class="unknown token" data-binding="">ℝ</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="226">x</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">×</span><span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-7839">example</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∇</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="228">f</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="226">x</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span> <span class="const token" data-binding="const-adjoint" data-verso-hover="266">adjoint</span> <span class="unknown token" data-binding="">ℝ</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∂</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="228">f</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="226">x</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-12422120010584835708-7888-7890"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-7888" data-verso-hover="69">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12422120010584835708-7888-7890"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.6" data-verso-hover="228">f</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span><span class="const token" data-binding="const-Prod" data-verso-hover="71"> × </span><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span> → <span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.10" data-verso-hover="226">x</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span><span class="const token" data-binding="const-Prod" data-verso-hover="71"> × </span><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type">∇ <span class="var token" data-binding="var-_uniq.6" data-verso-hover="228">f</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="226">x</span><span class="const token" data-binding="const-Eq" data-verso-hover="72"> = </span><span class="const token" data-binding="const-adjoint" data-verso-hover="266">adjoint</span> <span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span> (⇑(∂ <span class="var token" data-binding="var-_uniq.6" data-verso-hover="228">f</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="226">x</span>)) 1</span></span></div></div></span> <span class="tactic"><label for="tactic-state-7-7891-7894"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRfl-7891" data-verso-hover="230">rfl</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-7891-7894"><div class="tactic-state">All goals completed! 🐙</div></span>
<span class="unknown token" data-binding=""></span></code><p>
              One might naively do the same trick as with forward mode derivative and define reverse mode by putting together the function value and the derivative together i.e. <code>&lt;∂ f x dy = (f x, adjoint ℝ (∂ f x) dy)</code>. However, it is not possible to write down a good chain rule for this operation. The only way to do this is to postpone the argument <code>dy</code> and define the reverse mode derivative as</p>
            <pre>variable (f : ℝ → ℝ) (x : ℝ)
example : (&lt;∂ f x) = (f x, fun dy =&gt; adjoint ℝ (∂ f x) dy) := by rfl
</pre><p>
              The reverse mode derivative at point <code>x</code> computes the value <code>f x</code> and a function that can compute the adjoint of the derivative.</p>
            <p>
              With this definition we can write down the chain rule for reverse mode derivative</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-8631" data-verso-hover="52">variable</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="227">f</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="227">g</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="222">x</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.196" data-verso-hover="271">hf</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Differentiable" data-verso-hover="272">Differentiable</span> <span class="unknown token" data-binding="">ℝ</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="227">f</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.211" data-verso-hover="346">hg</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Differentiable" data-verso-hover="272">Differentiable</span> <span class="unknown token" data-binding="">ℝ</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="227">g</span><span class="unknown token" data-binding="">)</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-8727">example</span> <span class="unknown token" data-binding="">:</span> 
  <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">&lt;∂</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-8747">fun</span> <span class="var token" data-binding="var-_uniq.451" data-verso-hover="222">x</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="227">f</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="227">g</span> <span class="var token" data-binding="var-_uniq.451" data-verso-hover="222">x</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="222">x</span><span class="unknown token" data-binding="">)</span>
  <span class="unknown token" data-binding="">=</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-8774" data-verso-hover="80">let</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.540" data-verso-hover="222">y</span><span class="unknown token" data-binding="">,</span><span class="var token" data-binding="var-_uniq.541" data-verso-hover="227">dg'</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">&lt;∂</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="227">g</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="222">x</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-8800" data-verso-hover="80">let</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.596" data-verso-hover="222">z</span><span class="unknown token" data-binding="">,</span><span class="var token" data-binding="var-_uniq.597" data-verso-hover="227">df'</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">&lt;∂</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="227">f</span> <span class="var token" data-binding="var-_uniq.540" data-verso-hover="222">y</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.596" data-verso-hover="222">z</span><span class="unknown token" data-binding="">,</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-8830">fun</span> <span class="var token" data-binding="var-_uniq.605" data-verso-hover="222">dz</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.541" data-verso-hover="227">dg'</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.597" data-verso-hover="227">df'</span> <span class="var token" data-binding="var-_uniq.605" data-verso-hover="222">dz</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-2360441552519140296-8857-8859"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-8857" data-verso-hover="69">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-2360441552519140296-8857-8859"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="227">f</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span> → <span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.8" data-verso-hover="227">g</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span> → <span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.10" data-verso-hover="222">x</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.196" data-verso-hover="271">hf</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Differentiable" data-verso-hover="272">Differentiable</span> <span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="227">f</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.211" data-verso-hover="346">hg</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Differentiable" data-verso-hover="272">Differentiable</span> <span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="227">g</span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type">&lt;∂ (<span class="var token" data-binding="var-_uniq.2014" data-verso-hover="222">x</span>:=<span class="var token" data-binding="var-_uniq.10" data-verso-hover="222">x</span>), <span class="var token" data-binding="var-_uniq.4" data-verso-hover="227">f</span> (<span class="var token" data-binding="var-_uniq.8" data-verso-hover="227">g</span> <span class="var token" data-binding="var-_uniq.2014" data-verso-hover="222">x</span>)<span class="const token" data-binding="const-Eq" data-verso-hover="72"> =
  </span><span class="keyword token" data-binding="">match</span> &lt;∂ <span class="var token" data-binding="var-_uniq.8" data-verso-hover="227">g</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="222">x</span> <span class="keyword token" data-binding="">with</span>
  | (<span class="var token" data-binding="var-_uniq.2069" data-verso-hover="222">y</span>, <span class="var token" data-binding="var-_uniq.2070" data-verso-hover="227">dg'</span>) =&gt;
    <span class="keyword token" data-binding="">match</span> &lt;∂ <span class="var token" data-binding="var-_uniq.4" data-verso-hover="227">f</span> <span class="var token" data-binding="var-_uniq.2031" data-verso-hover="222">y</span> <span class="keyword token" data-binding="">with</span>
    | (<span class="var token" data-binding="var-_uniq.2059" data-verso-hover="222">z</span>, <span class="var token" data-binding="var-_uniq.2060" data-verso-hover="227">df'</span>) =&gt; (<span class="var token" data-binding="var-_uniq.2049" data-verso-hover="222">z</span>, <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.2055" data-verso-hover="222">dz</span> =&gt; <span class="var token" data-binding="var-_uniq.2032" data-verso-hover="227">dg'</span> (<span class="var token" data-binding="var-_uniq.2050" data-verso-hover="227">df'</span> <span class="var token" data-binding="var-_uniq.2055" data-verso-hover="222">dz</span>))</span></span></div></div></span> <span class="tactic"><label for="tactic-state-7-8860-8869"><span class="keyword token" data-binding="kw-occ-Mathlib.Meta.FunTrans.funTransTacStx-8860">fun_trans</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-8860-8869"><div class="tactic-state">All goals completed! 🐙</div></span>
<span class="unknown token" data-binding=""></span></code><p>
              The crucial observation is that the derivative part of <code>&lt;∂ (f∘g)</code> composes the derivatives of <code>f</code> and <code>g</code> in the reverse order hence the name <strong>reverse mode</strong>.</p>
            <div class="TODO">
              <p>
                Talk about </p>
              <ol start="1">
                <li>
                  <p>
                    what is forward pass and reverse pass</p>
                  </li>
                <li>
                  <p>
                    memory requirements of reverse mode</p>
                  </li>
                <li>
                  <p>
                    forward mode vs reverse mode </p>
                  </li>
                <li>
                  <p>
                    relation to vjp jvp convention</p>
                  </li>
                </ol>
              </div>
            <section>
              <h3 id="Scientific-Computing-in-Lean--Differentiation--Automatic-Differentiation--Reverse-Mode--Exercises">
                Exercises</h3>
              <ol start="1">
                <li>
                  <p>
                    reimplement gradient descent using <code>revFDeriv</code> and use <code>f x</code> for computing the improvement</p>
                  </li>
                <li>
                  <p>
                    Generate <code>revFDeriv</code> rules for <code>foo</code>.</p>
                  </li>
                <li>
                  <p>
                    SDF projection</p>
                  <ul>
                    <li>
                      <p>
                        sphere</p>
                      </li>
                    <li>
                      <p>
                        pick something from
    https://iquilezles.org/articles/distfunctions/</p>
                      </li>
                    </ul>
                  </li>
                </ol>
              </section>
            </section>
          <section>
            <h2 id="Scientific-Computing-in-Lean--Differentiation--Automatic-Differentiation--Derivatives-of-Neural-Network-Layers">
              Derivatives of Neural Network Layers</h2>
            <p>
              In the chapter 'Working with Arrays' we have constructured a simple neural network. To train it we have to comput its derivative</p>
            <div class="TODO">
              <p>
                Differentiate neural network layers from the chapter 'Working with Arrays'</p>
              </div>
            </section>
          </section>
        </main></div>
    </body>
  </html>

