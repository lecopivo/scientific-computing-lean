<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Symbolic Differentiation</title><link rel="stylesheet" href="../../book.css">
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <script src="../../static/katex/katex.min.js"></script>
    <script src="../../static/math.js"></script>
    <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="../../-verso-js/popper.js"></script>
    <script src="../../-verso-js/tippy.js"></script>
    <link rel="stylesheet" href="../../static/theme.css">
    <link rel="stylesheet" href="../../static/inter/inter.css">
    <link rel="stylesheet" href="../../static/firacode/fira_code.css">
    <link rel="stylesheet" href="../../static/katex/katex.min.css">
    <link rel="stylesheet" href="../../-verso-css/tippy-border.css">
    <style>

.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
}

.hl.lean .keyword {
  font-weight : bold;
}

.hl.lean .var {
  font-style: italic;
  position: relative;
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5em;
  z-index: 300;
  font-size: inherit;
}

.hl.lean .hover-info.messages {
  max-height: 10em;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5em 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5em;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1em;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0em;
}

/*
@media (hover: hover) {
  .hl.lean .has-info:hover > .hover-container > .hover-info:not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .has-info:hover > .hover-container > .hover-info,
  .hl.lean .token:hover > .hover-container > .hover-info:not(.has-info *):not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .token:hover > .hover-container > .hover-info:not(.has-info *) {
    display: inline-block;
    position: absolute;
    top: 1em;
    font-weight: normal;
    font-style: normal;
    width: min-content;
  }
}
*/

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: 0.1rem;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5em;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error {
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2em solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error pre {
    color: red;
}

.hl.lean .has-info.warning {
  text-decoration-color: #efd871;
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color: #efd871;
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: #efd871;
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2em solid #efd871;
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.info {
  text-decoration-color: blue;
}

@media (hover: hover) {
  .hl.lean .has-info.info:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.info {
  background-color: #e5e5e5;
  border-left: 0.2em solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.info {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: sans-serif;
  white-space: normal;
  max-width: 40em;
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1em;
  margin-right: 1em;
  margin-top: 0.5em;
  margin-bottom: 0.5em;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: monospace;
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  left: 2em;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1em;
  padding: 0.5em;
  font-family: sans-serif;
  background-color: #ffffff;
  z-index: 200;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5em;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: block;
}

/*
@media (hover: hover) {
  .hl.lean .tactic:hover > .tactic-toggle:not(:checked) ~ .tactic-state {
    display: block;
    position: absolute;
    left: 0;
    transform: translate(0.25rem, 0);
    z-index: 250;
  }
}
*/

.hl.lean .tactic > label {
  position: relative;
  transition: all 0.5s;
}

@media (hover: hover) {
  .hl.lean .tactic > label:hover {
    border-bottom: 1px dotted #bbbbbb;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  border-radius: 1em;
  height: 0.25em;
  vertical-align: middle;
  width: 0.6em;
  margin-left: 0.1em;
  margin-right: 0.1em;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5em;
}

.hl.lean .tactic-state summary {
  margin-left: -0.5em;
}

.hl.lean .tactic-state details {
  padding-left: 0.5em;
}

.hl.lean .tactic-state .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .tactic-state .goal-name {
  font-style: italic;
  font-family: monospace;
}

.hl.lean .tactic-state .hypotheses td.colon {
  text-align: center;
  min-width: 1em;
}

.hl.lean .tactic-state .hypotheses td.name {
  text-align: right;
}

.hl.lean .tactic-state .hypotheses td.name,
.hl.lean .tactic-state .hypotheses td.type,
.hl.lean .tactic-state .conclusion .type {
  font-family: monospace;
}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #efd871;
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}



.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}

</style><style>
div.TODO {
  border: 5px solid red;
  position: relative;
}
div.TODO::before {
  content: "TODO";
  position: absolute;
  top: 0;
  right: 0;
  color: red;
  font-size: large;
  font-weight: bold;
  transform: rotate(-90deg) translate(-2em);
}
</style><script>
      
window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    fetch("/-verso-docs.json").then((resp) => resp.json()).then((versoDocData) => {

      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        theme: "lean",
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        ignoreAttributes: true,
        onShow(inst) {
          if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          content.className = "hl lean";
          content.style.display = "block";
          content.style.maxHeight = "300px";
          content.style.overflowY = "auto";
          content.style.overflowX = "hidden";
          const hoverId = tgt.dataset.versoHover;
          const hoverInfo = tgt.querySelector(".hover-info");
          if (hoverId) { // Docstrings from the table
            // TODO stop doing an implicit conversion from string to number here
            let data = versoDocData[hoverId];
            if (data) {
              const info = document.createElement("span");
              info.className = "hover-info";
              info.style.display = "block";
              info.innerHTML = data;
              content.appendChild(info);
              /* Render docstrings - TODO server-side */
              if ('undefined' !== typeof marked) {
                  for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                      const str = d.innerText;
                      const html = marked.parse(str);
                      const rendered = document.createElement("div");
                      rendered.classList.add("docstring");
                      rendered.innerHTML = html;
                      d.parentNode.replaceChild(rendered, d);
                  }
              }
            } else {
              content.innerHTML = "Failed to load doc ID: " + hoverId;
            }
          } else if (hoverInfo) { // The inline info, still used for compiler messages
            content.appendChild(hoverInfo.cloneNode(true));
          }
          return content;
        }
      };

      const addTippy = (selector, props) => {
        tippy(selector, Object.assign({}, defaultTippyProps, props));
      };
      addTippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token', {theme: 'lean'});
      addTippy('.hl.lean .has-info.warning', {theme: 'warning message'});
      addTippy('.hl.lean .has-info.info', {theme: 'info message'});
      addTippy('.hl.lean .has-info.error', {theme: 'error message'});

      tippy('.hl.lean .tactic', {
        allowHtml: true,
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        maxWidth: "none",
        onShow(inst) {
          const toggle = inst.reference.querySelector("input.tactic-toggle");
          if (toggle && toggle.checked) {
            return false;
          }
          if (blockedByTippy(inst.reference)) { return false; }
        },
        theme: "tactic",
        placement: 'bottom-start',
        content (tgt) {
          const content = document.createElement("span");
          const state = tgt.querySelector(".tactic-state").cloneNode(true);
          state.style.display = "block";
          content.appendChild(state);
          content.style.display = "block";
          content.className = "hl lean popup";
          return content;
        }
      });
  });
}
</script>
    </head>
  <body>
    <div class="with-toc">
      <header>
        <h1>
          <a href="../../">Scientific Computing in Lean</a></h1>
        <div id="controls">
          <label for="toggle-toc" id="toggle-toc-click">📖</label></div>
        <div id="print">
          <span>🖨</span></div>
        </header>
      <nav id="toc">
        <input type="checkbox" id="toggle-toc" checked="checked"><ol>
          <li>
            <a href="../../Introduction#Scientific-Computing-in-Lean--Introduction">Introduction</a><ol>
              <li>
                <a href="../../Introduction/About#Scientific-Computing-in-Lean--Introduction--About">About</a></li>
              <li>
                <a href="../../Introduction/Introduction#Scientific-Computing-in-Lean--Introduction--Introduction">Introduction</a><ol>
                  <li>
                    <a href="../../Introduction/Introduction#Scientific-Computing-in-Lean--Introduction--Introduction--Why-Lean-for-Scientific-Computing">Why Lean for Scientific Computing?</a></li>
                  </ol>
                </li>
              </ol>
            </li>
          <li>
            <a href="../../Working-with-Arrays#Scientific-Computing-in-Lean--Working-with-Arrays">Working with Arrays</a><ol>
              <li>
                <a href="../../Working-with-Arrays/Basic-Operations#Scientific-Computing-in-Lean--Working-with-Arrays--Basic-Operations">Basic Operations</a><ol>
                  <li>
                    <a href="../../Working-with-Arrays/Basic-Operations#Scientific-Computing-in-Lean--Working-with-Arrays--Basic-Operations--Reshaping-Arrays">Reshaping Arrays</a></li>
                  <li>
                    <a href="../../Working-with-Arrays/Basic-Operations#Scientific-Computing-in-Lean--Working-with-Arrays--Basic-Operations--Exercises">Exercises</a></li>
                  </ol>
                </li>
              <li>
                <a href="../../Working-with-Arrays/Tensor-Operations#Scientific-Computing-in-Lean--Working-with-Arrays--Tensor-Operations">Tensor Operations</a><ol>
                  <li>
                    <a href="../../Working-with-Arrays/Tensor-Operations#Scientific-Computing-in-Lean--Working-with-Arrays--Tensor-Operations--Transformations-and-Reductions">Transformations and Reductions</a></li>
                  <li>
                    <a href="../../Working-with-Arrays/Tensor-Operations#Scientific-Computing-in-Lean--Working-with-Arrays--Tensor-Operations--Convolution-and-Operations-on-Indices">Convolution and Operations on Indices</a></li>
                  <li>
                    <a href="../../Working-with-Arrays/Tensor-Operations#Scientific-Computing-in-Lean--Working-with-Arrays--Tensor-Operations--Pooling-and-Difficulties-with-Dependent-Types">Pooling and Difficulties with Dependent Types</a></li>
                  <li>
                    <a href="../../Working-with-Arrays/Tensor-Operations#Scientific-Computing-in-Lean--Working-with-Arrays--Tensor-Operations--Simple-Neural-Network">Simple Neural Network</a></li>
                  </ol>
                </li>
              <li>
                <a href="../../Working-with-Arrays/Optimizing-Array-Expressions#Scientific-Computing-in-Lean--Working-with-Arrays--Optimizing-Array-Expressions">Optimizing Array Expressions</a><ol>
                  <li>
                    <a href="../../Working-with-Arrays/Optimizing-Array-Expressions#Scientific-Computing-in-Lean--Working-with-Arrays--Optimizing-Array-Expressions--Loop-Fusion">Loop Fusion</a></li>
                  <li>
                    <a href="../../Working-with-Arrays/Optimizing-Array-Expressions#Scientific-Computing-in-Lean--Working-with-Arrays--Optimizing-Array-Expressions--Optimizing-Array-Indexing">Optimizing Array Indexing</a></li>
                  </ol>
                </li>
              </ol>
            </li>
          <li>
            <a href="../../Differentiation#Scientific-Computing-in-Lean--Differentiation">Differentiation</a><ol>
              <li>
                <a href="../../Differentiation/Symbolic-Differentiation#Scientific-Computing-in-Lean--Differentiation--Symbolic-Differentiation">Symbolic Differentiation</a><ol>
                  <li>
                    <a href="../../Differentiation/Symbolic-Differentiation#Scientific-Computing-in-Lean--Differentiation--Symbolic-Differentiation--Notation-for-Derivative">Notation for Derivative</a></li>
                  <li>
                    <a href="../../Differentiation/Symbolic-Differentiation#Scientific-Computing-in-Lean--Differentiation--Symbolic-Differentiation--Derivative-Examples">Derivative Examples</a></li>
                  <li>
                    <a href="../../Differentiation/Symbolic-Differentiation#Scientific-Computing-in-Lean--Differentiation--Symbolic-Differentiation--Gradient">Gradient</a></li>
                  <li>
                    <a href="../../Differentiation/Symbolic-Differentiation#Scientific-Computing-in-Lean--Differentiation--Symbolic-Differentiation--Missing-Derivative-Rules">Missing Derivative Rules</a></li>
                  <li>
                    <a href="../../Differentiation/Symbolic-Differentiation#Scientific-Computing-in-Lean--Differentiation--Symbolic-Differentiation--Differentiating-Division-Log-Sqrt-">Differentiating Division, Log, Sqrt, ...</a></li>
                  </ol>
                </li>
              </ol>
            </li>
          <li>
            <a href="../../Examples#Scientific-Computing-in-Lean--Examples">Examples</a><ol>
              <li>
                <a href="../../Examples/Harmonic-Oscillator#Scientific-Computing-in-Lean--Examples--Harmonic-Oscillator">Harmonic Oscillator</a></li>
              </ol>
            </li>
          </ol>
        </nav>
      <main><section>
          <h1>
            Symbolic Differentiation</h1>
          <p>
            Differentiation is at the heart of many problems in scientific computing, from optimizing functions to solving differential equations. Computing derivatives is a mechanical process but very error prone when done manually. In this chapter, we will explore how we can compute derivatives of expressions and programs automatically.</p>
          <p>
            Let's recall what derivative is, for a function <code>f : ℝ → ℝ</code> we define it derivative as</p>
          <p>
            $$f'(x) = \lim_{h → 0} \frac{f(x+h) - f(x)}{h}
$$</p>
          <p>
            The mathematical library <strong>Mathlib</strong> defines derivative <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-fderiv" data-verso-hover="221">fderiv</span></code> for a general function <code>f : X → Y</code> from some vector spaces <code>X</code> and <code>Y</code>. The derivative of <code>f</code> at point <code>x : X</code> in direction <code>dx : X</code> is</p>
          <p>
            $$\texttt{fderiv ℝ f x dx} = \lim_{h → 0} \frac{f(x+h\cdot dx) - f(x)}{h}
$$</p>
          <p>
            <strong>SciLean</strong> provides tactic <code>fun_trans</code> which can compute derivatives. The name <code>fun_trans</code> stands for 'function transformation' and differentiations is just one example of function transformation. We will talk about general function transformations later in the book.</p>
          <p>
            One of the simplest examples of a derivative is the derivative of \(x^n\) which is equal to \(n x^{n-1}\). Let's compute it using <code>fun_trans</code> tactic</p>
          <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-1487" data-verso-hover="52">variable</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">n</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">x</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">↑n * x ^ (n - 1) : ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-1516">#check</span></span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-fderiv" data-verso-hover="221">fderiv</span> <span class="unknown token" data-binding="">ℝ</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-1536">fun</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="222">x</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.20" data-verso-hover="222">x</span><span class="unknown token" data-binding="">^</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">n</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">x</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-SciLean.term_Rewrite_byAssuming__-1523">rewrite_by</span> <span class="tactic"><label for="tactic-state-3389842003703735567-1574-1583"><span class="keyword token" data-binding="kw-occ-Mathlib.Meta.FunTrans.funTransConvStx-1574">fun_trans</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-3389842003703735567-1574-1583"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">n</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">x</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr></table><span class="conclusion"><span class="prefix">| </span><span class="type">↑<span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">n</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">x</span><span class="const token" data-binding="const-HPow.hPow" data-verso-hover="224"> ^ </span>(<span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">n</span><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="225"> - </span>1)</span></span></div></div></span>
<span class="unknown token" data-binding=""></span></code><div class="information">
            <pre>↑n * x ^ (n - 1) : ℝ
</pre></div>
          <div class="TODO">
            <p>
              Add a link to an interactive code editor and encourage reader to differentiate more complicated expressions involving sin, cos, exp, ... but warn about log or division.</p>
            </div>
          <section>
            <h2 id="Scientific-Computing-in-Lean--Differentiation--Symbolic-Differentiation--Notation-for-Derivative">
              Notation for Derivative</h2>
            <p>
              Writing <code>fderiv ℝ (fun x =&gt; f x)</code> is somewhat tedious so <strong>SciLean</strong> makes our life easier by introducing a nice notation <code>∂ x, f x</code> for differentiating <code>(f x)</code> w.r.t. <code>x</code>.</p>
            <p>
              Before we explore this notation further we have to mention that  <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-fderiv" data-verso-hover="221">fderiv</span></code> can also compute complex derivatives with <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-fderiv" data-verso-hover="221">fderiv</span> <span class="unknown token" data-binding="">ℂ</span></code> instead of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-fderiv" data-verso-hover="221">fderiv</span> <span class="unknown token" data-binding="">ℝ</span></code>. However, most of the time we work exclusively with real derivative so we can inform Lean that the default choce of the scalar field are real numbers using the following command</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-SciLean.NotationOverField.commandSet_default_scalar_-2383">set_default_scalar</span> <span class="unknown token" data-binding="">ℝ</span>
<span class="unknown token" data-binding=""></span></code><p>
              Now Lean knows that we want real derivative when we write <code>∂ x, f x</code>.</p>
            <p>
              Using this notation we can compute again the above derivative</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-2571" data-verso-hover="52">variable</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">n</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span><span class="unknown token" data-binding="">)</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">fun x =&gt; ↑n * x ^ (n - 1) : ℝ → ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-2590">#check</span></span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∂</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="222">x</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="222">x</span><span class="unknown token" data-binding="">^</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">n</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-SciLean.term_Rewrite_byAssuming__-2597">rewrite_by</span> <span class="tactic"><label for="tactic-state-15095968220163791515-2629-2638"><span class="keyword token" data-binding="kw-occ-Mathlib.Meta.FunTrans.funTransConvStx-2629">fun_trans</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-15095968220163791515-2629-2638"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">n</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span></td></tr></table><span class="conclusion"><span class="prefix">| </span><span class="type"><span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.3419" data-verso-hover="222">x</span> =&gt; ↑<span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">n</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.3419" data-verso-hover="222">x</span><span class="const token" data-binding="const-HPow.hPow" data-verso-hover="224"> ^ </span>(<span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">n</span><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="225"> - </span>1)</span></span></div></div></span>
<span class="unknown token" data-binding=""></span></code><div class="information">
              <pre>fun x =&gt; ↑n * x ^ (n - 1) : ℝ → ℝ
</pre></div>
            <p>
              Because we did not specify the point where we want to compute the derivative we obtained a function in <code>x</code>. We can specify the point where we want to compute the derivative with <code>∂ (x:=x₀), ...</code></p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-2936" data-verso-hover="52">variable</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">n</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">x₀</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">↑n * x₀ ^ (n - 1) : ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-2968">#check</span></span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∂</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="222">x</span><span class="unknown token" data-binding="">:=</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">x₀</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.13" data-verso-hover="222">x</span><span class="unknown token" data-binding="">^</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">n</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-SciLean.term_Rewrite_byAssuming__-2975">rewrite_by</span> <span class="tactic"><label for="tactic-state-10093373467645080824-3007-3016"><span class="keyword token" data-binding="kw-occ-Mathlib.Meta.FunTrans.funTransConvStx-3007">fun_trans</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-10093373467645080824-3007-3016"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">n</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">x₀</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr></table><span class="conclusion"><span class="prefix">| </span><span class="type">↑<span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">n</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">x₀</span><span class="const token" data-binding="const-HPow.hPow" data-verso-hover="224"> ^ </span>(<span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">n</span><span class="const token" data-binding="const-HSub.hSub" data-verso-hover="225"> - </span>1)</span></span></div></div></span>
<span class="unknown token" data-binding=""></span></code><div class="information">
              <pre>↑n * x₀ ^ (n - 1) : ℝ
</pre></div>
            <p>
              Writing <code>rewrite_by fun_trans</code> every time we want to diferentiate an expression gets a bit tedious. We can add an exclamation mark after <code>∂</code> to indicate that we want to run <code>fun_trans</code> tactic to compute the derivative.</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-3324" data-verso-hover="52">variable</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">n</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span><span class="unknown token" data-binding="">)</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">fun x =&gt; ↑n * x ^ (n - 1) : ℝ → ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-3343">#check</span></span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∂!</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="222">x</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="222">x</span><span class="unknown token" data-binding="">^</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">n</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
              <pre>fun x =&gt; ↑n * x ^ (n - 1) : ℝ → ℝ
</pre></div>
            <p>
              We can differentiate w.r.t to a vector valued variable <code>(x : ℝ×ℝ)</code></p>
            <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">fun x =&gt; fun dx =&gt;L[ℝ] 2 * ⟪dx, x⟫_ℝ : ℝ × ℝ → ℝ × ℝ →L[ℝ] ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-3545">#check</span></span> <span class="unknown token" data-binding="">∂!</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="226">x</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">×</span><span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">‖</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="226">x</span><span class="unknown token" data-binding="">‖₂²</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
              <pre>fun x =&gt; fun dx =&gt;L[ℝ] 2 * ⟪dx, x⟫_ℝ : ℝ × ℝ → ℝ × ℝ →L[ℝ] ℝ
</pre></div>
            <p>
              For derivatives w.r.t. a vector valued variable we have to also specify the direction in which we differentiate. Therefore in the above we obtained derivative as a function of the position <code>x</code> and direction <code>dx</code>. Furthermore, the notation <code>fun dx =&gt;L[ℝ] ...</code> indicates that the function is linear function in <code>dx</code> and similarly <code>X →L[ℝ] Y</code> stands for the space of ℝ-linear functions from <code>X</code> to <code>Y</code>.</p>
            <p>
              If we want to specify the position and the direction in which we want to compute the derivatives we use the notation <code>∂ (x:=x₀;dx₀), f x</code></p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-4284" data-verso-hover="52">variable</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="226">x₀</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="226">dx₀</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">×</span><span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">2 * ⟪dx₀, x₀⟫_ℝ : ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-4317">#check</span></span> <span class="unknown token" data-binding="">∂!</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.29" data-verso-hover="226">x</span><span class="unknown token" data-binding="">:=</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="226">x₀</span><span class="unknown token" data-binding="">;</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="226">dx₀</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">‖</span><span class="var token" data-binding="var-_uniq.29" data-verso-hover="226">x</span><span class="unknown token" data-binding="">‖₂²</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
              <pre>2 * ⟪dx₀, x₀⟫_ℝ : ℝ
</pre></div>
            <p>
              To summarize all the different variants. For function of a scalar valued argument</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-4514" data-verso-hover="52">variable</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.205" data-verso-hover="227">f</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.207" data-verso-hover="222">x₀</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span>

<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">∂ f : ℝ → ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-4555">#check</span></span> <span class="unknown token" data-binding="">∂</span> <span class="var token" data-binding="var-_uniq.205" data-verso-hover="227">f</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">∂ x, f x : ℝ → ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-4568">#check</span></span> <span class="unknown token" data-binding="">∂</span> <span class="var token" data-binding="var-_uniq.214" data-verso-hover="222">x</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.205" data-verso-hover="227">f</span> <span class="var token" data-binding="var-_uniq.214" data-verso-hover="222">x</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">∂ (x:=x₀), f x : ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-4586">#check</span></span> <span class="unknown token" data-binding="">∂</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.410" data-verso-hover="222">x</span><span class="unknown token" data-binding="">:=</span><span class="var token" data-binding="var-_uniq.207" data-verso-hover="222">x₀</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.205" data-verso-hover="227">f</span> <span class="var token" data-binding="var-_uniq.410" data-verso-hover="222">x</span>
<span class="unknown token" data-binding=""></span></code><p>
              For function of a vector valued argument</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-4666" data-verso-hover="52">variable</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.645" data-verso-hover="228">f</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">×</span><span class="unknown token" data-binding="">ℝ</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.649" data-verso-hover="226">x₀</span> <span class="var token" data-binding="var-_uniq.653" data-verso-hover="226">dx₀</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">×</span><span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span>

<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">∂ f : ℝ × ℝ → ℝ × ℝ →L[ℝ] ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-4723">#check</span></span> <span class="unknown token" data-binding="">∂</span> <span class="var token" data-binding="var-_uniq.645" data-verso-hover="228">f</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">∂ x, f x : ℝ × ℝ → ℝ × ℝ →L[ℝ] ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-4736">#check</span></span> <span class="unknown token" data-binding="">∂</span> <span class="var token" data-binding="var-_uniq.347" data-verso-hover="226">x</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.645" data-verso-hover="228">f</span> <span class="var token" data-binding="var-_uniq.347" data-verso-hover="226">x</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">∂ (x:=x₀), f x : ℝ × ℝ →L[ℝ] ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-4754">#check</span></span> <span class="unknown token" data-binding="">∂</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.658" data-verso-hover="226">x</span><span class="unknown token" data-binding="">:=</span><span class="var token" data-binding="var-_uniq.649" data-verso-hover="226">x₀</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.645" data-verso-hover="228">f</span> <span class="var token" data-binding="var-_uniq.658" data-verso-hover="226">x</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">(∂ (x:=x₀), f x) dx₀ : ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-4780">#check</span></span> <span class="unknown token" data-binding="">∂</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.981" data-verso-hover="226">x</span><span class="unknown token" data-binding="">:=</span><span class="var token" data-binding="var-_uniq.649" data-verso-hover="226">x₀</span><span class="unknown token" data-binding="">;</span><span class="var token" data-binding="var-_uniq.653" data-verso-hover="226">dx₀</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.645" data-verso-hover="228">f</span> <span class="var token" data-binding="var-_uniq.981" data-verso-hover="226">x</span>
<span class="unknown token" data-binding=""></span></code><p>
              There is nothing stopping us from applying derivative multiple times to compute higher order derivatives</p>
            <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">fun x =&gt; 2 : ℝ → ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-4947">#check</span></span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∂!</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∂!</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2620" data-verso-hover="222">x</span><span class="unknown token" data-binding="">:</span><span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.2620" data-verso-hover="222">x</span><span class="unknown token" data-binding="">^</span><span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
              <pre>fun x =&gt; 2 : ℝ → ℝ
</pre></div>
            </section>
          <section>
            <h2 id="Scientific-Computing-in-Lean--Differentiation--Symbolic-Differentiation--Derivative-Examples">
              Derivative Examples</h2>
            <p>
              Let's put computing derivatives to some practical use. We will demonstrate how to use <strong>SciLean</strong> symbolic differentiations to solve few common tasks in scientific computing and physics.</p>
            <section>
              <h3 id="Scientific-Computing-in-Lean--Differentiation--Symbolic-Differentiation--Derivative-Examples--Newtons-solver">
                Newton's solver</h3>
              <p>
                Solving non-linear equation \( f(x) = 0 \) is a very common problem in scientific computing. Often this can be done only approximately and a popular tool to do so is Newton's method. It is an interative process that starts with an initial guess \(x₀\) which is incrementally improved by the following rule</p>
              <p>
                $$x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}
$$</p>
              <p>
                We can use Newton's method to compute sqruare root of \(y\) by choosing \( f(x) = x^2 - y\).</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-5807">def</span> <span class="const token" data-binding="const-mySqrt" data-verso-hover="229">mySqrt</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">steps</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="81">y</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span> <span class="unknown token" data-binding="">:=</span> <span class="const token" data-binding="const-Id.run" data-verso-hover="6">Id.run</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-5862">do</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-5867">let</span> <span class="var token" data-binding="var-_uniq.115" data-verso-hover="230">f</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-5876">fun</span> <span class="var token" data-binding="var-_uniq.33" data-verso-hover="81">x</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.33" data-verso-hover="81">x</span><span class="unknown token" data-binding="">^</span><span class="unknown token" data-binding="">2</span> <span class="unknown token" data-binding="">-</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="81">y</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-5895">let</span> <span class="keyword token" data-binding="kw-occ-null-5899">mut</span> <span class="var token" data-binding="var-_uniq.207" data-verso-hover="81">x</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">1.0</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-5914" data-verso-hover="8">for</span> <span class="unknown token" data-binding="">_</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doForDecl-5918">in</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">0</span><span class="unknown token" data-binding="">:</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">steps</span><span class="unknown token" data-binding="">]</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-5914" data-verso-hover="8">do</span>
    <span class="var token" data-binding="var-_uniq.207" data-verso-hover="81">x</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.207" data-verso-hover="81">x</span> <span class="unknown token" data-binding="">-</span> <span class="var token" data-binding="var-_uniq.115" data-verso-hover="230">f</span> <span class="var token" data-binding="var-_uniq.207" data-verso-hover="81">x</span> <span class="unknown token" data-binding="">/</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-deriv" data-verso-hover="231">deriv</span> <span class="var token" data-binding="var-_uniq.115" data-verso-hover="230">f</span> <span class="var token" data-binding="var-_uniq.207" data-verso-hover="81">x</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-SciLean.term_Rewrite_byAssuming__-5956">rewrite_by</span> <span class="tactic"><label for="tactic-state-17103945928595264540-5979-5995"><span class="keyword token" data-binding="kw-occ-Mathlib.Meta.FunTrans.funTransConvStx-5979">fun_trans</span><span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-deriv" data-verso-hover="231">deriv</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-17103945928595264540-5979-5995"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">steps</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="81">y</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.115" data-verso-hover="230">f</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span> → <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span> := <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.6686" data-verso-hover="81">x</span> =&gt; <span class="var token" data-binding="var-_uniq.6686" data-verso-hover="81">x</span><span class="const token" data-binding="const-HPow.hPow" data-verso-hover="224"> ^ </span>2<span class="const token" data-binding="const-HSub.hSub" data-verso-hover="225"> - </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="81">y</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.207" data-verso-hover="81">x✝¹</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span> := 1.0</td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.157" data-verso-hover="232">col✝</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Std.Range" data-verso-hover="233">Std.Range</span> := { <span class="const token" data-binding="const-Std.Range.start" data-verso-hover="234">start</span> := 0, <span class="const token" data-binding="const-Std.Range.stop" data-verso-hover="234">stop</span> := <span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">steps</span>, <span class="const token" data-binding="const-Std.Range.step" data-verso-hover="234">step</span> := 1 }</td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.201" data-verso-hover="4">x✝</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.204" data-verso-hover="81">r✝</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.207" data-verso-hover="81">x</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span> := <span class="var token" data-binding="var-_uniq.204" data-verso-hover="81">r✝</span></td></tr></table><span class="conclusion"><span class="prefix">| </span><span class="type">2<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.207" data-verso-hover="81">x</span></span></span></div></div></span><span class="unknown token" data-binding="">)</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-5999" data-verso-hover="9">return</span> <span class="var token" data-binding="var-_uniq.207" data-verso-hover="81">x</span>

<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">1.414214
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-6009">#eval</span></span> <span class="const token" data-binding="const-mySqrt" data-verso-hover="235">mySqrt</span> <span class="unknown token" data-binding="">10</span> <span class="unknown token" data-binding="">2.0</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
                <pre>1.414214
</pre></div>
              <div class="TODO">
                <p>
                  In <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-mySqrt" data-verso-hover="235">mySqrt</span></code> we should use <code>(∂! f x)</code> notation but unfortunatelly it is currently broken for some reason.</p>
                </div>
              <p>
                You might feel a bit unconfortable here are we are differentiating a function defined on floating point numbers. If you think that can't be formally correct then you are right. We will discuss this issue in a later chapter "Working with Real Numbers".</p>
              <div class="TODO">
                <p>
                  Exercise</p>
                <ol start="1">
                  <li>
                    <p>
                      try to solve different equations, for example <code>exp x = y</code> to obtain <code>log</code>, <code>x*exp x = y</code> to obtain Lambert W function or some polynomial.</p>
                    </li>
                  <li>
                    <p>
                      measure relative,\(\left| \frac{f(x_n)}{x_n} \right| \), and absolute error \( \left| f(x_n) \right| \) and use them for stopping criteria.</p>
                    </li>
                  <li>
                    <p>
                      A difficult exercise is to define a general <code>newtonSolve</code> function that takes an arbitrary function <code>f : Float → Float</code> and uring elaboration synthesizes its derivative. Add multiple hints, 1. use <code>infer_var</code> trick, 2. state explicitly how the arguments should look like</p>
                    </li>
                  </ol>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-SciLean.NotationOverField.commandSet_default_scalar_-7053">set_default_scalar</span> <span class="unknown token" data-binding="">Float</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-7078">def</span> <span class="const token" data-binding="const-newtonSolve" data-verso-hover="236">newtonSolve</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.527" data-verso-hover="4">steps</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.529" data-verso-hover="81">x₀</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span><span class="unknown token" data-binding="">)</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.533" data-verso-hover="93">f</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.537" data-verso-hover="93">f'</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span><span class="unknown token" data-binding="">}</span>
    <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.809" data-verso-hover="237">hf</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.537" data-verso-hover="93">f'</span> <span class="unknown token" data-binding="">=</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∂</span> <span class="var token" data-binding="var-_uniq.533" data-verso-hover="93">f</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.binderTactic-7195">by</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.unfold-7201" data-verso-hover="238">unfold</span> <span class="unknown token" data-binding="">deriv</span><span class="unknown token" data-binding="">;</span> <span class="keyword token" data-binding="kw-occ-Mathlib.Meta.FunTrans.funTransTacStx-7215">fun_trans</span><span class="unknown token" data-binding="">;</span> <span class="keyword token" data-binding="kw-occ-SciLean.inferVar-7226">infer_var</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span> <span class="unknown token" data-binding="">:=</span> <span class="const token" data-binding="const-Id.run" data-verso-hover="6">Id.run</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-7255">do</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-7260">let</span> <span class="keyword token" data-binding="kw-occ-null-7264">mut</span> <span class="var token" data-binding="var-_uniq.921" data-verso-hover="81">x</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.529" data-verso-hover="81">x₀</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-7280" data-verso-hover="8">for</span> <span class="unknown token" data-binding="">_</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doForDecl-7284">in</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">0</span><span class="unknown token" data-binding="">:</span><span class="var token" data-binding="var-_uniq.527" data-verso-hover="4">steps</span><span class="unknown token" data-binding="">]</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-7280" data-verso-hover="8">do</span>
    <span class="var token" data-binding="var-_uniq.921" data-verso-hover="81">x</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.921" data-verso-hover="81">x</span> <span class="unknown token" data-binding="">-</span> <span class="var token" data-binding="var-_uniq.533" data-verso-hover="93">f</span> <span class="var token" data-binding="var-_uniq.921" data-verso-hover="81">x</span> <span class="unknown token" data-binding="">/</span> <span class="var token" data-binding="var-_uniq.537" data-verso-hover="93">f'</span> <span class="var token" data-binding="var-_uniq.921" data-verso-hover="81">x</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-7328" data-verso-hover="9">return</span> <span class="var token" data-binding="var-_uniq.921" data-verso-hover="81">x</span>

<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">1.414214
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-7338">#eval</span></span> <span class="const token" data-binding="const-newtonSolve" data-verso-hover="239">newtonSolve</span> <span class="unknown token" data-binding="">10</span> <span class="unknown token" data-binding="">1.0</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-7364">fun</span> <span class="var token" data-binding="var-_uniq.1202" data-verso-hover="81">x</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.1202" data-verso-hover="81">x</span><span class="unknown token" data-binding="">^</span><span class="unknown token" data-binding="">2</span> <span class="unknown token" data-binding="">-</span> <span class="unknown token" data-binding="">2.0</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code></div>
              </section>
            <section>
              <h3 id="Scientific-Computing-in-Lean--Differentiation--Symbolic-Differentiation--Derivative-Examples--Kinematics">
                Kinematics</h3>
              <p>
                We can also use <strong>SciLean</strong>'s symbolic differentiation to prove some basic theorems from physics. For example we can state the second Newton's law</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-7614">def</span> <span class="const token" data-binding="const-NewtonSecondLaw" data-verso-hover="240">NewtonSecondLaw</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="227">x</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="227">F</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="">Prop</span> <span class="unknown token" data-binding="">:=</span>
  <span class="unknown token" data-binding="">∀</span> <span class="var token" data-binding="var-_uniq.18" data-verso-hover="222">t</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span> <span class="unknown token" data-binding="">*</span> <span class="const token" data-binding="const-deriv" data-verso-hover="231">deriv</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∂</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="227">x</span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.18" data-verso-hover="222">t</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.10" data-verso-hover="227">F</span> <span class="var token" data-binding="var-_uniq.18" data-verso-hover="222">t</span>
<span class="unknown token" data-binding=""></span></code><p>
                saying that for a particle with mass <code>m</code> under the influence of force <code>F</code> has trajectory <code>x</code> if the mass times the acceleration <code>deriv (∂ x) t</code>, i.e. the second derivative of trajectory, is equal to the force <code>F t</code>.</p>
              <p>
                We can show that under constant force <code>f</code> a particle with mass <code>m</code> has trajectory <code>(fun t =&gt; 1/2 * f/m * t^2)</code></p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-8068">example</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">f</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.37" data-verso-hover="241">hm</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span> <span class="unknown token" data-binding="">≠</span> <span class="unknown token" data-binding="">0</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
    <span class="const token" data-binding="const-NewtonSecondLaw" data-verso-hover="242">NewtonSecondLaw</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-8128">fun</span> <span class="var token" data-binding="var-_uniq.41" data-verso-hover="222">t</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">/</span><span class="unknown token" data-binding="">2</span> <span class="unknown token" data-binding="">*</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">f</span><span class="unknown token" data-binding="">/</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span> <span class="unknown token" data-binding="">*</span> <span class="var token" data-binding="var-_uniq.41" data-verso-hover="222">t</span><span class="unknown token" data-binding="">^</span><span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-8155">fun</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">f</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-11136463473028576745-8170-8172"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-8170" data-verso-hover="69">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11136463473028576745-8170-8172"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">f</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.37" data-verso-hover="241">hm</span></td><td class="colon">:</td><td class="type"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span><span class="const token" data-binding="const-Ne" data-verso-hover="243"> ≠ </span>0</td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-NewtonSecondLaw" data-verso-hover="242">NewtonSecondLaw</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.14851" data-verso-hover="222">t</span> =&gt; 1 / 2<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">f</span><span class="const token" data-binding="const-HDiv.hDiv" data-verso-hover="137"> / </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.14851" data-verso-hover="222">t</span><span class="const token" data-binding="const-HPow.hPow" data-verso-hover="224"> ^ </span>2) <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.14894" data-verso-hover="222">x</span> =&gt; <span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">f</span></span></span></div></div></span>

  <span class="tactic"><label for="tactic-state-10220475187341847376-8176-8198"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.unfold-8176" data-verso-hover="238">unfold</span> <span class="const token" data-binding="const-NewtonSecondLaw" data-verso-hover="242">NewtonSecondLaw</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-10220475187341847376-8176-8198"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">f</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.37" data-verso-hover="241">hm</span></td><td class="colon">:</td><td class="type"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span><span class="const token" data-binding="const-Ne" data-verso-hover="243"> ≠ </span>0</td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.14850" data-verso-hover="222">t</span> : <span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span>), <span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span>∂ (∂ <span class="var token" data-binding="var-_uniq.14865" data-verso-hover="222">t</span>, 1 / 2<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">f</span><span class="const token" data-binding="const-HDiv.hDiv" data-verso-hover="137"> / </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.14865" data-verso-hover="222">t</span><span class="const token" data-binding="const-HPow.hPow" data-verso-hover="224"> ^ </span>2) <span class="var token" data-binding="var-_uniq.14850" data-verso-hover="222">t</span><span class="const token" data-binding="const-Eq" data-verso-hover="72"> = </span>(<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.14903" data-verso-hover="222">x</span> =&gt; <span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">f</span>) <span class="var token" data-binding="var-_uniq.14850" data-verso-hover="222">t</span></span></span></div></div></span>
  -- compute derivatives
  <span class="tactic"><label for="tactic-state-2773839945280178276-8226-8243"><span class="keyword token" data-binding="kw-occ-Mathlib.Meta.FunTrans.funTransTacStx-8226">fun_trans</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-deriv" data-verso-hover="231">deriv</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-2773839945280178276-8226-8243"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">f</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.37" data-verso-hover="241">hm</span></td><td class="colon">:</td><td class="type"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span><span class="const token" data-binding="const-Ne" data-verso-hover="243"> ≠ </span>0</td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span>(2<span class="const token" data-binding="const-Inv.inv" data-verso-hover="244">⁻¹</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">f</span><span class="const token" data-binding="const-HDiv.hDiv" data-verso-hover="137"> / </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span>2)<span class="const token" data-binding="const-Eq" data-verso-hover="72"> = </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">f</span></span></span></div></div></span>
  -- finish algebraic simplifications
  <span class="tactic"><label for="tactic-state-13705107788213365195-8284-8294"><span class="keyword token" data-binding="kw-occ-Mathlib.Tactic.FieldSimp.fieldSimp-8284" data-verso-hover="245">field_simp</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-13705107788213365195-8284-8294"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">f</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.37" data-verso-hover="241">hm</span></td><td class="colon">:</td><td class="type"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span><span class="const token" data-binding="const-Ne" data-verso-hover="243"> ≠ </span>0</td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span>(<span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">f</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span>2)<span class="const token" data-binding="const-Eq" data-verso-hover="72"> = </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">f</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span>(2<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span>)</span></span></div></div></span><span class="unknown token" data-binding="">;</span> <span class="tactic"><label for="tactic-state-7-8296-8300"><span class="keyword token" data-binding="kw-occ-Mathlib.Tactic.RingNF.ring-8296" data-verso-hover="246">ring</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-8296-8300"><div class="tactic-state">All goals completed! 🐙</div></span>
<span class="unknown token" data-binding=""></span></code><div class="TODO">
                <p>
                  <strong>Warning</strong>: currently the tactic <code>fun_trans</code> uses theorems that are not fully proven therefore the above proof is not completely formal proof. If you do not like this you are welcome to improve SciLean by helping out proving its theorems. Lots of theorems should be just matter of finding the right mathlib theorem.</p>
                </div>
              <div class="TODO">
                <p>
                  Exercises:</p>
                <ol start="1">
                  <li>
                    <p>
                      show that trajectory <code>x := fun t =&gt; (cos t, sin t)</code> satisfies differential equation <code>∂ x t = (- (x t).2, (x t).1)</code></p>
                    </li>
                  </ol>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-8790" data-verso-hover="13">open</span> <span class="unknown token" data-binding="">SciLean</span> <span class="unknown token" data-binding="">Scalar</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-8810">def</span> <span class="const token" data-binding="const-ode" data-verso-hover="247">ode</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="248">x</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">×</span><span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">∀</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="222">t</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-deriv" data-verso-hover="231">deriv</span> <span class="var token" data-binding="var-_uniq.6" data-verso-hover="248">x</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="222">t</span> <span class="unknown token" data-binding="">=</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">-</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="248">x</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="222">t</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="248">x</span> <span class="var token" data-binding="var-_uniq.14" data-verso-hover="222">t</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">)</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-8885">example</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-ode" data-verso-hover="249">ode</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-8900">fun</span> <span class="var token" data-binding="var-_uniq.304" data-verso-hover="222">t</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-SciLean.Scalar.cos" data-verso-hover="250">cos</span> <span class="var token" data-binding="var-_uniq.304" data-verso-hover="222">t</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-SciLean.Scalar.sin" data-verso-hover="251">sin</span> <span class="var token" data-binding="var-_uniq.304" data-verso-hover="222">t</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-556938093835688537-8928-8930"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-8928" data-verso-hover="69">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-556938093835688537-8928-8930"><div class="tactic-state"><div class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-ode" data-verso-hover="249">ode</span> <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.3247" data-verso-hover="222">t</span> =&gt; (<span class="const token" data-binding="const-SciLean.Scalar.cos" data-verso-hover="250">cos</span> <span class="var token" data-binding="var-_uniq.3247" data-verso-hover="222">t</span>, <span class="const token" data-binding="const-SciLean.Scalar.sin" data-verso-hover="251">sin</span> <span class="var token" data-binding="var-_uniq.3247" data-verso-hover="222">t</span>)</span></span></div></div></span> <span class="tactic"><label for="tactic-state-18219262327836496261-8931-8947"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.unfold-8931" data-verso-hover="238">unfold</span> <span class="const token" data-binding="const-ode" data-verso-hover="249">ode</span> <span class="const token" data-binding="const-deriv" data-verso-hover="231">deriv</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-18219262327836496261-8931-8947"><div class="tactic-state"><div class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.3247" data-verso-hover="222">t</span> : <span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span>), (∂ (<span class="var token" data-binding="var-_uniq.3248" data-verso-hover="222">t</span>:=<span class="var token" data-binding="var-_uniq.3247" data-verso-hover="222">t</span>), (<span class="const token" data-binding="const-SciLean.Scalar.cos" data-verso-hover="250">cos</span> <span class="var token" data-binding="var-_uniq.3248" data-verso-hover="222">t</span>, <span class="const token" data-binding="const-SciLean.Scalar.sin" data-verso-hover="251">sin</span> <span class="var token" data-binding="var-_uniq.3248" data-verso-hover="222">t</span>)) 1<span class="const token" data-binding="const-Eq" data-verso-hover="72"> = </span>(<span class="const token" data-binding="const-Neg.neg" data-verso-hover="168">-</span>((<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.3276" data-verso-hover="222">t</span> =&gt; (<span class="const token" data-binding="const-SciLean.Scalar.cos" data-verso-hover="250">cos</span> <span class="var token" data-binding="var-_uniq.3276" data-verso-hover="222">t</span>, <span class="const token" data-binding="const-SciLean.Scalar.sin" data-verso-hover="251">sin</span> <span class="var token" data-binding="var-_uniq.3276" data-verso-hover="222">t</span>)) <span class="var token" data-binding="var-_uniq.3247" data-verso-hover="222">t</span>).2, ((<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.3289" data-verso-hover="222">t</span> =&gt; (<span class="const token" data-binding="const-SciLean.Scalar.cos" data-verso-hover="250">cos</span> <span class="var token" data-binding="var-_uniq.3289" data-verso-hover="222">t</span>, <span class="const token" data-binding="const-SciLean.Scalar.sin" data-verso-hover="251">sin</span> <span class="var token" data-binding="var-_uniq.3289" data-verso-hover="222">t</span>)) <span class="var token" data-binding="var-_uniq.3247" data-verso-hover="222">t</span>).1)</span></span></div></div></span><span class="unknown token" data-binding="">;</span> <span class="tactic"><label for="tactic-state-7-8949-8958"><span class="keyword token" data-binding="kw-occ-Mathlib.Meta.FunTrans.funTransTacStx-8949">fun_trans</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-8949-8958"><div class="tactic-state">All goals completed! 🐙</div></span>
<span class="unknown token" data-binding=""></span></code><ol start="2">
                  <li>
                    <p>
                      show that trajectory <code>x := fun t =&gt; sin (ω*t)</code> correspond to the force <code>f := fun t =&gt; - k * x t</code> with <code>ω = sqrt (k/m)</code></p>
                    </li>
                  </ol>
                <p>
                  Hint: After differentiation you will have to show that \(m \sqrt{\frac{k}{m}}^2 = k\). Unfortunatelly Lean is not yet very powerful computer algebra system. So you can finish the proof with</p>
                <pre>  ring_nf --  m * (sqrt (k / m) * (sqrt (k / m) ==&gt; m * sqrt (k * m⁻¹) ^ 2
  have h : m * sqrt (k * m⁻¹) ^ 2 = k := sorry_proof
  simp[h]
</pre><p>
                  where we call <code>ring_nf</code> to clean up the expression, then we just assume that <code> m * sqrt (k * m⁻¹) ^ 2</code> is equal to <code>k</code> and finally we can finish the proof by running simp</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-9623" data-verso-hover="13">open</span> <span class="unknown token" data-binding="">SciLean</span> <span class="unknown token" data-binding="">Scalar</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-9644">example</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">k</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-9670" data-verso-hover="80">let</span> <span class="var token" data-binding="var-_uniq.108" data-verso-hover="222">ω</span> <span class="unknown token" data-binding="">:=</span> <span class="const token" data-binding="const-SciLean.Scalar.sqrt" data-verso-hover="95">sqrt</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">k</span><span class="unknown token" data-binding="">/</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span><span class="unknown token" data-binding="">)</span>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-9695" data-verso-hover="80">let</span> <span class="var token" data-binding="var-_uniq.187" data-verso-hover="227">x</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-9704">fun</span> <span class="var token" data-binding="var-_uniq.113" data-verso-hover="222">t</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-SciLean.Scalar.sin" data-verso-hover="251">sin</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.108" data-verso-hover="222">ω</span><span class="unknown token" data-binding="">*</span><span class="var token" data-binding="var-_uniq.113" data-verso-hover="222">t</span><span class="unknown token" data-binding="">)</span>
    <span class="const token" data-binding="const-NewtonSecondLaw" data-verso-hover="242">NewtonSecondLaw</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span> <span class="var token" data-binding="var-_uniq.187" data-verso-hover="227">x</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-9749">fun</span> <span class="var token" data-binding="var-_uniq.191" data-verso-hover="222">t</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">-</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">k</span><span class="unknown token" data-binding="">*</span><span class="var token" data-binding="var-_uniq.187" data-verso-hover="227">x</span> <span class="var token" data-binding="var-_uniq.191" data-verso-hover="222">t</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-5527738589373119154-9770-9772"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-9770" data-verso-hover="69">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5527738589373119154-9770-9772"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">k</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.19254" data-verso-hover="222">ω</span> := <span class="const token" data-binding="const-SciLean.Scalar.sqrt" data-verso-hover="95">sqrt</span> (<span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">k</span><span class="const token" data-binding="const-HDiv.hDiv" data-verso-hover="137"> / </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span>);
<span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.19273" data-verso-hover="227">x</span> := <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.19256" data-verso-hover="222">t</span> =&gt; <span class="const token" data-binding="const-SciLean.Scalar.sin" data-verso-hover="251">sin</span> (<span class="var token" data-binding="var-_uniq.19254" data-verso-hover="222">ω</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.19256" data-verso-hover="222">t</span>);
<span class="const token" data-binding="const-NewtonSecondLaw" data-verso-hover="242">NewtonSecondLaw</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span> <span class="var token" data-binding="var-_uniq.19273" data-verso-hover="227">x</span> <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.19275" data-verso-hover="222">t</span> =&gt; <span class="const token" data-binding="const-Neg.neg" data-verso-hover="168">-</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">k</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.19273" data-verso-hover="227">x</span> <span class="var token" data-binding="var-_uniq.19275" data-verso-hover="222">t</span></span></span></div></div></span>

  <span class="tactic"><label for="tactic-state-17029044180312848375-9776-9804"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.unfold-9776" data-verso-hover="238">unfold</span> <span class="const token" data-binding="const-NewtonSecondLaw" data-verso-hover="242">NewtonSecondLaw</span> <span class="const token" data-binding="const-deriv" data-verso-hover="231">deriv</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-17029044180312848375-9776-9804"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">k</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.19254" data-verso-hover="222">ω</span> := <span class="const token" data-binding="const-SciLean.Scalar.sqrt" data-verso-hover="95">sqrt</span> (<span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">k</span><span class="const token" data-binding="const-HDiv.hDiv" data-verso-hover="137"> / </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span>);
<span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.19273" data-verso-hover="227">x</span> := <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.19256" data-verso-hover="222">t</span> =&gt; <span class="const token" data-binding="const-SciLean.Scalar.sin" data-verso-hover="251">sin</span> (<span class="var token" data-binding="var-_uniq.19254" data-verso-hover="222">ω</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.19256" data-verso-hover="222">t</span>);
∀ (<span class="var token" data-binding="var-_uniq.19274" data-verso-hover="222">t</span> : <span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span>), <span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span>(∂ (<span class="var token" data-binding="var-_uniq.19282" data-verso-hover="222">x_1</span>:=<span class="var token" data-binding="var-_uniq.19274" data-verso-hover="222">t</span>), (∂ <span class="var token" data-binding="var-_uniq.19273" data-verso-hover="227">x</span> <span class="var token" data-binding="var-_uniq.19282" data-verso-hover="222">x_1</span>) 1) 1<span class="const token" data-binding="const-Eq" data-verso-hover="72"> = </span>(<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.19284" data-verso-hover="222">t</span> =&gt; <span class="const token" data-binding="const-Neg.neg" data-verso-hover="168">-</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">k</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.19273" data-verso-hover="227">x</span> <span class="var token" data-binding="var-_uniq.19284" data-verso-hover="222">t</span>) <span class="var token" data-binding="var-_uniq.19274" data-verso-hover="222">t</span></span></span></div></div></span>
  <span class="tactic"><label for="tactic-state-14008120453948222803-9807-9816"><span class="keyword token" data-binding="kw-occ-Mathlib.Meta.FunTrans.funTransTacStx-9807">fun_trans</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14008120453948222803-9807-9816"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">k</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.19234" data-verso-hover="222">t</span> : <span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span>), <span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span>(<span class="const token" data-binding="const-SciLean.Scalar.sqrt" data-verso-hover="95">sqrt</span> (<span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">k</span><span class="const token" data-binding="const-HDiv.hDiv" data-verso-hover="137"> / </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span>)<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span>(<span class="const token" data-binding="const-SciLean.Scalar.sqrt" data-verso-hover="95">sqrt</span> (<span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">k</span><span class="const token" data-binding="const-HDiv.hDiv" data-verso-hover="137"> / </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span>)<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="const token" data-binding="const-SciLean.Scalar.sin" data-verso-hover="251">sin</span> (<span class="const token" data-binding="const-SciLean.Scalar.sqrt" data-verso-hover="95">sqrt</span> (<span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">k</span><span class="const token" data-binding="const-HDiv.hDiv" data-verso-hover="137"> / </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span>)<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.19234" data-verso-hover="222">t</span>)))<span class="const token" data-binding="const-Eq" data-verso-hover="72"> = </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">k</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="const token" data-binding="const-SciLean.Scalar.sin" data-verso-hover="251">sin</span> (<span class="const token" data-binding="const-SciLean.Scalar.sqrt" data-verso-hover="95">sqrt</span> (<span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">k</span><span class="const token" data-binding="const-HDiv.hDiv" data-verso-hover="137"> / </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span>)<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.19234" data-verso-hover="222">t</span>)</span></span></div></div></span>
  <span class="tactic"><label for="tactic-state-7640825659365990867-9819-9826"><span class="keyword token" data-binding="kw-occ-Mathlib.Tactic.RingNF.ringNF-9819" data-verso-hover="252">ring_nf</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7640825659365990867-9819-9826"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">k</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.19234" data-verso-hover="222">t</span> : <span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span>), <span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="const token" data-binding="const-SciLean.Scalar.sqrt" data-verso-hover="95">sqrt</span> (<span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">k</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span><span class="const token" data-binding="const-Inv.inv" data-verso-hover="244">⁻¹</span>)<span class="const token" data-binding="const-HPow.hPow" data-verso-hover="224"> ^ </span>2<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="const token" data-binding="const-SciLean.Scalar.sin" data-verso-hover="251">sin</span> (<span class="const token" data-binding="const-SciLean.Scalar.sqrt" data-verso-hover="95">sqrt</span> (<span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">k</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span><span class="const token" data-binding="const-Inv.inv" data-verso-hover="244">⁻¹</span>)<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.19234" data-verso-hover="222">t</span>)<span class="const token" data-binding="const-Eq" data-verso-hover="72"> = </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">k</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="const token" data-binding="const-SciLean.Scalar.sin" data-verso-hover="251">sin</span> (<span class="const token" data-binding="const-SciLean.Scalar.sqrt" data-verso-hover="95">sqrt</span> (<span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">k</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span><span class="const token" data-binding="const-Inv.inv" data-verso-hover="244">⁻¹</span>)<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.19234" data-verso-hover="222">t</span>)</span></span></div></div></span>
  <span class="tactic"><label for="tactic-state-9621195212371140539-9829-9882"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave_-9829" data-verso-hover="253">have</span> <span class="var token" data-binding="var-_uniq.19078" data-verso-hover="254">h</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span> <span class="unknown token" data-binding="">*</span> <span class="const token" data-binding="const-SciLean.Scalar.sqrt" data-verso-hover="95">sqrt</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">k</span> <span class="unknown token" data-binding="">*</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span><span class="unknown token" data-binding="">⁻¹</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">^</span> <span class="unknown token" data-binding="">2</span> <span class="unknown token" data-binding="">=</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">k</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-SciLean.termSorry_proof-9871" data-verso-hover="67">sorry_proof</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-9621195212371140539-9829-9882"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">k</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.19078" data-verso-hover="254">h</span></td><td class="colon">:</td><td class="type"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="const token" data-binding="const-SciLean.Scalar.sqrt" data-verso-hover="95">sqrt</span> (<span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">k</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span><span class="const token" data-binding="const-Inv.inv" data-verso-hover="244">⁻¹</span>)<span class="const token" data-binding="const-HPow.hPow" data-verso-hover="224"> ^ </span>2<span class="const token" data-binding="const-Eq" data-verso-hover="72"> = </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">k</span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.19234" data-verso-hover="222">t</span> : <span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span>), <span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="const token" data-binding="const-SciLean.Scalar.sqrt" data-verso-hover="95">sqrt</span> (<span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">k</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span><span class="const token" data-binding="const-Inv.inv" data-verso-hover="244">⁻¹</span>)<span class="const token" data-binding="const-HPow.hPow" data-verso-hover="224"> ^ </span>2<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="const token" data-binding="const-SciLean.Scalar.sin" data-verso-hover="251">sin</span> (<span class="const token" data-binding="const-SciLean.Scalar.sqrt" data-verso-hover="95">sqrt</span> (<span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">k</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span><span class="const token" data-binding="const-Inv.inv" data-verso-hover="244">⁻¹</span>)<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.19234" data-verso-hover="222">t</span>)<span class="const token" data-binding="const-Eq" data-verso-hover="72"> = </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">k</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="const token" data-binding="const-SciLean.Scalar.sin" data-verso-hover="251">sin</span> (<span class="const token" data-binding="const-SciLean.Scalar.sqrt" data-verso-hover="95">sqrt</span> (<span class="var token" data-binding="var-_uniq.4" data-verso-hover="222">k</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">m</span><span class="const token" data-binding="const-Inv.inv" data-verso-hover="244">⁻¹</span>)<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.19234" data-verso-hover="222">t</span>)</span></span></div></div></span>
  <span class="tactic"><label for="tactic-state-7-9885-9892"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-9885" data-verso-hover="185">simp</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.19078" data-verso-hover="254">h</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-9885-9892"><div class="tactic-state">All goals completed! 🐙</div></span>
<span class="unknown token" data-binding=""></span></code><p>
                  Warning: Right now <code>fun_trans</code> uses theorems that use sorry thus the theorem is not fully proven.</p>
                </div>
              </section>
            </section>
          <section>
            <h2 id="Scientific-Computing-in-Lean--Differentiation--Symbolic-Differentiation--Gradient">
              Gradient</h2>
            <p>
              In many practical applications, we need to compute gradient instead of directional derivative. For a function \(f : \mathbb{R}^n \rightarrow \mathbb{R} \) the gradient of \(f\) is a vector of all its partial derivatives</p>
            <p>
              $$\nabla f = \left(\frac{\partial f}{\partial x_1}, \dots, \frac{\partial f}{\partial x_n} \right)
$$</p>
            <p>
              A more general way of defining gradient is through linear map transposition/adjoint. The derivative of a function <code>(f : X → ℝ)</code> at point <code>x</code> is a linear map from <code>X</code> to <code>ℝ</code></p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-10565" data-verso-hover="13">open</span> <span class="unknown token" data-binding="">SciLean</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-10578" data-verso-hover="52">variable</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.662" data-verso-hover="255">X</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-NormedAddCommGroup" data-verso-hover="256">NormedAddCommGroup</span> <span class="var token" data-binding="var-_uniq.662" data-verso-hover="255">X</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-AdjointSpace" data-verso-hover="257">AdjointSpace</span> <span class="unknown token" data-binding="">ℝ</span> <span class="var token" data-binding="var-_uniq.662" data-verso-hover="255">X</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-CompleteSpace" data-verso-hover="258">CompleteSpace</span> <span class="var token" data-binding="var-_uniq.662" data-verso-hover="255">X</span><span class="unknown token" data-binding="">]</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-10653" data-verso-hover="52">variable</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1322" data-verso-hover="259">f</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.662" data-verso-hover="260">X</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1324" data-verso-hover="261">x</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.662" data-verso-hover="260">X</span><span class="unknown token" data-binding="">)</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">∂ f x : X →L[ℝ] ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-10686">#check</span></span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∂</span> <span class="var token" data-binding="var-_uniq.1322" data-verso-hover="259">f</span> <span class="var token" data-binding="var-_uniq.1324" data-verso-hover="261">x</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
              <pre>∂ f x : X →L[ℝ] ℝ
</pre></div>
            <p>
              To obtain gradient we take an adjoint and evaluate it at one. This is exactly how gradient is defined.</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-10875" data-verso-hover="13">open</span> <span class="unknown token" data-binding="">SciLean</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-10888" data-verso-hover="52">variable</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.662" data-verso-hover="255">X</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-NormedAddCommGroup" data-verso-hover="256">NormedAddCommGroup</span> <span class="var token" data-binding="var-_uniq.662" data-verso-hover="255">X</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-AdjointSpace" data-verso-hover="257">AdjointSpace</span> <span class="unknown token" data-binding="">ℝ</span> <span class="var token" data-binding="var-_uniq.662" data-verso-hover="255">X</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-CompleteSpace" data-verso-hover="258">CompleteSpace</span> <span class="var token" data-binding="var-_uniq.662" data-verso-hover="255">X</span><span class="unknown token" data-binding="">]</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-10963" data-verso-hover="52">variable</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1322" data-verso-hover="259">f</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.662" data-verso-hover="260">X</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1324" data-verso-hover="261">x</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.662" data-verso-hover="260">X</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-10996">example</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∇</span> <span class="var token" data-binding="var-_uniq.1322" data-verso-hover="259">f</span> <span class="var token" data-binding="var-_uniq.1324" data-verso-hover="261">x</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span> <span class="const token" data-binding="const-adjoint" data-verso-hover="262">adjoint</span> <span class="unknown token" data-binding="">ℝ</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∂</span> <span class="var token" data-binding="var-_uniq.1322" data-verso-hover="259">f</span> <span class="var token" data-binding="var-_uniq.1324" data-verso-hover="261">x</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-14200650673733438145-11045-11047"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-11045" data-verso-hover="69">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14200650673733438145-11045-11047"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.662" data-verso-hover="263">X</span></td><td class="colon">:</td><td class="type"><span class="sort token" data-binding="">Type u_1</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.1330" data-verso-hover="264">inst✝²</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-NormedAddCommGroup" data-verso-hover="256">NormedAddCommGroup</span> <span class="var token" data-binding="var-_uniq.662" data-verso-hover="263">X</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.1348" data-verso-hover="265">inst✝¹</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-AdjointSpace" data-verso-hover="257">AdjointSpace</span> <span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span> <span class="var token" data-binding="var-_uniq.662" data-verso-hover="263">X</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.1983" data-verso-hover="266">inst✝</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-CompleteSpace" data-verso-hover="258">CompleteSpace</span> <span class="var token" data-binding="var-_uniq.662" data-verso-hover="263">X</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.1322" data-verso-hover="259">f</span></td><td class="colon">:</td><td class="type"><span class="var token" data-binding="var-_uniq.662" data-verso-hover="263">X</span> → <span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.1324" data-verso-hover="261">x</span></td><td class="colon">:</td><td class="type"><span class="var token" data-binding="var-_uniq.662" data-verso-hover="263">X</span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type">∇ <span class="var token" data-binding="var-_uniq.1322" data-verso-hover="259">f</span> <span class="var token" data-binding="var-_uniq.1324" data-verso-hover="261">x</span><span class="const token" data-binding="const-Eq" data-verso-hover="72"> = </span><span class="const token" data-binding="const-adjoint" data-verso-hover="262">adjoint</span> <span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span> (⇑(∂ <span class="var token" data-binding="var-_uniq.1322" data-verso-hover="259">f</span> <span class="var token" data-binding="var-_uniq.1324" data-verso-hover="261">x</span>)) 1</span></span></div></div></span> <span class="tactic"><label for="tactic-state-7-11048-11051"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRfl-11048" data-verso-hover="267">rfl</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-11048-11051"><div class="tactic-state">All goals completed! 🐙</div></span>
<span class="unknown token" data-binding=""></span></code><p>
              This coincides with the standard notion of gradient that it is a vector of all its partial derivatives. For example for <code>n=2</code> we have</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-11199" data-verso-hover="13">open</span> <span class="unknown token" data-binding="">SciLean</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-11212" data-verso-hover="52">variable</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="4">n</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="228">f</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">×</span><span class="unknown token" data-binding="">ℝ</span> <span class="unknown token" data-binding="">→</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.300" data-verso-hover="268">hf</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Differentiable" data-verso-hover="269">Differentiable</span> <span class="unknown token" data-binding="">ℝ</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="228">f</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.302" data-verso-hover="222">x</span> <span class="var token" data-binding="var-_uniq.304" data-verso-hover="222">y</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-11294">example</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∇</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="228">f</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.302" data-verso-hover="222">x</span><span class="unknown token" data-binding="">,</span><span class="var token" data-binding="var-_uniq.304" data-verso-hover="222">y</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∂</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.740" data-verso-hover="222">x'</span><span class="unknown token" data-binding="">:=</span><span class="var token" data-binding="var-_uniq.302" data-verso-hover="222">x</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="228">f</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.740" data-verso-hover="222">x'</span><span class="unknown token" data-binding="">,</span><span class="var token" data-binding="var-_uniq.304" data-verso-hover="222">y</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">∂</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.768" data-verso-hover="222">y'</span><span class="unknown token" data-binding="">:=</span><span class="var token" data-binding="var-_uniq.304" data-verso-hover="222">y</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="228">f</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.302" data-verso-hover="222">x</span><span class="unknown token" data-binding="">,</span><span class="var token" data-binding="var-_uniq.768" data-verso-hover="222">y'</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-SciLean.termSorry_proof-11370" data-verso-hover="67">sorry_proof</span>
<span class="unknown token" data-binding=""></span></code><div class="TODO">
              <p>
                <strong>Warning for mathlib users</strong>: SciLean defines its own version of <code>adjoint</code> and <code>gradient</code>. The reason is that the product type <code>ℝ×ℝ</code> and function type <code>Fin n → ℝ</code> are not <code>InnerProductSpace</code> and therefore it is impossible do use mathlibs <code>gradient</code> on functions of type <code>ℝ×ℝ → ℝ</code> or <code>(Fin n → ℝ) → ℝ</code>. Mathlib's advice is to use <code>WithLp 2 (ℝ×ℝ)</code> or <code>EuclidianSpace n</code> however this is seriously inconvenient for people that just want to write some code.</p>
              <p>
                SciLean solution to this is to introduce new typeclass <code>AdjointSpace ℝ X</code> that is almost the same as <code>InnerProductSpace ℝ X</code> but requires that the norm induced by inner product, <code>‖x‖₂ = ⟪x,x⟫</code>, is topologically equivalent to the norm <code>‖x‖</code>. This way we can provide instance of <code>AdjointSpace ℝ (X×Y)</code> and <code>AdjointSpace ℝ (ι → X)</code> without causing issues.</p>
              </div>
            <p>
              Few examples of of computing gradients</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-12330" data-verso-hover="52">variable</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="226">x₀</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">×</span><span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">(1, 0) : ℝ × ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-12357">#check</span></span> <span class="unknown token" data-binding="">∇!</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="226">x</span><span class="unknown token" data-binding="">:=</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="226">x₀</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.13" data-verso-hover="226">x</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">1</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
              <pre>(1, 0) : ℝ × ℝ
</pre></div>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-12461" data-verso-hover="52">variable</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="226">x₀</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">×</span><span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">2 • x₀ : ℝ × ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-12488">#check</span></span> <span class="unknown token" data-binding="">∇!</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="226">x</span><span class="unknown token" data-binding="">:=</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="226">x₀</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">‖</span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="226">x</span><span class="unknown token" data-binding="">‖₂²</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
              <pre>2 • x₀ : ℝ × ℝ
</pre></div>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-12607" data-verso-hover="52">variable</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="226">x₀</span> <span class="var token" data-binding="var-_uniq.8" data-verso-hover="226">y</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">×</span><span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">y : ℝ × ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-12636">#check</span></span> <span class="unknown token" data-binding="">∇!</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.21" data-verso-hover="226">x</span><span class="unknown token" data-binding="">:=</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="226">x₀</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">⟪</span><span class="var token" data-binding="var-_uniq.21" data-verso-hover="226">x</span><span class="unknown token" data-binding="">,</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="226">y</span><span class="unknown token" data-binding="">⟫</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
              <pre>y : ℝ × ℝ
</pre></div>
            <div class="TODO">
              <p>
                Exercises</p>
              <ol start="1">
                <li>
                  <p>
                    Previously we computed \(\sqrt{y}\) using Newton's method. Similarly we can <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-mySqrt" data-verso-hover="235">mySqrt</span></code> Compute <code>sqrt y</code> using gradient descent by minimizing objective function <code>f := fun x =&gt; (x^2 - y)^2</code></p>
                  </li>
                <li>
                  <p>
                    Linear regression via gradient descent
   <code>x : Float^[2]^[n]</code> <code>y : Float^[2]^[n]</code>
   <code>fun := fun (A : Float^[2,2]) =&gt; ∑ i, ‖ ⊞ i' =&gt; ∑ j, A[i',j] * x[i][j] - y[i]‖₂²</code></p>
                  </li>
                </ol>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-SciLean.NotationOverField.commandSet_default_scalar_-13132">set_default_scalar</span> <span class="unknown token" data-binding="">Float</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-13158" data-verso-hover="52">variable</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.527" data-verso-hover="4">n</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Nat" data-verso-hover="5">Nat</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.583" data-verso-hover="270">x</span> <span class="var token" data-binding="var-_uniq.592" data-verso-hover="270">y</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span><span class="unknown token" data-binding="">^[</span><span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">^[</span><span class="var token" data-binding="var-_uniq.527" data-verso-hover="4">n</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span>

<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">fun x_1 =&gt;
  SciLean.IndexType.foldl
    (fun dx i =&gt;
      SciLean.IndexType.foldl
        (fun dx i_1 =&gt;
          SciLean.IndexType.foldl
            (fun dx i_2 =&gt;
              SciLean.ArrayType.modify dx (i_1, i_2) fun xi =&gt;
                xi + x[i][i_2] * (2 * ( ∑ i_3, x_1[i_1, i_3] * x[i][i_3] - y[i][i_1])))
            dx)
        dx)
    0 : Float^[2, 2] → Float^[2, 2]</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-13200">#check</span></span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∇</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.685" data-verso-hover="271">A</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span><span class="unknown token" data-binding="">^[</span><span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">,</span><span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">∑</span> <span class="var token" data-binding="var-_uniq.1034" data-verso-hover="32">i</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">‖</span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">⊞</span> <span class="var token" data-binding="var-_uniq.1087" data-verso-hover="96">i'</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">∑</span> <span class="var token" data-binding="var-_uniq.1097" data-verso-hover="96">j</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.685" data-verso-hover="271">A</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.1087" data-verso-hover="96">i'</span><span class="unknown token" data-binding="">,</span><span class="var token" data-binding="var-_uniq.1097" data-verso-hover="96">j</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">*</span> <span class="var token" data-binding="var-_uniq.583" data-verso-hover="270">x</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.1034" data-verso-hover="32">i</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.1097" data-verso-hover="96">j</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">-</span> <span class="var token" data-binding="var-_uniq.592" data-verso-hover="270">y</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.1034" data-verso-hover="32">i</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">‖₂²</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-SciLean.term_Rewrite_byAssuming__-13207">rewrite_by</span> <span class="tactic"><label for="tactic-state-10895220449835783338-13305-13329"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.Conv.unfold-13305" data-verso-hover="272">unfold</span> <span class="const token" data-binding="const-SciLean.fgradient" data-verso-hover="273">SciLean.fgradient</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-10895220449835783338-13305-13329"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.527" data-verso-hover="4">n</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.583" data-verso-hover="270">x</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>^[2]^[<span class="var token" data-binding="var-_uniq.527" data-verso-hover="4">n</span>]</td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.592" data-verso-hover="270">y</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>^[2]^[<span class="var token" data-binding="var-_uniq.527" data-verso-hover="4">n</span>]</td></tr></table><span class="conclusion"><span class="prefix">| </span><span class="type"><span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.22877" data-verso-hover="271">x_1</span> =&gt; (&lt;∂ (<span class="var token" data-binding="var-_uniq.22891" data-verso-hover="271">A</span>:=<span class="var token" data-binding="var-_uniq.22877" data-verso-hover="271">x_1</span>), ∑ <span class="var token" data-binding="var-_uniq.22906" data-verso-hover="32">i</span>, ‖(⊞ <span class="var token" data-binding="var-_uniq.22939" data-verso-hover="96">i'</span> =&gt; ∑ <span class="var token" data-binding="var-_uniq.22947" data-verso-hover="96">j</span>, <span class="var token" data-binding="var-_uniq.22891" data-verso-hover="271">A</span>[<span class="var token" data-binding="var-_uniq.22939" data-verso-hover="96">i'</span>, <span class="var token" data-binding="var-_uniq.22947" data-verso-hover="96">j</span>]<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.583" data-verso-hover="270">x</span>[<span class="var token" data-binding="var-_uniq.22906" data-verso-hover="32">i</span>][<span class="var token" data-binding="var-_uniq.22947" data-verso-hover="96">j</span>])<span class="const token" data-binding="const-HSub.hSub" data-verso-hover="225"> - </span><span class="var token" data-binding="var-_uniq.592" data-verso-hover="270">y</span>[<span class="var token" data-binding="var-_uniq.22906" data-verso-hover="32">i</span>]‖₂²).2 1</span></span></div></div></span><span class="unknown token" data-binding="">;</span> <span class="tactic"><label for="tactic-state-12566003252554421725-13331-13340"><span class="keyword token" data-binding="kw-occ-Mathlib.Meta.FunTrans.funTransConvStx-13331">fun_trans</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12566003252554421725-13331-13340"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.527" data-verso-hover="4">n</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.583" data-verso-hover="270">x</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>^[2]^[<span class="var token" data-binding="var-_uniq.527" data-verso-hover="4">n</span>]</td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.592" data-verso-hover="270">y</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>^[2]^[<span class="var token" data-binding="var-_uniq.527" data-verso-hover="4">n</span>]</td></tr></table><span class="conclusion"><span class="prefix">| </span><span class="type"><span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.22877" data-verso-hover="271">x_1</span> =&gt;
  <span class="const token" data-binding="const-SciLean.IndexType.foldl" data-verso-hover="274">SciLean.IndexType.foldl</span>
    (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.22893" data-verso-hover="271">dx</span> <span class="var token" data-binding="var-_uniq.22895" data-verso-hover="32">i</span> =&gt;
      <span class="const token" data-binding="const-SciLean.IndexType.foldl" data-verso-hover="274">SciLean.IndexType.foldl</span>
        (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.22904" data-verso-hover="271">dx</span> <span class="var token" data-binding="var-_uniq.22906" data-verso-hover="96">i_1</span> =&gt;
          <span class="const token" data-binding="const-SciLean.IndexType.foldl" data-verso-hover="274">SciLean.IndexType.foldl</span>
            (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.22915" data-verso-hover="271">dx</span> <span class="var token" data-binding="var-_uniq.22917" data-verso-hover="96">i_2</span> =&gt;
              <span class="const token" data-binding="const-SciLean.ArrayType.modify" data-verso-hover="275">SciLean.ArrayType.modify</span> <span class="var token" data-binding="var-_uniq.22915" data-verso-hover="271">dx</span> (<span class="var token" data-binding="var-_uniq.22906" data-verso-hover="96">i_1</span>, <span class="var token" data-binding="var-_uniq.22917" data-verso-hover="96">i_2</span>) <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.22938" data-verso-hover="81">xi</span> =&gt;
                <span class="var token" data-binding="var-_uniq.22938" data-verso-hover="81">xi</span><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="141"> +
                  </span><span class="var token" data-binding="var-_uniq.583" data-verso-hover="270">x</span>[<span class="var token" data-binding="var-_uniq.22895" data-verso-hover="32">i</span>][<span class="var token" data-binding="var-_uniq.22917" data-verso-hover="96">i_2</span>]<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> *
                    </span>(<span class="const token" data-binding="const-SciLean.revFDerivProj" data-verso-hover="276">SciLean.revFDerivProj</span> <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span> <span class="const token" data-binding="const-Unit" data-verso-hover="277">Unit</span> (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.22999" data-verso-hover="278">x4</span> =&gt; <span class="const token" data-binding="const-SciLean.ArrayType.ofFn" data-verso-hover="279">SciLean.ArrayType.ofFn</span> <span class="var token" data-binding="var-_uniq.22999" data-verso-hover="278">x4</span>) <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.23013" data-verso-hover="96">i_3</span> =&gt;
                           ∑ <span class="var token" data-binding="var-_uniq.23028" data-verso-hover="96">i_4</span>, <span class="var token" data-binding="var-_uniq.22877" data-verso-hover="271">x_1</span>[<span class="var token" data-binding="var-_uniq.23013" data-verso-hover="96">i_3</span>, <span class="var token" data-binding="var-_uniq.23028" data-verso-hover="96">i_4</span>]<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.583" data-verso-hover="270">x</span>[<span class="var token" data-binding="var-_uniq.22895" data-verso-hover="32">i</span>][<span class="var token" data-binding="var-_uniq.23028" data-verso-hover="96">i_4</span>]).2
                      <span class="const token" data-binding="const-Unit.unit" data-verso-hover="280">()</span> (2<span class="const token" data-binding="const-HSMul.hSMul" data-verso-hover="191"> • </span>((⊞ <span class="var token" data-binding="var-_uniq.23086" data-verso-hover="96">i_3</span> =&gt; ∑ <span class="var token" data-binding="var-_uniq.23094" data-verso-hover="96">i_4</span>, <span class="var token" data-binding="var-_uniq.22877" data-verso-hover="271">x_1</span>[<span class="var token" data-binding="var-_uniq.23086" data-verso-hover="96">i_3</span>, <span class="var token" data-binding="var-_uniq.23094" data-verso-hover="96">i_4</span>]<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.583" data-verso-hover="270">x</span>[<span class="var token" data-binding="var-_uniq.22895" data-verso-hover="32">i</span>][<span class="var token" data-binding="var-_uniq.23094" data-verso-hover="96">i_4</span>])<span class="const token" data-binding="const-HSub.hSub" data-verso-hover="225"> - </span><span class="var token" data-binding="var-_uniq.592" data-verso-hover="270">y</span>[<span class="var token" data-binding="var-_uniq.22895" data-verso-hover="32">i</span>])) <span class="var token" data-binding="var-_uniq.22906" data-verso-hover="96">i_1</span>)
            <span class="var token" data-binding="var-_uniq.22904" data-verso-hover="271">dx</span>)
        <span class="var token" data-binding="var-_uniq.22893" data-verso-hover="271">dx</span>)
    0</span></span></div></div></span><span class="unknown token" data-binding="">;</span> <span class="tactic"><label for="tactic-state-14693485949627472821-13342-13370"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.Conv.unfold-13342" data-verso-hover="272">unfold</span> <span class="const token" data-binding="const-SciLean.revFDerivProj" data-verso-hover="276">SciLean.revFDerivProj</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14693485949627472821-13342-13370"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.527" data-verso-hover="4">n</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.583" data-verso-hover="270">x</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>^[2]^[<span class="var token" data-binding="var-_uniq.527" data-verso-hover="4">n</span>]</td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.592" data-verso-hover="270">y</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>^[2]^[<span class="var token" data-binding="var-_uniq.527" data-verso-hover="4">n</span>]</td></tr></table><span class="conclusion"><span class="prefix">| </span><span class="type"><span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.22877" data-verso-hover="271">x_1</span> =&gt;
  <span class="const token" data-binding="const-SciLean.IndexType.foldl" data-verso-hover="274">SciLean.IndexType.foldl</span>
    (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.22893" data-verso-hover="271">dx</span> <span class="var token" data-binding="var-_uniq.22895" data-verso-hover="32">i</span> =&gt;
      <span class="const token" data-binding="const-SciLean.IndexType.foldl" data-verso-hover="274">SciLean.IndexType.foldl</span>
        (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.22904" data-verso-hover="271">dx</span> <span class="var token" data-binding="var-_uniq.22906" data-verso-hover="96">i_1</span> =&gt;
          <span class="const token" data-binding="const-SciLean.IndexType.foldl" data-verso-hover="274">SciLean.IndexType.foldl</span>
            (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.22915" data-verso-hover="271">dx</span> <span class="var token" data-binding="var-_uniq.22917" data-verso-hover="96">i_2</span> =&gt;
              <span class="const token" data-binding="const-SciLean.ArrayType.modify" data-verso-hover="275">SciLean.ArrayType.modify</span> <span class="var token" data-binding="var-_uniq.22915" data-verso-hover="271">dx</span> (<span class="var token" data-binding="var-_uniq.22906" data-verso-hover="96">i_1</span>, <span class="var token" data-binding="var-_uniq.22917" data-verso-hover="96">i_2</span>) <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.22938" data-verso-hover="81">xi</span> =&gt;
                <span class="var token" data-binding="var-_uniq.22938" data-verso-hover="81">xi</span><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="141"> +
                  </span><span class="var token" data-binding="var-_uniq.583" data-verso-hover="270">x</span>[<span class="var token" data-binding="var-_uniq.22895" data-verso-hover="32">i</span>][<span class="var token" data-binding="var-_uniq.22917" data-verso-hover="96">i_2</span>]<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> *
                    </span>((<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.22986" data-verso-hover="278">x4</span> =&gt; <span class="const token" data-binding="const-SciLean.ArrayType.ofFn" data-verso-hover="279">SciLean.ArrayType.ofFn</span> <span class="var token" data-binding="var-_uniq.22986" data-verso-hover="278">x4</span>) <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.23000" data-verso-hover="96">i_3</span> =&gt;  ∑ <span class="var token" data-binding="var-_uniq.23015" data-verso-hover="96">i_4</span>, <span class="var token" data-binding="var-_uniq.22877" data-verso-hover="271">x_1</span>[<span class="var token" data-binding="var-_uniq.23000" data-verso-hover="96">i_3</span>, <span class="var token" data-binding="var-_uniq.23015" data-verso-hover="96">i_4</span>]<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.583" data-verso-hover="270">x</span>[<span class="var token" data-binding="var-_uniq.22895" data-verso-hover="32">i</span>][<span class="var token" data-binding="var-_uniq.23015" data-verso-hover="96">i_4</span>], <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.23047" data-verso-hover="281">i_3</span> <span class="var token" data-binding="var-_uniq.23049" data-verso-hover="282">de</span> =&gt;
                          <span class="const token" data-binding="const-adjoint" data-verso-hover="262">adjoint</span> <span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>
                            (⇑(∂ (<span class="var token" data-binding="var-_uniq.23051" data-verso-hover="278">x4</span>:=<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.23058" data-verso-hover="96">i_4</span> =&gt;  ∑ <span class="var token" data-binding="var-_uniq.23066" data-verso-hover="96">i_5</span>, <span class="var token" data-binding="var-_uniq.22877" data-verso-hover="271">x_1</span>[<span class="var token" data-binding="var-_uniq.23058" data-verso-hover="96">i_4</span>, <span class="var token" data-binding="var-_uniq.23066" data-verso-hover="96">i_5</span>]<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.583" data-verso-hover="270">x</span>[<span class="var token" data-binding="var-_uniq.22895" data-verso-hover="32">i</span>][<span class="var token" data-binding="var-_uniq.23066" data-verso-hover="96">i_5</span>]), <span class="const token" data-binding="const-SciLean.ArrayType.ofFn" data-verso-hover="279">SciLean.ArrayType.ofFn</span> <span class="var token" data-binding="var-_uniq.23051" data-verso-hover="278">x4</span>))
                            (<span class="const token" data-binding="const-SciLean.oneHot" data-verso-hover="283">SciLean.oneHot</span> <span class="var token" data-binding="var-_uniq.23047" data-verso-hover="281">i_3</span> <span class="var token" data-binding="var-_uniq.23049" data-verso-hover="282">de</span>)).2
                      <span class="const token" data-binding="const-Unit.unit" data-verso-hover="280">()</span> (2<span class="const token" data-binding="const-HSMul.hSMul" data-verso-hover="191"> • </span>((⊞ <span class="var token" data-binding="var-_uniq.23152" data-verso-hover="96">i_3</span> =&gt; ∑ <span class="var token" data-binding="var-_uniq.23160" data-verso-hover="96">i_4</span>, <span class="var token" data-binding="var-_uniq.22877" data-verso-hover="271">x_1</span>[<span class="var token" data-binding="var-_uniq.23152" data-verso-hover="96">i_3</span>, <span class="var token" data-binding="var-_uniq.23160" data-verso-hover="96">i_4</span>]<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.583" data-verso-hover="270">x</span>[<span class="var token" data-binding="var-_uniq.22895" data-verso-hover="32">i</span>][<span class="var token" data-binding="var-_uniq.23160" data-verso-hover="96">i_4</span>])<span class="const token" data-binding="const-HSub.hSub" data-verso-hover="225"> - </span><span class="var token" data-binding="var-_uniq.592" data-verso-hover="270">y</span>[<span class="var token" data-binding="var-_uniq.22895" data-verso-hover="32">i</span>])) <span class="var token" data-binding="var-_uniq.22906" data-verso-hover="96">i_1</span>)
            <span class="var token" data-binding="var-_uniq.22904" data-verso-hover="271">dx</span>)
        <span class="var token" data-binding="var-_uniq.22893" data-verso-hover="271">dx</span>)
    0</span></span></div></div></span><span class="unknown token" data-binding="">;</span> <span class="tactic"><label for="tactic-state-14131426221577998885-13372-13381"><span class="keyword token" data-binding="kw-occ-Mathlib.Meta.FunTrans.funTransConvStx-13372">fun_trans</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14131426221577998885-13372-13381"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.527" data-verso-hover="4">n</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="5">ℕ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.583" data-verso-hover="270">x</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>^[2]^[<span class="var token" data-binding="var-_uniq.527" data-verso-hover="4">n</span>]</td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.592" data-verso-hover="270">y</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Float" data-verso-hover="27">Float</span>^[2]^[<span class="var token" data-binding="var-_uniq.527" data-verso-hover="4">n</span>]</td></tr></table><span class="conclusion"><span class="prefix">| </span><span class="type"><span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.22877" data-verso-hover="271">x_1</span> =&gt;
  <span class="const token" data-binding="const-SciLean.IndexType.foldl" data-verso-hover="274">SciLean.IndexType.foldl</span>
    (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.22893" data-verso-hover="271">dx</span> <span class="var token" data-binding="var-_uniq.22895" data-verso-hover="32">i</span> =&gt;
      <span class="const token" data-binding="const-SciLean.IndexType.foldl" data-verso-hover="274">SciLean.IndexType.foldl</span>
        (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.22904" data-verso-hover="271">dx</span> <span class="var token" data-binding="var-_uniq.22906" data-verso-hover="96">i_1</span> =&gt;
          <span class="const token" data-binding="const-SciLean.IndexType.foldl" data-verso-hover="274">SciLean.IndexType.foldl</span>
            (<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.22915" data-verso-hover="271">dx</span> <span class="var token" data-binding="var-_uniq.22917" data-verso-hover="96">i_2</span> =&gt;
              <span class="const token" data-binding="const-SciLean.ArrayType.modify" data-verso-hover="275">SciLean.ArrayType.modify</span> <span class="var token" data-binding="var-_uniq.22915" data-verso-hover="271">dx</span> (<span class="var token" data-binding="var-_uniq.22906" data-verso-hover="96">i_1</span>, <span class="var token" data-binding="var-_uniq.22917" data-verso-hover="96">i_2</span>) <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.22938" data-verso-hover="81">xi</span> =&gt;
                <span class="var token" data-binding="var-_uniq.22938" data-verso-hover="81">xi</span><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="141"> + </span><span class="var token" data-binding="var-_uniq.583" data-verso-hover="270">x</span>[<span class="var token" data-binding="var-_uniq.22895" data-verso-hover="32">i</span>][<span class="var token" data-binding="var-_uniq.22917" data-verso-hover="96">i_2</span>]<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span>(2<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span>( ∑ <span class="var token" data-binding="var-_uniq.23013" data-verso-hover="96">i_3</span>, <span class="var token" data-binding="var-_uniq.22877" data-verso-hover="271">x_1</span>[<span class="var token" data-binding="var-_uniq.22906" data-verso-hover="96">i_1</span>, <span class="var token" data-binding="var-_uniq.23013" data-verso-hover="96">i_3</span>]<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.583" data-verso-hover="270">x</span>[<span class="var token" data-binding="var-_uniq.22895" data-verso-hover="32">i</span>][<span class="var token" data-binding="var-_uniq.23013" data-verso-hover="96">i_3</span>]<span class="const token" data-binding="const-HSub.hSub" data-verso-hover="225"> - </span><span class="var token" data-binding="var-_uniq.592" data-verso-hover="270">y</span>[<span class="var token" data-binding="var-_uniq.22895" data-verso-hover="32">i</span>][<span class="var token" data-binding="var-_uniq.22906" data-verso-hover="96">i_1</span>])))
            <span class="var token" data-binding="var-_uniq.22904" data-verso-hover="271">dx</span>)
        <span class="var token" data-binding="var-_uniq.22893" data-verso-hover="271">dx</span>)
    0</span></span></div></div></span>
<span class="unknown token" data-binding=""></span></code></div>
            </section>
          <section>
            <h2 id="Scientific-Computing-in-Lean--Differentiation--Symbolic-Differentiation--Missing-Derivative-Rules">
              Missing Derivative Rules</h2>
            <p>
              A commong issue when <code>fun_trans</code> is not doing what we expect is that there is a missing differentiation theorem.</p>
            <p>
              For example, if we define a function</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-13629">def</span> <span class="const token" data-binding="const-foo" data-verso-hover="284">foo</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">x</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">x</span><span class="unknown token" data-binding="">^</span><span class="unknown token" data-binding="">2</span> <span class="unknown token" data-binding="">+</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">x</span>
<span class="unknown token" data-binding=""></span></code><p>
              then nothing happens when we try to differentiate it</p>
            <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">fun x =&gt; (∂ (x:=x), foo x) 1 : ℝ → ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-13747">#check</span></span> <span class="unknown token" data-binding="">∂!</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="222">x</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-foo" data-verso-hover="285">foo</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="222">x</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
              <pre>fun x =&gt; (∂ (x:=x), foo x) 1 : ℝ → ℝ
</pre></div>
            <p>
              Turning on the <code>fun_trans</code> trace reveals useful information</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-13919" data-verso-hover="179">set_option</span> <span class="option token" data-binding="option-Mathlib.Meta.FunTrans.initFn._@.SciLean.Tactic.FunTrans.Decl._hyg.50" data-verso-hover="286">trace.Meta.Tactic.fun_trans</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-13919" data-verso-hover="179">true</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.in-13919">in</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">fun x =&gt; (∂ (x:=x), foo x) 1 : ℝ → ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-13966">#check</span></span> <span class="unknown token" data-binding="">∂!</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="222">x</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-foo" data-verso-hover="285">foo</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="222">x</span>
<span class="unknown token" data-binding=""></span></code><pre>[Meta.Tactic.fun_trans] [❌] ∂ (x:=x), foo x
  [Meta.Tactic.fun_trans] candidate theorems for foo: []
  [Meta.Tactic.fun_trans] candidate local theorems for foo: []
  [Meta.Tactic.fun_trans] candidate fvar theorems: [isContinuousLinearMap_fderiv]
  [Meta.Tactic.fun_trans] [❌] applying: isContinuousLinearMap_fderiv
    [Meta.Tactic.fun_trans] isContinuousLinearMap_fderiv, failed to discharge hypotheses
          SciLean.IsContinuousLinearMap ℝ fun x =&gt; foo x
</pre><p>
              The <code>❌</code> on the first line signifies that <code>fun_trans</code> failed to make prograss on <code>∂ (x:=x), foo x</code>. The next two lines</p>
            <pre>  [Meta.Tactic.fun_trans] candidate theorems for foo: []
  [Meta.Tactic.fun_trans] candidate local theorems for foo: []
</pre><p>
              states that there are no derivative theorems for <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-foo" data-verso-hover="285">foo</span></code>. The next line</p>
            <pre>  [Meta.Tactic.fun_trans] candidate fvar theorems: [isContinuousLinearMap_fderiv]
</pre><p>
              states that there is a potentially applicable theorem <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-isContinuousLinearMap_fderiv" data-verso-hover="287">isContinuousLinearMap_fderiv</span></code> which can differentiate linear functions. However the next few lines report that applying this theorem failed as <code>fun_trans</code> can't prove that <code>foo</code> is (continuous) linear map.</p>
            <p>
              To remedy this problem we can define derivative of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-foo" data-verso-hover="285">foo</span></code></p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-15225">def</span> <span class="const token" data-binding="const-foo_deriv" data-verso-hover="288">foo_deriv</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">x</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">*</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">x</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span>
<span class="unknown token" data-binding=""></span></code><p>
              and add a theorem that the derivative of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-foo" data-verso-hover="285">foo</span></code> is equal to <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-foo_deriv" data-verso-hover="289">foo_deriv</span></code></p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-15355" data-verso-hover="13">open</span> <span class="unknown token" data-binding="">SciLean</span>
<span class="unknown token" data-binding="">@[</span><span class="unknown token" data-binding="">fun_trans</span><span class="unknown token" data-binding="">]</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-15381">theorem</span> <span class="const token" data-binding="const-foo_deriv_rule" data-verso-hover="290">foo_deriv_rule</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-fderiv" data-verso-hover="221">fderiv</span> <span class="unknown token" data-binding="">ℝ</span> <span class="const token" data-binding="const-foo" data-verso-hover="285">foo</span> <span class="unknown token" data-binding="">=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-15423">fun</span> <span class="var token" data-binding="var-_uniq.190" data-verso-hover="222">x</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="keyword token" data-binding="kw-occ-SciLean.«termFun_=>L[_]_»-15432">fun</span> <span class="var token" data-binding="var-_uniq.205" data-verso-hover="222">dx</span> <span class="unknown token" data-binding="">=&gt;L[</span><span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">]</span> <span class="var token" data-binding="var-_uniq.205" data-verso-hover="222">dx</span> <span class="unknown token" data-binding="">•</span> <span class="const token" data-binding="const-foo_deriv" data-verso-hover="289">foo_deriv</span> <span class="var token" data-binding="var-_uniq.190" data-verso-hover="222">x</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-12053836367124394835-15470-15472"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-15470" data-verso-hover="69">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12053836367124394835-15470-15472"><div class="tactic-state"><div class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type">∂ <span class="const token" data-binding="const-foo" data-verso-hover="285">foo</span><span class="const token" data-binding="const-Eq" data-verso-hover="72"> = </span><span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.7876" data-verso-hover="222">x</span> =&gt; <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.7890" data-verso-hover="222">dx</span> =&gt;L[<span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span>] <span class="var token" data-binding="var-_uniq.7890" data-verso-hover="222">dx</span><span class="const token" data-binding="const-HSMul.hSMul" data-verso-hover="191"> • </span><span class="const token" data-binding="const-foo_deriv" data-verso-hover="289">foo_deriv</span> <span class="var token" data-binding="var-_uniq.7876" data-verso-hover="222">x</span></span></span></div></div></span> <span class="tactic"><label for="tactic-state-8629001085943303540-15473-15493"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.unfold-15473" data-verso-hover="238">unfold</span> <span class="const token" data-binding="const-foo" data-verso-hover="285">foo</span> <span class="const token" data-binding="const-foo_deriv" data-verso-hover="289">foo_deriv</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-8629001085943303540-15473-15493"><div class="tactic-state"><div class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type">∂ <span class="var token" data-binding="var-_uniq.7876" data-verso-hover="222">x</span>, (<span class="var token" data-binding="var-_uniq.7876" data-verso-hover="222">x</span><span class="const token" data-binding="const-HPow.hPow" data-verso-hover="224"> ^ </span>2<span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="141"> + </span><span class="var token" data-binding="var-_uniq.7876" data-verso-hover="222">x</span>)<span class="const token" data-binding="const-Eq" data-verso-hover="72"> = </span><span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.7901" data-verso-hover="222">x</span> =&gt; <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.7915" data-verso-hover="222">dx</span> =&gt;L[<span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span>] <span class="var token" data-binding="var-_uniq.7915" data-verso-hover="222">dx</span><span class="const token" data-binding="const-HSMul.hSMul" data-verso-hover="191"> • </span>(2<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.7901" data-verso-hover="222">x</span><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="141"> + </span>1)</span></span></div></div></span><span class="unknown token" data-binding="">;</span> <span class="tactic"><label for="tactic-state-252404580762776335-15495-15500"><span class="keyword token" data-binding="kw-occ-Lean.Elab.Tactic.Ext.ext-15495" data-verso-hover="184">ext</span> <span class="var token" data-binding="var-_uniq.2522" data-verso-hover="222">x</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-252404580762776335-15495-15500"><div class="tactic-state"><div class="goal"><details open="open"><summary><span class="goal-name">h.h</span></summary><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2522" data-verso-hover="222">x</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type">(∂ (<span class="var token" data-binding="var-_uniq.7875" data-verso-hover="222">x</span>:=<span class="var token" data-binding="var-_uniq.2522" data-verso-hover="222">x</span>), (<span class="var token" data-binding="var-_uniq.7875" data-verso-hover="222">x</span><span class="const token" data-binding="const-HPow.hPow" data-verso-hover="224"> ^ </span>2<span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="141"> + </span><span class="var token" data-binding="var-_uniq.7875" data-verso-hover="222">x</span>)) 1<span class="const token" data-binding="const-Eq" data-verso-hover="72"> = </span>(<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.7913" data-verso-hover="222">dx</span> =&gt;L[<span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span>] <span class="var token" data-binding="var-_uniq.7913" data-verso-hover="222">dx</span><span class="const token" data-binding="const-HSMul.hSMul" data-verso-hover="191"> • </span>(2<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.2522" data-verso-hover="222">x</span><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="141"> + </span>1)) 1</span></span></details></div></div></span><span class="unknown token" data-binding="">;</span> <span class="tactic"><label for="tactic-state-7-15502-15511"><span class="keyword token" data-binding="kw-occ-Mathlib.Meta.FunTrans.funTransTacStx-15502">fun_trans</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-15502-15511"><div class="tactic-state">All goals completed! 🐙</div></span>
<span class="unknown token" data-binding=""></span></code><p>
              Because <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-foo_deriv_rule" data-verso-hover="291">foo_deriv_rule</span></code> is marked with <code>fun_trans</code> attribute it will be used when we try to differentiate <code>foo</code> now</p>
            <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">fun x =&gt; foo_deriv x : ℝ → ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-15665">#check</span></span> <span class="unknown token" data-binding="">∂!</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="222">x</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-foo" data-verso-hover="285">foo</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="222">x</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
              <pre>fun x =&gt; foo_deriv x : ℝ → ℝ
</pre></div>
            <p>
              Unfortuantelly there is one more issue, <code>fun_trans</code> will do nothing when we try to compose <code>foo</code> together</p>
            <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">fun x =&gt; (∂ (x:=x), foo (foo x)) 1 : ℝ → ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-15888">#check</span></span> <span class="unknown token" data-binding="">∂!</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="222">x</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-foo" data-verso-hover="285">foo</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-foo" data-verso-hover="285">foo</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="222">x</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
              <pre>fun x =&gt; (∂ (x:=x), foo (foo x)) 1 : ℝ → ℝ
</pre></div>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-16008" data-verso-hover="179">set_option</span> <span class="option token" data-binding="option-Mathlib.Meta.FunTrans.initFn._@.SciLean.Tactic.FunTrans.Decl._hyg.50" data-verso-hover="286">trace.Meta.Tactic.fun_trans</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-16008" data-verso-hover="179">true</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.in-16008">in</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">fun x =&gt; (∂ (x:=x), foo (foo x)) 1 : ℝ → ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-16055">#check</span></span> <span class="unknown token" data-binding="">∂!</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="222">x</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-foo" data-verso-hover="285">foo</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-foo" data-verso-hover="285">foo</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="222">x</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><pre>...
  [Meta.Tactic.fun_trans] trying comp theorem SciLean.fderiv.comp_rule
  [Meta.Tactic.fun_trans] [❌] applying: SciLean.fderiv.comp_rule
    [Meta.Tactic.fun_trans] SciLean.fderiv.comp_rule, failed to discharge hypotheses
          Differentiable ℝ fun x0 =&gt; foo x0
...
</pre><p>
              The trace will reveal that <code>fun_trans</code> tries to apply composition(chain) rule <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-SciLean.fderiv.comp_rule" data-verso-hover="292">SciLean.fderiv.comp_rule</span></code> but it fails as it can't prove <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Differentiable" data-verso-hover="269">Differentiable</span> <span class="unknown token" data-binding="">ℝ</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-16539">fun</span> <span class="var token" data-binding="var-_uniq.1401" data-verso-hover="222">x0</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-foo" data-verso-hover="285">foo</span> <span class="var token" data-binding="var-_uniq.1401" data-verso-hover="222">x0</span></code>. We need another theorem stating that <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-foo" data-verso-hover="285">foo</span></code> is differentiable function. Mathlib has a tactic <code>fun_prop</code> that can prove differentiability and many other function properties like linearity, continuity, measurability etc. and <code>fun_trans</code> uses this tactic to ensure it can apply chain rule.</p>
            <p>
              Therefore we need to add <code>fun_prop</code> theorem for <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-foo" data-verso-hover="285">foo</span></code></p>
            <code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding="">@[</span><span class="unknown token" data-binding="">fun_prop</span><span class="unknown token" data-binding="">]</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-16931">theorem</span> <span class="const token" data-binding="const-foo_differentiable" data-verso-hover="293">foo_differentiable</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Differentiable" data-verso-hover="269">Differentiable</span> <span class="unknown token" data-binding="">ℝ</span> <span class="const token" data-binding="const-foo" data-verso-hover="285">foo</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-10893289003651201275-16986-16988"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-16986" data-verso-hover="69">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-10893289003651201275-16986-16988"><div class="tactic-state"><div class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-Differentiable" data-verso-hover="269">Differentiable</span> <span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span> <span class="const token" data-binding="const-foo" data-verso-hover="285">foo</span></span></span></div></div></span> <span class="tactic"><label for="tactic-state-11734240531055305780-16989-16999"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.unfold-16989" data-verso-hover="238">unfold</span> <span class="const token" data-binding="const-foo" data-verso-hover="285">foo</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11734240531055305780-16989-16999"><div class="tactic-state"><div class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-Differentiable" data-verso-hover="269">Differentiable</span> <span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span> <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.598" data-verso-hover="222">x</span> =&gt; <span class="var token" data-binding="var-_uniq.598" data-verso-hover="222">x</span><span class="const token" data-binding="const-HPow.hPow" data-verso-hover="224"> ^ </span>2<span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="141"> + </span><span class="var token" data-binding="var-_uniq.598" data-verso-hover="222">x</span></span></span></div></div></span><span class="unknown token" data-binding="">;</span> <span class="tactic"><label for="tactic-state-7-17001-17009"><span class="keyword token" data-binding="kw-occ-Mathlib.Meta.FunProp.funPropTacStx-17001" data-verso-hover="294">fun_prop</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-17001-17009"><div class="tactic-state">All goals completed! 🐙</div></span>
<span class="unknown token" data-binding=""></span></code><p>
              Now <code>fun_trans</code> knows that <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-foo" data-verso-hover="285">foo</span></code> is differentiable function and can safely apply chain rule</p>
            <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">fun x =&gt; foo_deriv x * foo_deriv (foo x) : ℝ → ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-17147">#check</span></span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∂!</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="222">x</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-foo" data-verso-hover="285">foo</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-foo" data-verso-hover="285">foo</span> <span class="var token" data-binding="var-_uniq.7" data-verso-hover="222">x</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-SciLean.term_Rewrite_byAssuming__-17154">rewrite_by</span> <span class="tactic"><label for="tactic-state-14180328119166588544-17187-17191"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.Conv.simp-17187" data-verso-hover="178">simp</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14180328119166588544-17187-17191"><div class="tactic-state"><div class="goal"><span class="conclusion"><span class="prefix">| </span><span class="type"><span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.1806" data-verso-hover="222">x</span> =&gt; <span class="const token" data-binding="const-foo_deriv" data-verso-hover="289">foo_deriv</span> <span class="var token" data-binding="var-_uniq.1806" data-verso-hover="222">x</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="const token" data-binding="const-foo_deriv" data-verso-hover="289">foo_deriv</span> (<span class="const token" data-binding="const-foo" data-verso-hover="285">foo</span> <span class="var token" data-binding="var-_uniq.1806" data-verso-hover="222">x</span>)</span></span></div></div></span>
<span class="unknown token" data-binding=""></span></code><div class="information">
              <pre>fun x =&gt; foo_deriv x * foo_deriv (foo x) : ℝ → ℝ
</pre></div>
            <p>
              Writing these theorems by hand is quite tedious so there is a macro <code>def_fun_prop</code> and <code>def_fun_trans</code> to help you with writing these theorems</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-SciLean.«commandDef_fun_propWith_transitive__:_By_»-17440" data-verso-hover="295">def_fun_prop</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Differentiable" data-verso-hover="269">Differentiable</span> <span class="unknown token" data-binding="">ℝ</span> <span class="const token" data-binding="const-foo" data-verso-hover="285">foo</span> <span class="keyword token" data-binding="kw-occ-SciLean.«commandDef_fun_propWith_transitive__:_By_»-17440" data-verso-hover="295">by</span> <span class="tactic"><label for="tactic-state-3567834162914227034-17481-17491"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.unfold-17481" data-verso-hover="238">unfold</span> <span class="const token" data-binding="const-foo" data-verso-hover="285">foo</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-3567834162914227034-17481-17491"><div class="tactic-state"><div class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-Differentiable" data-verso-hover="269">Differentiable</span> <span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span> <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.584" data-verso-hover="222">x</span> =&gt; <span class="var token" data-binding="var-_uniq.584" data-verso-hover="222">x</span><span class="const token" data-binding="const-HPow.hPow" data-verso-hover="224"> ^ </span>2<span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="141"> + </span><span class="var token" data-binding="var-_uniq.584" data-verso-hover="222">x</span></span></span></div></div></span><span class="unknown token" data-binding="">;</span> <span class="tactic"><label for="tactic-state-7-17493-17501"><span class="keyword token" data-binding="kw-occ-Mathlib.Meta.FunProp.funPropTacStx-17493" data-verso-hover="294">fun_prop</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-17493-17501"><div class="tactic-state">All goals completed! 🐙</div></span>
<span class="keyword token" data-binding="kw-occ-SciLean.«commandDef_fun_transWith_transitive__:_By_»-17502">def_fun_trans</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-fderiv" data-verso-hover="221">fderiv</span> <span class="unknown token" data-binding="">ℝ</span> <span class="const token" data-binding="const-foo" data-verso-hover="285">foo</span> <span class="keyword token" data-binding="kw-occ-SciLean.«commandDef_fun_transWith_transitive__:_By_»-17502">by</span> <span class="tactic"><label for="tactic-state-7340767202081764024-17536-17546"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.Conv.unfold-17536" data-verso-hover="272">unfold</span> <span class="const token" data-binding="const-foo" data-verso-hover="285">foo</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7340767202081764024-17536-17546"><div class="tactic-state"><div class="goal"><span class="conclusion"><span class="prefix">| </span><span class="type">∂ <span class="var token" data-binding="var-_uniq.6068" data-verso-hover="222">x</span>, (<span class="var token" data-binding="var-_uniq.6068" data-verso-hover="222">x</span><span class="const token" data-binding="const-HPow.hPow" data-verso-hover="224"> ^ </span>2<span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="141"> + </span><span class="var token" data-binding="var-_uniq.6068" data-verso-hover="222">x</span>)</span></span></div></div></span><span class="unknown token" data-binding="">;</span> <span class="tactic"><label for="tactic-state-4831339525703391608-17548-17557"><span class="keyword token" data-binding="kw-occ-Mathlib.Meta.FunTrans.funTransConvStx-17548">fun_trans</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-4831339525703391608-17548-17557"><div class="tactic-state"><div class="goal"><span class="conclusion"><span class="prefix">| </span><span class="type"><span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.6066" data-verso-hover="222">x</span> =&gt; <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.6080" data-verso-hover="222">x_1</span> =&gt;L[<span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span>] 2<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.6080" data-verso-hover="222">x_1</span><span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.6066" data-verso-hover="222">x</span><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="141"> + </span><span class="var token" data-binding="var-_uniq.6080" data-verso-hover="222">x_1</span></span></span></div></div></span>
<span class="unknown token" data-binding=""></span></code><p>
              It generates these theorems and definition</p>
            <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">foo.arg_x.Differentiable_rule : Differentiable ℝ foo</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-17633">#check</span></span> <span class="const token" data-binding="const-foo.arg_x.Differentiable_rule" data-verso-hover="296">foo.arg_x.Differentiable_rule</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">def foo.arg_x.fderiv : ℝ → ℝ →L[ℝ] ℝ :=
fun x =&gt; fun x_1 =&gt;L[ℝ] 2 * x_1 * x + x_1</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.print-17670">#print</span></span> <span class="const token" data-binding="const-foo.arg_x.fderiv" data-verso-hover="297">foo.arg_x.fderiv</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">foo.arg_x.fderiv_rule : ∂ foo = foo.arg_x.fderiv</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-17694">#check</span></span> <span class="const token" data-binding="const-foo.arg_x.fderiv_rule" data-verso-hover="298">foo.arg_x.fderiv_rule</span>
<span class="unknown token" data-binding=""></span></code><p>
              The problem of writing appropriate theorems for <code>fun_trans</code> and <code>fun_prop</code> is quite involve problem and will be discussed in future chapter.</p>
            </section>
          <section>
            <h2 id="Scientific-Computing-in-Lean--Differentiation--Symbolic-Differentiation--Differentiating-Division-Log-Sqrt-">
              Differentiating Division, Log, Sqrt, ...</h2>
            <p>
              So far we have worked with functions that are smooth. However, functions like division, <code>log</code>, <code>sqrt</code>, <code>‖·‖₂</code> are not differentiable everywhere. We have to be a bit careful with those functions because <strong>SciLean</strong> tries to perform computations that are, at least in principle, fully formalizable. Let's try to differentiate division</p>
            <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">fun x =&gt; (∂ (x:=x), x⁻¹) 1 : ℝ → ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-18328">#check</span></span> <span class="unknown token" data-binding="">∂!</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="222">x</span><span class="unknown token" data-binding="">:</span><span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">/</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="222">x</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
              <pre>fun x =&gt; (∂ (x:=x), x⁻¹) 1 : ℝ → ℝ
</pre></div>
            <p>
              We did not get expected <code>-x⁻²</code>. When differentiation, or any tactic, is not doing what we expect we can turn on tracing. Let's try again with tracing on</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-18594" data-verso-hover="179">set_option</span> <span class="option token" data-binding="option-Mathlib.Meta.FunTrans.initFn._@.SciLean.Tactic.FunTrans.Decl._hyg.50" data-verso-hover="286">trace.Meta.Tactic.fun_trans</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-18594" data-verso-hover="179">true</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.in-18594">in</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">fun x =&gt; (∂ (x:=x), x⁻¹) 1 : ℝ → ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-18641">#check</span></span> <span class="unknown token" data-binding="">∂!</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="222">x</span><span class="unknown token" data-binding="">:</span><span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">/</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="222">x</span>
<span class="unknown token" data-binding=""></span></code><p>
              and the beggining of the trace is saying that <code>fun_trans</code> tried to apply theorem <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-HDiv.hDiv.arg_a0a1.fderiv_rule_at" data-verso-hover="299">HDiv.hDiv.arg_a0a1.fderiv_rule_at</span></code> however it failed to discharge <code>x ≠ 0</code></p>
            <pre>[Meta.Tactic.fun_trans] [❌] ∂ (x:=x), 1 / x
  [Meta.Tactic.fun_trans] candidate theorems for HDiv.hDiv: [HDiv.hDiv.arg_a0a1.fderiv_rule_at]
  [Meta.Tactic.fun_trans] [❌] applying: HDiv.hDiv.arg_a0a1.fderiv_rule_at
    [Meta.Tactic.fun_trans] [❌] discharging: x ≠ 0
    [Meta.Tactic.fun_trans] HDiv.hDiv.arg_a0a1.fderiv_rule_at, failed to discharge hypotheses
          x ≠ 0
</pre><p>
              This makes sense as division <code>1/x</code> is well defined and differentiable only away from zero. Therefore we have to differentiate it at a concrete point that is not equal to zero.</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-19434" data-verso-hover="52">variable</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">x₀</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.35" data-verso-hover="300">hx₀</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">x₀</span> <span class="unknown token" data-binding="">≠</span> <span class="unknown token" data-binding="">0</span><span class="unknown token" data-binding="">)</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">-(x₀ ^ 2)⁻¹ : ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-19477">#check</span></span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∂</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.75" data-verso-hover="222">x</span><span class="unknown token" data-binding="">:=</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">x₀</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">/</span><span class="var token" data-binding="var-_uniq.75" data-verso-hover="222">x</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-SciLean.term_Rewrite_byAssuming__-19484">rewrite_by</span> <span class="tactic"><label for="tactic-state-15339860773356334190-19516-19545"><span class="keyword token" data-binding="kw-occ-Mathlib.Meta.FunTrans.funTransConvStx-19516">fun_trans</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-token.disch-19527">disch</span><span class="unknown token" data-binding="">:=</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.assumption-19534" data-verso-hover="301">assumption</span><span class="unknown token" data-binding="">)</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-15339860773356334190-19516-19545"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">x₀</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.35" data-verso-hover="300">hx₀</span></td><td class="colon">:</td><td class="type"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">x₀</span><span class="const token" data-binding="const-Ne" data-verso-hover="243"> ≠ </span>0</td></tr></table><span class="conclusion"><span class="prefix">| </span><span class="type"><span class="const token" data-binding="const-Neg.neg" data-verso-hover="168">-</span>(<span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">x₀</span><span class="const token" data-binding="const-HPow.hPow" data-verso-hover="224"> ^ </span>2)<span class="const token" data-binding="const-Inv.inv" data-verso-hover="244">⁻¹</span></span></span></div></div></span>
<span class="unknown token" data-binding=""></span></code><div class="information">
              <pre>-(x₀ ^ 2)⁻¹ : ℝ
</pre></div>
            <p>
              We introduced a point <code>x₀</code> and assumption <code>hx₀</code> that it is not equal to zero. By default <code>fun_trans</code> does not see this assumption and we have to provide discharger. A discharger is any tactic that tries to satisfy(discharge) any assumption of the theorems <code>fun_trans</code> is using. In this simple case <code>assumption</code> tactic is enough as it just looks through the local context and tries to directly apply any existing assumptions.</p>
            <p>
              Using <code>assumption</code> is not enough for a more complicated expression</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-20128" data-verso-hover="52">variable</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">x₀</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.35" data-verso-hover="300">hx₀</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">x₀</span> <span class="unknown token" data-binding="">≠</span> <span class="unknown token" data-binding="">0</span><span class="unknown token" data-binding="">)</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">∂ (x:=x₀), (x ^ 2)⁻¹ : ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-20171">#check</span></span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∂</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.75" data-verso-hover="222">x</span><span class="unknown token" data-binding="">:=</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">x₀</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">/</span><span class="var token" data-binding="var-_uniq.75" data-verso-hover="222">x</span><span class="unknown token" data-binding="">^</span><span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-SciLean.term_Rewrite_byAssuming__-20178">rewrite_by</span> <span class="tactic"><label for="tactic-state-3224104707086150454-20212-20241"><span class="keyword token" data-binding="kw-occ-Mathlib.Meta.FunTrans.funTransConvStx-20212">fun_trans</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-token.disch-20223">disch</span><span class="unknown token" data-binding="">:=</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.assumption-20230" data-verso-hover="301">assumption</span><span class="unknown token" data-binding="">)</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-3224104707086150454-20212-20241"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">x₀</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.35" data-verso-hover="300">hx₀</span></td><td class="colon">:</td><td class="type"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">x₀</span><span class="const token" data-binding="const-Ne" data-verso-hover="243"> ≠ </span>0</td></tr></table><span class="conclusion"><span class="prefix">| </span><span class="type">∂ (<span class="var token" data-binding="var-_uniq.3271" data-verso-hover="222">x</span>:=<span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">x₀</span>), (<span class="var token" data-binding="var-_uniq.3271" data-verso-hover="222">x</span><span class="const token" data-binding="const-HPow.hPow" data-verso-hover="224"> ^ </span>2)<span class="const token" data-binding="const-Inv.inv" data-verso-hover="244">⁻¹</span></span></span></div></div></span>
<span class="unknown token" data-binding=""></span></code><div class="information">
              <pre>∂ (x:=x₀), (x ^ 2)⁻¹ : ℝ
</pre></div>
            <p>
              tracing shows</p>
            <pre>[Meta.Tactic.fun_trans] HDiv.hDiv.arg_a0a1.fderiv_rule_at,
  failed to discharge hypotheses x₀ ^ 2 ≠ 0
</pre><p>
              We need a tactic that is capable of infering <code>(x₀^2 ≠ 0)</code> from <code>(x₀ ≠ 0)</code>. A very general and powerful tactic is <code>aesop</code></p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-20598" data-verso-hover="52">variable</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">x₀</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.35" data-verso-hover="300">hx₀</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">x₀</span> <span class="unknown token" data-binding="">≠</span> <span class="unknown token" data-binding="">0</span><span class="unknown token" data-binding="">)</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">-(2 * x₀) / (x₀ ^ 2) ^ 2 : ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-20641">#check</span></span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∂</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.75" data-verso-hover="222">x</span><span class="unknown token" data-binding="">:=</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">x₀</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">/</span><span class="var token" data-binding="var-_uniq.75" data-verso-hover="222">x</span><span class="unknown token" data-binding="">^</span><span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-SciLean.term_Rewrite_byAssuming__-20648">rewrite_by</span> <span class="tactic"><label for="tactic-state-8078952733232278183-20682-20706"><span class="keyword token" data-binding="kw-occ-Mathlib.Meta.FunTrans.funTransConvStx-20682">fun_trans</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-token.disch-20693">disch</span><span class="unknown token" data-binding="">:=</span><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">aesop: failed to prove the goal. Some goals were not explored because the maximum rule application depth (30) was reached. Set option 'maxRuleApplicationDepth' to increase the limit.</code><code class="message warning">aesop: failed to prove the goal. Some goals were not explored because the maximum rule application depth (30) was reached. Set option 'maxRuleApplicationDepth' to increase the limit.</code></span></span><span class="keyword token" data-binding="kw-occ-Aesop.Frontend.Parser.aesopTactic-20700" data-verso-hover="302">aesop</span></span><span class="unknown token" data-binding="">)</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-8078952733232278183-20682-20706"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">x₀</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.35" data-verso-hover="300">hx₀</span></td><td class="colon">:</td><td class="type"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">x₀</span><span class="const token" data-binding="const-Ne" data-verso-hover="243"> ≠ </span>0</td></tr></table><span class="conclusion"><span class="prefix">| </span><span class="type"><span class="const token" data-binding="const-Neg.neg" data-verso-hover="168">-</span>(2<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="138"> * </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">x₀</span>)<span class="const token" data-binding="const-HDiv.hDiv" data-verso-hover="137"> / </span>(<span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">x₀</span><span class="const token" data-binding="const-HPow.hPow" data-verso-hover="224"> ^ </span>2)<span class="const token" data-binding="const-HPow.hPow" data-verso-hover="224"> ^ </span>2</span></span></div></div></span>
<span class="unknown token" data-binding=""></span></code><div class="information">
              <pre>-(2 * x₀) / (x₀ ^ 2) ^ 2 : ℝ
</pre></div>
            <p>
              In multiple dimensions we often want to differentiate the norm</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-20852" data-verso-hover="13">open</span> <span class="unknown token" data-binding="">SciLean</span> <span class="unknown token" data-binding="">Scalar</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-20873" data-verso-hover="52">variable</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="226">x₀</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">×</span><span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.62" data-verso-hover="300">hx₀</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.4" data-verso-hover="226">x₀</span> <span class="unknown token" data-binding="">≠</span> <span class="unknown token" data-binding="">0</span><span class="unknown token" data-binding="">)</span>

<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">‖x₀‖₂[ℝ]⁻¹ • x₀ : ℝ × ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-20922">#check</span></span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∇</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.129" data-verso-hover="226">x</span><span class="unknown token" data-binding="">:=</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="226">x₀</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">‖</span><span class="var token" data-binding="var-_uniq.129" data-verso-hover="226">x</span><span class="unknown token" data-binding="">‖₂</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-SciLean.term_Rewrite_byAssuming__-20929">rewrite_by</span> <span class="tactic"><label for="tactic-state-7606327244069302305-20968-20984"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.Conv.unfold-20968" data-verso-hover="272">unfold</span> <span class="const token" data-binding="const-SciLean.fgradient" data-verso-hover="273">fgradient</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7606327244069302305-20968-20984"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="226">x₀</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span><span class="const token" data-binding="const-Prod" data-verso-hover="71"> × </span><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.62" data-verso-hover="300">hx₀</span></td><td class="colon">:</td><td class="type"><span class="var token" data-binding="var-_uniq.4" data-verso-hover="226">x₀</span><span class="const token" data-binding="const-Ne" data-verso-hover="243"> ≠ </span>0</td></tr></table><span class="conclusion"><span class="prefix">| </span><span class="type">(&lt;∂ (<span class="var token" data-binding="var-_uniq.1567" data-verso-hover="226">x</span>:=<span class="var token" data-binding="var-_uniq.4" data-verso-hover="226">x₀</span>), <span class="const token" data-binding="const-SciLean.norm₂" data-verso-hover="303">‖</span><span class="var token" data-binding="var-_uniq.1567" data-verso-hover="226">x</span><span class="const token" data-binding="const-SciLean.norm₂" data-verso-hover="303">‖₂[</span><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span><span class="const token" data-binding="const-SciLean.norm₂" data-verso-hover="303">]</span>).2 1</span></span></div></div></span><span class="unknown token" data-binding="">;</span> <span class="keyword token" data-binding="kw-occ-Mathlib.Meta.FunTrans.funTransConvStx-20986">fun_trans</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-token.disch-20997">disch</span><span class="unknown token" data-binding="">:=</span><span class="tactic"><label for="tactic-state-7-21004-21014"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.assumption-21004" data-verso-hover="301">assumption</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-21004-21014"><div class="tactic-state">All goals completed! 🐙</div></span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
              The fact that norm is not differentiable can cause issues. The common practice when writing numerical algorithms is to regularize norm using a small positive <code>ε</code>.</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-21215" data-verso-hover="13">open</span> <span class="unknown token" data-binding="">SciLean</span> <span class="unknown token" data-binding="">Scalar</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-21235" data-verso-hover="52">variable</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">ε</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.63" data-verso-hover="304">hε</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">0</span> <span class="unknown token" data-binding="">&lt;</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">ε</span><span class="unknown token" data-binding="">)</span>

<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">fun w =&gt; fun x =&gt;L[ℝ] 2 * ⟪x, w⟫_ℝ / (2 * sqrt (ε + ‖w‖₂²)) : ℝ × ℝ → ℝ × ℝ →L[ℝ] ℝ</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-21271">#check</span></span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∂</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.134" data-verso-hover="226">x</span><span class="unknown token" data-binding="">:</span><span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">×</span><span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-SciLean.Scalar.sqrt" data-verso-hover="95">sqrt</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">ε</span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">‖</span><span class="var token" data-binding="var-_uniq.134" data-verso-hover="226">x</span><span class="unknown token" data-binding="">‖₂²</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-SciLean.term_Rewrite_byAssuming__-21278">rewrite_by</span>
  <span class="tactic"><label for="tactic-state-10394615373954461386-21336-21348"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.Conv.unfold-21336" data-verso-hover="272">unfold</span> <span class="const token" data-binding="const-deriv" data-verso-hover="231">deriv</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-10394615373954461386-21336-21348"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">ε</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.63" data-verso-hover="304">hε</span></td><td class="colon">:</td><td class="type">0<span class="const token" data-binding="const-LT.lt" data-verso-hover="139"> &lt; </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">ε</span></td></tr></table><span class="conclusion"><span class="prefix">| </span><span class="type">∂ <span class="var token" data-binding="var-_uniq.7704" data-verso-hover="226">x</span>, <span class="const token" data-binding="const-SciLean.Scalar.sqrt" data-verso-hover="95">sqrt</span> (<span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">ε</span><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="141"> + </span>‖<span class="var token" data-binding="var-_uniq.7704" data-verso-hover="226">x</span>‖₂²)</span></span></div></div></span>
  <span class="keyword token" data-binding="kw-occ-Mathlib.Meta.FunTrans.funTransConvStx-21351">fun_trans</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-token.disch-21362">disch</span><span class="unknown token" data-binding="">:=</span><span class="tactic"><label for="tactic-state-9167456033761161832-21369-21376"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-21369" data-verso-hover="305">intro</span> <span class="var token" data-binding="var-_uniq.1155" data-verso-hover="226">x</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-9167456033761161832-21369-21376"><div class="tactic-state"><div class="goal"><details open="open"><summary><span class="goal-name">funProp.discharger</span></summary><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">ε</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.63" data-verso-hover="304">hε</span></td><td class="colon">:</td><td class="type">0<span class="const token" data-binding="const-LT.lt" data-verso-hover="139"> &lt; </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">ε</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.1155" data-verso-hover="226">x</span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span><span class="const token" data-binding="const-Prod" data-verso-hover="71"> × </span><span class="const token" data-binding="const-Real" data-verso-hover="223">ℝ</span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.2" data-verso-hover="222">ε</span><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="141"> + </span>‖<span class="var token" data-binding="var-_uniq.1155" data-verso-hover="226">x</span>‖₂²<span class="const token" data-binding="const-Ne" data-verso-hover="243"> ≠ </span>0</span></span></details></div></div></span><span class="unknown token" data-binding="">;</span> <span class="tactic"><label for="tactic-state-7-21378-21408"><span class="keyword token" data-binding="kw-occ-nlinarith-21378" data-verso-hover="306">nlinarith</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-SciLean.norm2_nonneg" data-verso-hover="307">norm2_nonneg</span> <span class="unknown token" data-binding="">ℝ</span> <span class="var token" data-binding="var-_uniq.1155" data-verso-hover="226">x</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-21378-21408"><div class="tactic-state">All goals completed! 🐙</div></span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><div class="information">
              <pre>fun w =&gt; fun x =&gt;L[ℝ] 2 * ⟪x, w⟫_ℝ / (2 * sqrt (ε + ‖w‖₂²)) : ℝ × ℝ → ℝ × ℝ →L[ℝ] ℝ
</pre></div>
            <div class="TODO">
              <p>
                Figuring out the right tactic like <code>intro x; nlinarith [norm2_nonneg ℝ x]</code> can be difficult. Therefore introduce tactic/discharger <code>unsafe_ad_disch</code> that assumes commong AD assumptions and reports them back to user.</p>
              <p>
                Create unsafe mode differentiation which assumes that everything works out. Effectivelly this requires discharger that recognize commong goals that should be sorries or postponed.</p>
              </div>
            </section>
          </section>
        </main></div>
    </body>
  </html>

